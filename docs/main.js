!function(e){var t={};function n(a){if(t[a])return t[a].exports;var r=t[a]={i:a,l:!1,exports:{}};return e[a].call(r.exports,r,r.exports,n),r.l=!0,r.exports}n.m=e,n.c=t,n.d=function(e,t,a){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:a})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var a=Object.create(null);if(n.r(a),Object.defineProperty(a,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var r in e)n.d(a,r,function(t){return e[t]}.bind(null,r));return a},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=10)}([function(e,t){var n;n=function(){return this}();try{n=n||new Function("return this")()}catch(e){"object"==typeof window&&(n=window)}e.exports=n},function(e,t,n){"use strict";(function(e,n){
/*!
 * Vue.js v2.6.12
 * (c) 2014-2020 Evan You
 * Released under the MIT License.
 */
var a=Object.freeze({});function r(e){return null==e}function s(e){return null!=e}function i(e){return!0===e}function o(e){return"string"==typeof e||"number"==typeof e||"symbol"==typeof e||"boolean"==typeof e}function d(e){return null!==e&&"object"==typeof e}var u=Object.prototype.toString;function p(e){return"[object Object]"===u.call(e)}function l(e){return"[object RegExp]"===u.call(e)}function y(e){var t=parseFloat(String(e));return t>=0&&Math.floor(t)===t&&isFinite(e)}function c(e){return s(e)&&"function"==typeof e.then&&"function"==typeof e.catch}function m(e){return null==e?"":Array.isArray(e)||p(e)&&e.toString===u?JSON.stringify(e,null,2):String(e)}function f(e){var t=parseFloat(e);return isNaN(t)?e:t}function h(e,t){for(var n=Object.create(null),a=e.split(","),r=0;r<a.length;r++)n[a[r]]=!0;return t?function(e){return n[e.toLowerCase()]}:function(e){return n[e]}}var v=h("slot,component",!0),T=h("key,ref,slot,slot-scope,is");function b(e,t){if(e.length){var n=e.indexOf(t);if(n>-1)return e.splice(n,1)}}var _=Object.prototype.hasOwnProperty;function g(e,t){return _.call(e,t)}function w(e){var t=Object.create(null);return function(n){return t[n]||(t[n]=e(n))}}var k=/-(\w)/g,R=w((function(e){return e.replace(k,(function(e,t){return t?t.toUpperCase():""}))})),I=w((function(e){return e.charAt(0).toUpperCase()+e.slice(1)})),A=/\B([A-Z])/g,M=w((function(e){return e.replace(A,"-$1").toLowerCase()}));var C=Function.prototype.bind?function(e,t){return e.bind(t)}:function(e,t){function n(n){var a=arguments.length;return a?a>1?e.apply(t,arguments):e.call(t,n):e.call(t)}return n._length=e.length,n};function S(e,t){t=t||0;for(var n=e.length-t,a=new Array(n);n--;)a[n]=e[n+t];return a}function x(e,t){for(var n in t)e[n]=t[n];return e}function E(e){for(var t={},n=0;n<e.length;n++)e[n]&&x(t,e[n]);return t}function F(e,t,n){}var O=function(e,t,n){return!1},N=function(e){return e};function D(e,t){if(e===t)return!0;var n=d(e),a=d(t);if(!n||!a)return!n&&!a&&String(e)===String(t);try{var r=Array.isArray(e),s=Array.isArray(t);if(r&&s)return e.length===t.length&&e.every((function(e,n){return D(e,t[n])}));if(e instanceof Date&&t instanceof Date)return e.getTime()===t.getTime();if(r||s)return!1;var i=Object.keys(e),o=Object.keys(t);return i.length===o.length&&i.every((function(n){return D(e[n],t[n])}))}catch(e){return!1}}function U(e,t){for(var n=0;n<e.length;n++)if(D(e[n],t))return n;return-1}function $(e){var t=!1;return function(){t||(t=!0,e.apply(this,arguments))}}var L=["component","directive","filter"],P=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch"],j={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:O,isReservedAttr:O,isUnknownElement:O,getTagNamespace:F,parsePlatformTagName:N,mustUseProp:O,async:!0,_lifecycleHooks:P},q=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function H(e){var t=(e+"").charCodeAt(0);return 36===t||95===t}function B(e,t,n,a){Object.defineProperty(e,t,{value:n,enumerable:!!a,writable:!0,configurable:!0})}var z=new RegExp("[^"+q.source+".$_\\d]");var G,W="__proto__"in{},V="undefined"!=typeof window,Y="undefined"!=typeof WXEnvironment&&!!WXEnvironment.platform,Q=Y&&WXEnvironment.platform.toLowerCase(),J=V&&window.navigator.userAgent.toLowerCase(),K=J&&/msie|trident/.test(J),X=J&&J.indexOf("msie 9.0")>0,Z=J&&J.indexOf("edge/")>0,ee=(J&&J.indexOf("android"),J&&/iphone|ipad|ipod|ios/.test(J)||"ios"===Q),te=(J&&/chrome\/\d+/.test(J),J&&/phantomjs/.test(J),J&&J.match(/firefox\/(\d+)/)),ne={}.watch,ae=!1;if(V)try{var re={};Object.defineProperty(re,"passive",{get:function(){ae=!0}}),window.addEventListener("test-passive",null,re)}catch(e){}var se=function(){return void 0===G&&(G=!V&&!Y&&void 0!==e&&(e.process&&"server"===e.process.env.VUE_ENV)),G},ie=V&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function oe(e){return"function"==typeof e&&/native code/.test(e.toString())}var de,ue="undefined"!=typeof Symbol&&oe(Symbol)&&"undefined"!=typeof Reflect&&oe(Reflect.ownKeys);de="undefined"!=typeof Set&&oe(Set)?Set:function(){function e(){this.set=Object.create(null)}return e.prototype.has=function(e){return!0===this.set[e]},e.prototype.add=function(e){this.set[e]=!0},e.prototype.clear=function(){this.set=Object.create(null)},e}();var pe=F,le=0,ye=function(){this.id=le++,this.subs=[]};ye.prototype.addSub=function(e){this.subs.push(e)},ye.prototype.removeSub=function(e){b(this.subs,e)},ye.prototype.depend=function(){ye.target&&ye.target.addDep(this)},ye.prototype.notify=function(){var e=this.subs.slice();for(var t=0,n=e.length;t<n;t++)e[t].update()},ye.target=null;var ce=[];function me(e){ce.push(e),ye.target=e}function fe(){ce.pop(),ye.target=ce[ce.length-1]}var he=function(e,t,n,a,r,s,i,o){this.tag=e,this.data=t,this.children=n,this.text=a,this.elm=r,this.ns=void 0,this.context=s,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=t&&t.key,this.componentOptions=i,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=o,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1},ve={child:{configurable:!0}};ve.child.get=function(){return this.componentInstance},Object.defineProperties(he.prototype,ve);var Te=function(e){void 0===e&&(e="");var t=new he;return t.text=e,t.isComment=!0,t};function be(e){return new he(void 0,void 0,void 0,String(e))}function _e(e){var t=new he(e.tag,e.data,e.children&&e.children.slice(),e.text,e.elm,e.context,e.componentOptions,e.asyncFactory);return t.ns=e.ns,t.isStatic=e.isStatic,t.key=e.key,t.isComment=e.isComment,t.fnContext=e.fnContext,t.fnOptions=e.fnOptions,t.fnScopeId=e.fnScopeId,t.asyncMeta=e.asyncMeta,t.isCloned=!0,t}var ge=Array.prototype,we=Object.create(ge);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(e){var t=ge[e];B(we,e,(function(){for(var n=[],a=arguments.length;a--;)n[a]=arguments[a];var r,s=t.apply(this,n),i=this.__ob__;switch(e){case"push":case"unshift":r=n;break;case"splice":r=n.slice(2)}return r&&i.observeArray(r),i.dep.notify(),s}))}));var ke=Object.getOwnPropertyNames(we),Re=!0;function Ie(e){Re=e}var Ae=function(e){this.value=e,this.dep=new ye,this.vmCount=0,B(e,"__ob__",this),Array.isArray(e)?(W?function(e,t){e.__proto__=t}(e,we):function(e,t,n){for(var a=0,r=n.length;a<r;a++){var s=n[a];B(e,s,t[s])}}(e,we,ke),this.observeArray(e)):this.walk(e)};function Me(e,t){var n;if(d(e)&&!(e instanceof he))return g(e,"__ob__")&&e.__ob__ instanceof Ae?n=e.__ob__:Re&&!se()&&(Array.isArray(e)||p(e))&&Object.isExtensible(e)&&!e._isVue&&(n=new Ae(e)),t&&n&&n.vmCount++,n}function Ce(e,t,n,a,r){var s=new ye,i=Object.getOwnPropertyDescriptor(e,t);if(!i||!1!==i.configurable){var o=i&&i.get,d=i&&i.set;o&&!d||2!==arguments.length||(n=e[t]);var u=!r&&Me(n);Object.defineProperty(e,t,{enumerable:!0,configurable:!0,get:function(){var t=o?o.call(e):n;return ye.target&&(s.depend(),u&&(u.dep.depend(),Array.isArray(t)&&Ee(t))),t},set:function(t){var a=o?o.call(e):n;t===a||t!=t&&a!=a||o&&!d||(d?d.call(e,t):n=t,u=!r&&Me(t),s.notify())}})}}function Se(e,t,n){if(Array.isArray(e)&&y(t))return e.length=Math.max(e.length,t),e.splice(t,1,n),n;if(t in e&&!(t in Object.prototype))return e[t]=n,n;var a=e.__ob__;return e._isVue||a&&a.vmCount?n:a?(Ce(a.value,t,n),a.dep.notify(),n):(e[t]=n,n)}function xe(e,t){if(Array.isArray(e)&&y(t))e.splice(t,1);else{var n=e.__ob__;e._isVue||n&&n.vmCount||g(e,t)&&(delete e[t],n&&n.dep.notify())}}function Ee(e){for(var t=void 0,n=0,a=e.length;n<a;n++)(t=e[n])&&t.__ob__&&t.__ob__.dep.depend(),Array.isArray(t)&&Ee(t)}Ae.prototype.walk=function(e){for(var t=Object.keys(e),n=0;n<t.length;n++)Ce(e,t[n])},Ae.prototype.observeArray=function(e){for(var t=0,n=e.length;t<n;t++)Me(e[t])};var Fe=j.optionMergeStrategies;function Oe(e,t){if(!t)return e;for(var n,a,r,s=ue?Reflect.ownKeys(t):Object.keys(t),i=0;i<s.length;i++)"__ob__"!==(n=s[i])&&(a=e[n],r=t[n],g(e,n)?a!==r&&p(a)&&p(r)&&Oe(a,r):Se(e,n,r));return e}function Ne(e,t,n){return n?function(){var a="function"==typeof t?t.call(n,n):t,r="function"==typeof e?e.call(n,n):e;return a?Oe(a,r):r}:t?e?function(){return Oe("function"==typeof t?t.call(this,this):t,"function"==typeof e?e.call(this,this):e)}:t:e}function De(e,t){var n=t?e?e.concat(t):Array.isArray(t)?t:[t]:e;return n?function(e){for(var t=[],n=0;n<e.length;n++)-1===t.indexOf(e[n])&&t.push(e[n]);return t}(n):n}function Ue(e,t,n,a){var r=Object.create(e||null);return t?x(r,t):r}Fe.data=function(e,t,n){return n?Ne(e,t,n):t&&"function"!=typeof t?e:Ne(e,t)},P.forEach((function(e){Fe[e]=De})),L.forEach((function(e){Fe[e+"s"]=Ue})),Fe.watch=function(e,t,n,a){if(e===ne&&(e=void 0),t===ne&&(t=void 0),!t)return Object.create(e||null);if(!e)return t;var r={};for(var s in x(r,e),t){var i=r[s],o=t[s];i&&!Array.isArray(i)&&(i=[i]),r[s]=i?i.concat(o):Array.isArray(o)?o:[o]}return r},Fe.props=Fe.methods=Fe.inject=Fe.computed=function(e,t,n,a){if(!e)return t;var r=Object.create(null);return x(r,e),t&&x(r,t),r},Fe.provide=Ne;var $e=function(e,t){return void 0===t?e:t};function Le(e,t,n){if("function"==typeof t&&(t=t.options),function(e,t){var n=e.props;if(n){var a,r,s={};if(Array.isArray(n))for(a=n.length;a--;)"string"==typeof(r=n[a])&&(s[R(r)]={type:null});else if(p(n))for(var i in n)r=n[i],s[R(i)]=p(r)?r:{type:r};else 0;e.props=s}}(t),function(e,t){var n=e.inject;if(n){var a=e.inject={};if(Array.isArray(n))for(var r=0;r<n.length;r++)a[n[r]]={from:n[r]};else if(p(n))for(var s in n){var i=n[s];a[s]=p(i)?x({from:s},i):{from:i}}else 0}}(t),function(e){var t=e.directives;if(t)for(var n in t){var a=t[n];"function"==typeof a&&(t[n]={bind:a,update:a})}}(t),!t._base&&(t.extends&&(e=Le(e,t.extends,n)),t.mixins))for(var a=0,r=t.mixins.length;a<r;a++)e=Le(e,t.mixins[a],n);var s,i={};for(s in e)o(s);for(s in t)g(e,s)||o(s);function o(a){var r=Fe[a]||$e;i[a]=r(e[a],t[a],n,a)}return i}function Pe(e,t,n,a){if("string"==typeof n){var r=e[t];if(g(r,n))return r[n];var s=R(n);if(g(r,s))return r[s];var i=I(s);return g(r,i)?r[i]:r[n]||r[s]||r[i]}}function je(e,t,n,a){var r=t[e],s=!g(n,e),i=n[e],o=Be(Boolean,r.type);if(o>-1)if(s&&!g(r,"default"))i=!1;else if(""===i||i===M(e)){var d=Be(String,r.type);(d<0||o<d)&&(i=!0)}if(void 0===i){i=function(e,t,n){if(!g(t,"default"))return;var a=t.default;0;if(e&&e.$options.propsData&&void 0===e.$options.propsData[n]&&void 0!==e._props[n])return e._props[n];return"function"==typeof a&&"Function"!==qe(t.type)?a.call(e):a}(a,r,e);var u=Re;Ie(!0),Me(i),Ie(u)}return i}function qe(e){var t=e&&e.toString().match(/^\s*function (\w+)/);return t?t[1]:""}function He(e,t){return qe(e)===qe(t)}function Be(e,t){if(!Array.isArray(t))return He(t,e)?0:-1;for(var n=0,a=t.length;n<a;n++)if(He(t[n],e))return n;return-1}function ze(e,t,n){me();try{if(t)for(var a=t;a=a.$parent;){var r=a.$options.errorCaptured;if(r)for(var s=0;s<r.length;s++)try{if(!1===r[s].call(a,e,t,n))return}catch(e){We(e,a,"errorCaptured hook")}}We(e,t,n)}finally{fe()}}function Ge(e,t,n,a,r){var s;try{(s=n?e.apply(t,n):e.call(t))&&!s._isVue&&c(s)&&!s._handled&&(s.catch((function(e){return ze(e,a,r+" (Promise/async)")})),s._handled=!0)}catch(e){ze(e,a,r)}return s}function We(e,t,n){if(j.errorHandler)try{return j.errorHandler.call(null,e,t,n)}catch(t){t!==e&&Ve(t,null,"config.errorHandler")}Ve(e,t,n)}function Ve(e,t,n){if(!V&&!Y||"undefined"==typeof console)throw e;console.error(e)}var Ye,Qe=!1,Je=[],Ke=!1;function Xe(){Ke=!1;var e=Je.slice(0);Je.length=0;for(var t=0;t<e.length;t++)e[t]()}if("undefined"!=typeof Promise&&oe(Promise)){var Ze=Promise.resolve();Ye=function(){Ze.then(Xe),ee&&setTimeout(F)},Qe=!0}else if(K||"undefined"==typeof MutationObserver||!oe(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Ye=void 0!==n&&oe(n)?function(){n(Xe)}:function(){setTimeout(Xe,0)};else{var et=1,tt=new MutationObserver(Xe),nt=document.createTextNode(String(et));tt.observe(nt,{characterData:!0}),Ye=function(){et=(et+1)%2,nt.data=String(et)},Qe=!0}function at(e,t){var n;if(Je.push((function(){if(e)try{e.call(t)}catch(e){ze(e,t,"nextTick")}else n&&n(t)})),Ke||(Ke=!0,Ye()),!e&&"undefined"!=typeof Promise)return new Promise((function(e){n=e}))}var rt=new de;function st(e){!function e(t,n){var a,r,s=Array.isArray(t);if(!s&&!d(t)||Object.isFrozen(t)||t instanceof he)return;if(t.__ob__){var i=t.__ob__.dep.id;if(n.has(i))return;n.add(i)}if(s)for(a=t.length;a--;)e(t[a],n);else for(r=Object.keys(t),a=r.length;a--;)e(t[r[a]],n)}(e,rt),rt.clear()}var it=w((function(e){var t="&"===e.charAt(0),n="~"===(e=t?e.slice(1):e).charAt(0),a="!"===(e=n?e.slice(1):e).charAt(0);return{name:e=a?e.slice(1):e,once:n,capture:a,passive:t}}));function ot(e,t){function n(){var e=arguments,a=n.fns;if(!Array.isArray(a))return Ge(a,null,arguments,t,"v-on handler");for(var r=a.slice(),s=0;s<r.length;s++)Ge(r[s],null,e,t,"v-on handler")}return n.fns=e,n}function dt(e,t,n,a,s,o){var d,u,p,l;for(d in e)u=e[d],p=t[d],l=it(d),r(u)||(r(p)?(r(u.fns)&&(u=e[d]=ot(u,o)),i(l.once)&&(u=e[d]=s(l.name,u,l.capture)),n(l.name,u,l.capture,l.passive,l.params)):u!==p&&(p.fns=u,e[d]=p));for(d in t)r(e[d])&&a((l=it(d)).name,t[d],l.capture)}function ut(e,t,n){var a;e instanceof he&&(e=e.data.hook||(e.data.hook={}));var o=e[t];function d(){n.apply(this,arguments),b(a.fns,d)}r(o)?a=ot([d]):s(o.fns)&&i(o.merged)?(a=o).fns.push(d):a=ot([o,d]),a.merged=!0,e[t]=a}function pt(e,t,n,a,r){if(s(t)){if(g(t,n))return e[n]=t[n],r||delete t[n],!0;if(g(t,a))return e[n]=t[a],r||delete t[a],!0}return!1}function lt(e){return o(e)?[be(e)]:Array.isArray(e)?function e(t,n){var a,d,u,p,l=[];for(a=0;a<t.length;a++)r(d=t[a])||"boolean"==typeof d||(u=l.length-1,p=l[u],Array.isArray(d)?d.length>0&&(yt((d=e(d,(n||"")+"_"+a))[0])&&yt(p)&&(l[u]=be(p.text+d[0].text),d.shift()),l.push.apply(l,d)):o(d)?yt(p)?l[u]=be(p.text+d):""!==d&&l.push(be(d)):yt(d)&&yt(p)?l[u]=be(p.text+d.text):(i(t._isVList)&&s(d.tag)&&r(d.key)&&s(n)&&(d.key="__vlist"+n+"_"+a+"__"),l.push(d)));return l}(e):void 0}function yt(e){return s(e)&&s(e.text)&&!1===e.isComment}function ct(e,t){if(e){for(var n=Object.create(null),a=ue?Reflect.ownKeys(e):Object.keys(e),r=0;r<a.length;r++){var s=a[r];if("__ob__"!==s){for(var i=e[s].from,o=t;o;){if(o._provided&&g(o._provided,i)){n[s]=o._provided[i];break}o=o.$parent}if(!o)if("default"in e[s]){var d=e[s].default;n[s]="function"==typeof d?d.call(t):d}else 0}}return n}}function mt(e,t){if(!e||!e.length)return{};for(var n={},a=0,r=e.length;a<r;a++){var s=e[a],i=s.data;if(i&&i.attrs&&i.attrs.slot&&delete i.attrs.slot,s.context!==t&&s.fnContext!==t||!i||null==i.slot)(n.default||(n.default=[])).push(s);else{var o=i.slot,d=n[o]||(n[o]=[]);"template"===s.tag?d.push.apply(d,s.children||[]):d.push(s)}}for(var u in n)n[u].every(ft)&&delete n[u];return n}function ft(e){return e.isComment&&!e.asyncFactory||" "===e.text}function ht(e,t,n){var r,s=Object.keys(t).length>0,i=e?!!e.$stable:!s,o=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(i&&n&&n!==a&&o===n.$key&&!s&&!n.$hasNormal)return n;for(var d in r={},e)e[d]&&"$"!==d[0]&&(r[d]=vt(t,d,e[d]))}else r={};for(var u in t)u in r||(r[u]=Tt(t,u));return e&&Object.isExtensible(e)&&(e._normalized=r),B(r,"$stable",i),B(r,"$key",o),B(r,"$hasNormal",s),r}function vt(e,t,n){var a=function(){var e=arguments.length?n.apply(null,arguments):n({});return(e=e&&"object"==typeof e&&!Array.isArray(e)?[e]:lt(e))&&(0===e.length||1===e.length&&e[0].isComment)?void 0:e};return n.proxy&&Object.defineProperty(e,t,{get:a,enumerable:!0,configurable:!0}),a}function Tt(e,t){return function(){return e[t]}}function bt(e,t){var n,a,r,i,o;if(Array.isArray(e)||"string"==typeof e)for(n=new Array(e.length),a=0,r=e.length;a<r;a++)n[a]=t(e[a],a);else if("number"==typeof e)for(n=new Array(e),a=0;a<e;a++)n[a]=t(a+1,a);else if(d(e))if(ue&&e[Symbol.iterator]){n=[];for(var u=e[Symbol.iterator](),p=u.next();!p.done;)n.push(t(p.value,n.length)),p=u.next()}else for(i=Object.keys(e),n=new Array(i.length),a=0,r=i.length;a<r;a++)o=i[a],n[a]=t(e[o],o,a);return s(n)||(n=[]),n._isVList=!0,n}function _t(e,t,n,a){var r,s=this.$scopedSlots[e];s?(n=n||{},a&&(n=x(x({},a),n)),r=s(n)||t):r=this.$slots[e]||t;var i=n&&n.slot;return i?this.$createElement("template",{slot:i},r):r}function gt(e){return Pe(this.$options,"filters",e)||N}function wt(e,t){return Array.isArray(e)?-1===e.indexOf(t):e!==t}function kt(e,t,n,a,r){var s=j.keyCodes[t]||n;return r&&a&&!j.keyCodes[t]?wt(r,a):s?wt(s,e):a?M(a)!==t:void 0}function Rt(e,t,n,a,r){if(n)if(d(n)){var s;Array.isArray(n)&&(n=E(n));var i=function(i){if("class"===i||"style"===i||T(i))s=e;else{var o=e.attrs&&e.attrs.type;s=a||j.mustUseProp(t,o,i)?e.domProps||(e.domProps={}):e.attrs||(e.attrs={})}var d=R(i),u=M(i);d in s||u in s||(s[i]=n[i],r&&((e.on||(e.on={}))["update:"+i]=function(e){n[i]=e}))};for(var o in n)i(o)}else;return e}function It(e,t){var n=this._staticTrees||(this._staticTrees=[]),a=n[e];return a&&!t||Mt(a=n[e]=this.$options.staticRenderFns[e].call(this._renderProxy,null,this),"__static__"+e,!1),a}function At(e,t,n){return Mt(e,"__once__"+t+(n?"_"+n:""),!0),e}function Mt(e,t,n){if(Array.isArray(e))for(var a=0;a<e.length;a++)e[a]&&"string"!=typeof e[a]&&Ct(e[a],t+"_"+a,n);else Ct(e,t,n)}function Ct(e,t,n){e.isStatic=!0,e.key=t,e.isOnce=n}function St(e,t){if(t)if(p(t)){var n=e.on=e.on?x({},e.on):{};for(var a in t){var r=n[a],s=t[a];n[a]=r?[].concat(r,s):s}}else;return e}function xt(e,t,n,a){t=t||{$stable:!n};for(var r=0;r<e.length;r++){var s=e[r];Array.isArray(s)?xt(s,t,n):s&&(s.proxy&&(s.fn.proxy=!0),t[s.key]=s.fn)}return a&&(t.$key=a),t}function Et(e,t){for(var n=0;n<t.length;n+=2){var a=t[n];"string"==typeof a&&a&&(e[t[n]]=t[n+1])}return e}function Ft(e,t){return"string"==typeof e?t+e:e}function Ot(e){e._o=At,e._n=f,e._s=m,e._l=bt,e._t=_t,e._q=D,e._i=U,e._m=It,e._f=gt,e._k=kt,e._b=Rt,e._v=be,e._e=Te,e._u=xt,e._g=St,e._d=Et,e._p=Ft}function Nt(e,t,n,r,s){var o,d=this,u=s.options;g(r,"_uid")?(o=Object.create(r))._original=r:(o=r,r=r._original);var p=i(u._compiled),l=!p;this.data=e,this.props=t,this.children=n,this.parent=r,this.listeners=e.on||a,this.injections=ct(u.inject,r),this.slots=function(){return d.$slots||ht(e.scopedSlots,d.$slots=mt(n,r)),d.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return ht(e.scopedSlots,this.slots())}}),p&&(this.$options=u,this.$slots=this.slots(),this.$scopedSlots=ht(e.scopedSlots,this.$slots)),u._scopeId?this._c=function(e,t,n,a){var s=qt(o,e,t,n,a,l);return s&&!Array.isArray(s)&&(s.fnScopeId=u._scopeId,s.fnContext=r),s}:this._c=function(e,t,n,a){return qt(o,e,t,n,a,l)}}function Dt(e,t,n,a,r){var s=_e(e);return s.fnContext=n,s.fnOptions=a,t.slot&&((s.data||(s.data={})).slot=t.slot),s}function Ut(e,t){for(var n in t)e[R(n)]=t[n]}Ot(Nt.prototype);var $t={init:function(e,t){if(e.componentInstance&&!e.componentInstance._isDestroyed&&e.data.keepAlive){var n=e;$t.prepatch(n,n)}else{(e.componentInstance=function(e,t){var n={_isComponent:!0,_parentVnode:e,parent:t},a=e.data.inlineTemplate;s(a)&&(n.render=a.render,n.staticRenderFns=a.staticRenderFns);return new e.componentOptions.Ctor(n)}(e,Kt)).$mount(t?e.elm:void 0,t)}},prepatch:function(e,t){var n=t.componentOptions;!function(e,t,n,r,s){0;var i=r.data.scopedSlots,o=e.$scopedSlots,d=!!(i&&!i.$stable||o!==a&&!o.$stable||i&&e.$scopedSlots.$key!==i.$key),u=!!(s||e.$options._renderChildren||d);e.$options._parentVnode=r,e.$vnode=r,e._vnode&&(e._vnode.parent=r);if(e.$options._renderChildren=s,e.$attrs=r.data.attrs||a,e.$listeners=n||a,t&&e.$options.props){Ie(!1);for(var p=e._props,l=e.$options._propKeys||[],y=0;y<l.length;y++){var c=l[y],m=e.$options.props;p[c]=je(c,m,t,e)}Ie(!0),e.$options.propsData=t}n=n||a;var f=e.$options._parentListeners;e.$options._parentListeners=n,Jt(e,n,f),u&&(e.$slots=mt(s,r.context),e.$forceUpdate());0}(t.componentInstance=e.componentInstance,n.propsData,n.listeners,t,n.children)},insert:function(e){var t,n=e.context,a=e.componentInstance;a._isMounted||(a._isMounted=!0,tn(a,"mounted")),e.data.keepAlive&&(n._isMounted?((t=a)._inactive=!1,an.push(t)):en(a,!0))},destroy:function(e){var t=e.componentInstance;t._isDestroyed||(e.data.keepAlive?function e(t,n){if(n&&(t._directInactive=!0,Zt(t)))return;if(!t._inactive){t._inactive=!0;for(var a=0;a<t.$children.length;a++)e(t.$children[a]);tn(t,"deactivated")}}(t,!0):t.$destroy())}},Lt=Object.keys($t);function Pt(e,t,n,o,u){if(!r(e)){var p=n.$options._base;if(d(e)&&(e=p.extend(e)),"function"==typeof e){var l;if(r(e.cid)&&void 0===(e=function(e,t){if(i(e.error)&&s(e.errorComp))return e.errorComp;if(s(e.resolved))return e.resolved;var n=Bt;n&&s(e.owners)&&-1===e.owners.indexOf(n)&&e.owners.push(n);if(i(e.loading)&&s(e.loadingComp))return e.loadingComp;if(n&&!s(e.owners)){var a=e.owners=[n],o=!0,u=null,p=null;n.$on("hook:destroyed",(function(){return b(a,n)}));var l=function(e){for(var t=0,n=a.length;t<n;t++)a[t].$forceUpdate();e&&(a.length=0,null!==u&&(clearTimeout(u),u=null),null!==p&&(clearTimeout(p),p=null))},y=$((function(n){e.resolved=zt(n,t),o?a.length=0:l(!0)})),m=$((function(t){s(e.errorComp)&&(e.error=!0,l(!0))})),f=e(y,m);return d(f)&&(c(f)?r(e.resolved)&&f.then(y,m):c(f.component)&&(f.component.then(y,m),s(f.error)&&(e.errorComp=zt(f.error,t)),s(f.loading)&&(e.loadingComp=zt(f.loading,t),0===f.delay?e.loading=!0:u=setTimeout((function(){u=null,r(e.resolved)&&r(e.error)&&(e.loading=!0,l(!1))}),f.delay||200)),s(f.timeout)&&(p=setTimeout((function(){p=null,r(e.resolved)&&m(null)}),f.timeout)))),o=!1,e.loading?e.loadingComp:e.resolved}}(l=e,p)))return function(e,t,n,a,r){var s=Te();return s.asyncFactory=e,s.asyncMeta={data:t,context:n,children:a,tag:r},s}(l,t,n,o,u);t=t||{},Rn(e),s(t.model)&&function(e,t){var n=e.model&&e.model.prop||"value",a=e.model&&e.model.event||"input";(t.attrs||(t.attrs={}))[n]=t.model.value;var r=t.on||(t.on={}),i=r[a],o=t.model.callback;s(i)?(Array.isArray(i)?-1===i.indexOf(o):i!==o)&&(r[a]=[o].concat(i)):r[a]=o}(e.options,t);var y=function(e,t,n){var a=t.options.props;if(!r(a)){var i={},o=e.attrs,d=e.props;if(s(o)||s(d))for(var u in a){var p=M(u);pt(i,d,u,p,!0)||pt(i,o,u,p,!1)}return i}}(t,e);if(i(e.options.functional))return function(e,t,n,r,i){var o=e.options,d={},u=o.props;if(s(u))for(var p in u)d[p]=je(p,u,t||a);else s(n.attrs)&&Ut(d,n.attrs),s(n.props)&&Ut(d,n.props);var l=new Nt(n,d,i,r,e),y=o.render.call(null,l._c,l);if(y instanceof he)return Dt(y,n,l.parent,o,l);if(Array.isArray(y)){for(var c=lt(y)||[],m=new Array(c.length),f=0;f<c.length;f++)m[f]=Dt(c[f],n,l.parent,o,l);return m}}(e,y,t,n,o);var m=t.on;if(t.on=t.nativeOn,i(e.options.abstract)){var f=t.slot;t={},f&&(t.slot=f)}!function(e){for(var t=e.hook||(e.hook={}),n=0;n<Lt.length;n++){var a=Lt[n],r=t[a],s=$t[a];r===s||r&&r._merged||(t[a]=r?jt(s,r):s)}}(t);var h=e.options.name||u;return new he("vue-component-"+e.cid+(h?"-"+h:""),t,void 0,void 0,void 0,n,{Ctor:e,propsData:y,listeners:m,tag:u,children:o},l)}}}function jt(e,t){var n=function(n,a){e(n,a),t(n,a)};return n._merged=!0,n}function qt(e,t,n,a,u,p){return(Array.isArray(n)||o(n))&&(u=a,a=n,n=void 0),i(p)&&(u=2),function(e,t,n,a,o){if(s(n)&&s(n.__ob__))return Te();s(n)&&s(n.is)&&(t=n.is);if(!t)return Te();0;Array.isArray(a)&&"function"==typeof a[0]&&((n=n||{}).scopedSlots={default:a[0]},a.length=0);2===o?a=lt(a):1===o&&(a=function(e){for(var t=0;t<e.length;t++)if(Array.isArray(e[t]))return Array.prototype.concat.apply([],e);return e}(a));var u,p;if("string"==typeof t){var l;p=e.$vnode&&e.$vnode.ns||j.getTagNamespace(t),u=j.isReservedTag(t)?new he(j.parsePlatformTagName(t),n,a,void 0,void 0,e):n&&n.pre||!s(l=Pe(e.$options,"components",t))?new he(t,n,a,void 0,void 0,e):Pt(l,n,e,a,t)}else u=Pt(t,n,e,a);return Array.isArray(u)?u:s(u)?(s(p)&&function e(t,n,a){t.ns=n,"foreignObject"===t.tag&&(n=void 0,a=!0);if(s(t.children))for(var o=0,d=t.children.length;o<d;o++){var u=t.children[o];s(u.tag)&&(r(u.ns)||i(a)&&"svg"!==u.tag)&&e(u,n,a)}}(u,p),s(n)&&function(e){d(e.style)&&st(e.style);d(e.class)&&st(e.class)}(n),u):Te()}(e,t,n,a,u)}var Ht,Bt=null;function zt(e,t){return(e.__esModule||ue&&"Module"===e[Symbol.toStringTag])&&(e=e.default),d(e)?t.extend(e):e}function Gt(e){return e.isComment&&e.asyncFactory}function Wt(e){if(Array.isArray(e))for(var t=0;t<e.length;t++){var n=e[t];if(s(n)&&(s(n.componentOptions)||Gt(n)))return n}}function Vt(e,t){Ht.$on(e,t)}function Yt(e,t){Ht.$off(e,t)}function Qt(e,t){var n=Ht;return function a(){var r=t.apply(null,arguments);null!==r&&n.$off(e,a)}}function Jt(e,t,n){Ht=e,dt(t,n||{},Vt,Yt,Qt,e),Ht=void 0}var Kt=null;function Xt(e){var t=Kt;return Kt=e,function(){Kt=t}}function Zt(e){for(;e&&(e=e.$parent);)if(e._inactive)return!0;return!1}function en(e,t){if(t){if(e._directInactive=!1,Zt(e))return}else if(e._directInactive)return;if(e._inactive||null===e._inactive){e._inactive=!1;for(var n=0;n<e.$children.length;n++)en(e.$children[n]);tn(e,"activated")}}function tn(e,t){me();var n=e.$options[t],a=t+" hook";if(n)for(var r=0,s=n.length;r<s;r++)Ge(n[r],e,null,e,a);e._hasHookEvent&&e.$emit("hook:"+t),fe()}var nn=[],an=[],rn={},sn=!1,on=!1,dn=0;var un=0,pn=Date.now;if(V&&!K){var ln=window.performance;ln&&"function"==typeof ln.now&&pn()>document.createEvent("Event").timeStamp&&(pn=function(){return ln.now()})}function yn(){var e,t;for(un=pn(),on=!0,nn.sort((function(e,t){return e.id-t.id})),dn=0;dn<nn.length;dn++)(e=nn[dn]).before&&e.before(),t=e.id,rn[t]=null,e.run();var n=an.slice(),a=nn.slice();dn=nn.length=an.length=0,rn={},sn=on=!1,function(e){for(var t=0;t<e.length;t++)e[t]._inactive=!0,en(e[t],!0)}(n),function(e){var t=e.length;for(;t--;){var n=e[t],a=n.vm;a._watcher===n&&a._isMounted&&!a._isDestroyed&&tn(a,"updated")}}(a),ie&&j.devtools&&ie.emit("flush")}var cn=0,mn=function(e,t,n,a,r){this.vm=e,r&&(e._watcher=this),e._watchers.push(this),a?(this.deep=!!a.deep,this.user=!!a.user,this.lazy=!!a.lazy,this.sync=!!a.sync,this.before=a.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=n,this.id=++cn,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new de,this.newDepIds=new de,this.expression="","function"==typeof t?this.getter=t:(this.getter=function(e){if(!z.test(e)){var t=e.split(".");return function(e){for(var n=0;n<t.length;n++){if(!e)return;e=e[t[n]]}return e}}}(t),this.getter||(this.getter=F)),this.value=this.lazy?void 0:this.get()};mn.prototype.get=function(){var e;me(this);var t=this.vm;try{e=this.getter.call(t,t)}catch(e){if(!this.user)throw e;ze(e,t,'getter for watcher "'+this.expression+'"')}finally{this.deep&&st(e),fe(),this.cleanupDeps()}return e},mn.prototype.addDep=function(e){var t=e.id;this.newDepIds.has(t)||(this.newDepIds.add(t),this.newDeps.push(e),this.depIds.has(t)||e.addSub(this))},mn.prototype.cleanupDeps=function(){for(var e=this.deps.length;e--;){var t=this.deps[e];this.newDepIds.has(t.id)||t.removeSub(this)}var n=this.depIds;this.depIds=this.newDepIds,this.newDepIds=n,this.newDepIds.clear(),n=this.deps,this.deps=this.newDeps,this.newDeps=n,this.newDeps.length=0},mn.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(e){var t=e.id;if(null==rn[t]){if(rn[t]=!0,on){for(var n=nn.length-1;n>dn&&nn[n].id>e.id;)n--;nn.splice(n+1,0,e)}else nn.push(e);sn||(sn=!0,at(yn))}}(this)},mn.prototype.run=function(){if(this.active){var e=this.get();if(e!==this.value||d(e)||this.deep){var t=this.value;if(this.value=e,this.user)try{this.cb.call(this.vm,e,t)}catch(e){ze(e,this.vm,'callback for watcher "'+this.expression+'"')}else this.cb.call(this.vm,e,t)}}},mn.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},mn.prototype.depend=function(){for(var e=this.deps.length;e--;)this.deps[e].depend()},mn.prototype.teardown=function(){if(this.active){this.vm._isBeingDestroyed||b(this.vm._watchers,this);for(var e=this.deps.length;e--;)this.deps[e].removeSub(this);this.active=!1}};var fn={enumerable:!0,configurable:!0,get:F,set:F};function hn(e,t,n){fn.get=function(){return this[t][n]},fn.set=function(e){this[t][n]=e},Object.defineProperty(e,n,fn)}function vn(e){e._watchers=[];var t=e.$options;t.props&&function(e,t){var n=e.$options.propsData||{},a=e._props={},r=e.$options._propKeys=[];e.$parent&&Ie(!1);var s=function(s){r.push(s);var i=je(s,t,n,e);Ce(a,s,i),s in e||hn(e,"_props",s)};for(var i in t)s(i);Ie(!0)}(e,t.props),t.methods&&function(e,t){e.$options.props;for(var n in t)e[n]="function"!=typeof t[n]?F:C(t[n],e)}(e,t.methods),t.data?function(e){var t=e.$options.data;p(t=e._data="function"==typeof t?function(e,t){me();try{return e.call(t,t)}catch(e){return ze(e,t,"data()"),{}}finally{fe()}}(t,e):t||{})||(t={});var n=Object.keys(t),a=e.$options.props,r=(e.$options.methods,n.length);for(;r--;){var s=n[r];0,a&&g(a,s)||H(s)||hn(e,"_data",s)}Me(t,!0)}(e):Me(e._data={},!0),t.computed&&function(e,t){var n=e._computedWatchers=Object.create(null),a=se();for(var r in t){var s=t[r],i="function"==typeof s?s:s.get;0,a||(n[r]=new mn(e,i||F,F,Tn)),r in e||bn(e,r,s)}}(e,t.computed),t.watch&&t.watch!==ne&&function(e,t){for(var n in t){var a=t[n];if(Array.isArray(a))for(var r=0;r<a.length;r++)wn(e,n,a[r]);else wn(e,n,a)}}(e,t.watch)}var Tn={lazy:!0};function bn(e,t,n){var a=!se();"function"==typeof n?(fn.get=a?_n(t):gn(n),fn.set=F):(fn.get=n.get?a&&!1!==n.cache?_n(t):gn(n.get):F,fn.set=n.set||F),Object.defineProperty(e,t,fn)}function _n(e){return function(){var t=this._computedWatchers&&this._computedWatchers[e];if(t)return t.dirty&&t.evaluate(),ye.target&&t.depend(),t.value}}function gn(e){return function(){return e.call(this,this)}}function wn(e,t,n,a){return p(n)&&(a=n,n=n.handler),"string"==typeof n&&(n=e[n]),e.$watch(t,n,a)}var kn=0;function Rn(e){var t=e.options;if(e.super){var n=Rn(e.super);if(n!==e.superOptions){e.superOptions=n;var a=function(e){var t,n=e.options,a=e.sealedOptions;for(var r in n)n[r]!==a[r]&&(t||(t={}),t[r]=n[r]);return t}(e);a&&x(e.extendOptions,a),(t=e.options=Le(n,e.extendOptions)).name&&(t.components[t.name]=e)}}return t}function In(e){this._init(e)}function An(e){e.cid=0;var t=1;e.extend=function(e){e=e||{};var n=this,a=n.cid,r=e._Ctor||(e._Ctor={});if(r[a])return r[a];var s=e.name||n.options.name;var i=function(e){this._init(e)};return(i.prototype=Object.create(n.prototype)).constructor=i,i.cid=t++,i.options=Le(n.options,e),i.super=n,i.options.props&&function(e){var t=e.options.props;for(var n in t)hn(e.prototype,"_props",n)}(i),i.options.computed&&function(e){var t=e.options.computed;for(var n in t)bn(e.prototype,n,t[n])}(i),i.extend=n.extend,i.mixin=n.mixin,i.use=n.use,L.forEach((function(e){i[e]=n[e]})),s&&(i.options.components[s]=i),i.superOptions=n.options,i.extendOptions=e,i.sealedOptions=x({},i.options),r[a]=i,i}}function Mn(e){return e&&(e.Ctor.options.name||e.tag)}function Cn(e,t){return Array.isArray(e)?e.indexOf(t)>-1:"string"==typeof e?e.split(",").indexOf(t)>-1:!!l(e)&&e.test(t)}function Sn(e,t){var n=e.cache,a=e.keys,r=e._vnode;for(var s in n){var i=n[s];if(i){var o=Mn(i.componentOptions);o&&!t(o)&&xn(n,s,a,r)}}}function xn(e,t,n,a){var r=e[t];!r||a&&r.tag===a.tag||r.componentInstance.$destroy(),e[t]=null,b(n,t)}!function(e){e.prototype._init=function(e){var t=this;t._uid=kn++,t._isVue=!0,e&&e._isComponent?function(e,t){var n=e.$options=Object.create(e.constructor.options),a=t._parentVnode;n.parent=t.parent,n._parentVnode=a;var r=a.componentOptions;n.propsData=r.propsData,n._parentListeners=r.listeners,n._renderChildren=r.children,n._componentTag=r.tag,t.render&&(n.render=t.render,n.staticRenderFns=t.staticRenderFns)}(t,e):t.$options=Le(Rn(t.constructor),e||{},t),t._renderProxy=t,t._self=t,function(e){var t=e.$options,n=t.parent;if(n&&!t.abstract){for(;n.$options.abstract&&n.$parent;)n=n.$parent;n.$children.push(e)}e.$parent=n,e.$root=n?n.$root:e,e.$children=[],e.$refs={},e._watcher=null,e._inactive=null,e._directInactive=!1,e._isMounted=!1,e._isDestroyed=!1,e._isBeingDestroyed=!1}(t),function(e){e._events=Object.create(null),e._hasHookEvent=!1;var t=e.$options._parentListeners;t&&Jt(e,t)}(t),function(e){e._vnode=null,e._staticTrees=null;var t=e.$options,n=e.$vnode=t._parentVnode,r=n&&n.context;e.$slots=mt(t._renderChildren,r),e.$scopedSlots=a,e._c=function(t,n,a,r){return qt(e,t,n,a,r,!1)},e.$createElement=function(t,n,a,r){return qt(e,t,n,a,r,!0)};var s=n&&n.data;Ce(e,"$attrs",s&&s.attrs||a,null,!0),Ce(e,"$listeners",t._parentListeners||a,null,!0)}(t),tn(t,"beforeCreate"),function(e){var t=ct(e.$options.inject,e);t&&(Ie(!1),Object.keys(t).forEach((function(n){Ce(e,n,t[n])})),Ie(!0))}(t),vn(t),function(e){var t=e.$options.provide;t&&(e._provided="function"==typeof t?t.call(e):t)}(t),tn(t,"created"),t.$options.el&&t.$mount(t.$options.el)}}(In),function(e){var t={get:function(){return this._data}},n={get:function(){return this._props}};Object.defineProperty(e.prototype,"$data",t),Object.defineProperty(e.prototype,"$props",n),e.prototype.$set=Se,e.prototype.$delete=xe,e.prototype.$watch=function(e,t,n){if(p(t))return wn(this,e,t,n);(n=n||{}).user=!0;var a=new mn(this,e,t,n);if(n.immediate)try{t.call(this,a.value)}catch(e){ze(e,this,'callback for immediate watcher "'+a.expression+'"')}return function(){a.teardown()}}}(In),function(e){var t=/^hook:/;e.prototype.$on=function(e,n){var a=this;if(Array.isArray(e))for(var r=0,s=e.length;r<s;r++)a.$on(e[r],n);else(a._events[e]||(a._events[e]=[])).push(n),t.test(e)&&(a._hasHookEvent=!0);return a},e.prototype.$once=function(e,t){var n=this;function a(){n.$off(e,a),t.apply(n,arguments)}return a.fn=t,n.$on(e,a),n},e.prototype.$off=function(e,t){var n=this;if(!arguments.length)return n._events=Object.create(null),n;if(Array.isArray(e)){for(var a=0,r=e.length;a<r;a++)n.$off(e[a],t);return n}var s,i=n._events[e];if(!i)return n;if(!t)return n._events[e]=null,n;for(var o=i.length;o--;)if((s=i[o])===t||s.fn===t){i.splice(o,1);break}return n},e.prototype.$emit=function(e){var t=this,n=t._events[e];if(n){n=n.length>1?S(n):n;for(var a=S(arguments,1),r='event handler for "'+e+'"',s=0,i=n.length;s<i;s++)Ge(n[s],t,a,t,r)}return t}}(In),function(e){e.prototype._update=function(e,t){var n=this,a=n.$el,r=n._vnode,s=Xt(n);n._vnode=e,n.$el=r?n.__patch__(r,e):n.__patch__(n.$el,e,t,!1),s(),a&&(a.__vue__=null),n.$el&&(n.$el.__vue__=n),n.$vnode&&n.$parent&&n.$vnode===n.$parent._vnode&&(n.$parent.$el=n.$el)},e.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},e.prototype.$destroy=function(){var e=this;if(!e._isBeingDestroyed){tn(e,"beforeDestroy"),e._isBeingDestroyed=!0;var t=e.$parent;!t||t._isBeingDestroyed||e.$options.abstract||b(t.$children,e),e._watcher&&e._watcher.teardown();for(var n=e._watchers.length;n--;)e._watchers[n].teardown();e._data.__ob__&&e._data.__ob__.vmCount--,e._isDestroyed=!0,e.__patch__(e._vnode,null),tn(e,"destroyed"),e.$off(),e.$el&&(e.$el.__vue__=null),e.$vnode&&(e.$vnode.parent=null)}}}(In),function(e){Ot(e.prototype),e.prototype.$nextTick=function(e){return at(e,this)},e.prototype._render=function(){var e,t=this,n=t.$options,a=n.render,r=n._parentVnode;r&&(t.$scopedSlots=ht(r.data.scopedSlots,t.$slots,t.$scopedSlots)),t.$vnode=r;try{Bt=t,e=a.call(t._renderProxy,t.$createElement)}catch(n){ze(n,t,"render"),e=t._vnode}finally{Bt=null}return Array.isArray(e)&&1===e.length&&(e=e[0]),e instanceof he||(e=Te()),e.parent=r,e}}(In);var En=[String,RegExp,Array],Fn={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:En,exclude:En,max:[String,Number]},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var e in this.cache)xn(this.cache,e,this.keys)},mounted:function(){var e=this;this.$watch("include",(function(t){Sn(e,(function(e){return Cn(t,e)}))})),this.$watch("exclude",(function(t){Sn(e,(function(e){return!Cn(t,e)}))}))},render:function(){var e=this.$slots.default,t=Wt(e),n=t&&t.componentOptions;if(n){var a=Mn(n),r=this.include,s=this.exclude;if(r&&(!a||!Cn(r,a))||s&&a&&Cn(s,a))return t;var i=this.cache,o=this.keys,d=null==t.key?n.Ctor.cid+(n.tag?"::"+n.tag:""):t.key;i[d]?(t.componentInstance=i[d].componentInstance,b(o,d),o.push(d)):(i[d]=t,o.push(d),this.max&&o.length>parseInt(this.max)&&xn(i,o[0],o,this._vnode)),t.data.keepAlive=!0}return t||e&&e[0]}}};!function(e){var t={get:function(){return j}};Object.defineProperty(e,"config",t),e.util={warn:pe,extend:x,mergeOptions:Le,defineReactive:Ce},e.set=Se,e.delete=xe,e.nextTick=at,e.observable=function(e){return Me(e),e},e.options=Object.create(null),L.forEach((function(t){e.options[t+"s"]=Object.create(null)})),e.options._base=e,x(e.options.components,Fn),function(e){e.use=function(e){var t=this._installedPlugins||(this._installedPlugins=[]);if(t.indexOf(e)>-1)return this;var n=S(arguments,1);return n.unshift(this),"function"==typeof e.install?e.install.apply(e,n):"function"==typeof e&&e.apply(null,n),t.push(e),this}}(e),function(e){e.mixin=function(e){return this.options=Le(this.options,e),this}}(e),An(e),function(e){L.forEach((function(t){e[t]=function(e,n){return n?("component"===t&&p(n)&&(n.name=n.name||e,n=this.options._base.extend(n)),"directive"===t&&"function"==typeof n&&(n={bind:n,update:n}),this.options[t+"s"][e]=n,n):this.options[t+"s"][e]}}))}(e)}(In),Object.defineProperty(In.prototype,"$isServer",{get:se}),Object.defineProperty(In.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(In,"FunctionalRenderContext",{value:Nt}),In.version="2.6.12";var On=h("style,class"),Nn=h("input,textarea,option,select,progress"),Dn=function(e,t,n){return"value"===n&&Nn(e)&&"button"!==t||"selected"===n&&"option"===e||"checked"===n&&"input"===e||"muted"===n&&"video"===e},Un=h("contenteditable,draggable,spellcheck"),$n=h("events,caret,typing,plaintext-only"),Ln=h("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,translate,truespeed,typemustmatch,visible"),Pn="http://www.w3.org/1999/xlink",jn=function(e){return":"===e.charAt(5)&&"xlink"===e.slice(0,5)},qn=function(e){return jn(e)?e.slice(6,e.length):""},Hn=function(e){return null==e||!1===e};function Bn(e){for(var t=e.data,n=e,a=e;s(a.componentInstance);)(a=a.componentInstance._vnode)&&a.data&&(t=zn(a.data,t));for(;s(n=n.parent);)n&&n.data&&(t=zn(t,n.data));return function(e,t){if(s(e)||s(t))return Gn(e,Wn(t));return""}(t.staticClass,t.class)}function zn(e,t){return{staticClass:Gn(e.staticClass,t.staticClass),class:s(e.class)?[e.class,t.class]:t.class}}function Gn(e,t){return e?t?e+" "+t:e:t||""}function Wn(e){return Array.isArray(e)?function(e){for(var t,n="",a=0,r=e.length;a<r;a++)s(t=Wn(e[a]))&&""!==t&&(n&&(n+=" "),n+=t);return n}(e):d(e)?function(e){var t="";for(var n in e)e[n]&&(t&&(t+=" "),t+=n);return t}(e):"string"==typeof e?e:""}var Vn={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},Yn=h("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),Qn=h("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),Jn=function(e){return Yn(e)||Qn(e)};function Kn(e){return Qn(e)?"svg":"math"===e?"math":void 0}var Xn=Object.create(null);var Zn=h("text,number,password,search,email,tel,url");function ea(e){if("string"==typeof e){var t=document.querySelector(e);return t||document.createElement("div")}return e}var ta=Object.freeze({createElement:function(e,t){var n=document.createElement(e);return"select"!==e||t.data&&t.data.attrs&&void 0!==t.data.attrs.multiple&&n.setAttribute("multiple","multiple"),n},createElementNS:function(e,t){return document.createElementNS(Vn[e],t)},createTextNode:function(e){return document.createTextNode(e)},createComment:function(e){return document.createComment(e)},insertBefore:function(e,t,n){e.insertBefore(t,n)},removeChild:function(e,t){e.removeChild(t)},appendChild:function(e,t){e.appendChild(t)},parentNode:function(e){return e.parentNode},nextSibling:function(e){return e.nextSibling},tagName:function(e){return e.tagName},setTextContent:function(e,t){e.textContent=t},setStyleScope:function(e,t){e.setAttribute(t,"")}}),na={create:function(e,t){aa(t)},update:function(e,t){e.data.ref!==t.data.ref&&(aa(e,!0),aa(t))},destroy:function(e){aa(e,!0)}};function aa(e,t){var n=e.data.ref;if(s(n)){var a=e.context,r=e.componentInstance||e.elm,i=a.$refs;t?Array.isArray(i[n])?b(i[n],r):i[n]===r&&(i[n]=void 0):e.data.refInFor?Array.isArray(i[n])?i[n].indexOf(r)<0&&i[n].push(r):i[n]=[r]:i[n]=r}}var ra=new he("",{},[]),sa=["create","activate","update","remove","destroy"];function ia(e,t){return e.key===t.key&&(e.tag===t.tag&&e.isComment===t.isComment&&s(e.data)===s(t.data)&&function(e,t){if("input"!==e.tag)return!0;var n,a=s(n=e.data)&&s(n=n.attrs)&&n.type,r=s(n=t.data)&&s(n=n.attrs)&&n.type;return a===r||Zn(a)&&Zn(r)}(e,t)||i(e.isAsyncPlaceholder)&&e.asyncFactory===t.asyncFactory&&r(t.asyncFactory.error))}function oa(e,t,n){var a,r,i={};for(a=t;a<=n;++a)s(r=e[a].key)&&(i[r]=a);return i}var da={create:ua,update:ua,destroy:function(e){ua(e,ra)}};function ua(e,t){(e.data.directives||t.data.directives)&&function(e,t){var n,a,r,s=e===ra,i=t===ra,o=la(e.data.directives,e.context),d=la(t.data.directives,t.context),u=[],p=[];for(n in d)a=o[n],r=d[n],a?(r.oldValue=a.value,r.oldArg=a.arg,ca(r,"update",t,e),r.def&&r.def.componentUpdated&&p.push(r)):(ca(r,"bind",t,e),r.def&&r.def.inserted&&u.push(r));if(u.length){var l=function(){for(var n=0;n<u.length;n++)ca(u[n],"inserted",t,e)};s?ut(t,"insert",l):l()}p.length&&ut(t,"postpatch",(function(){for(var n=0;n<p.length;n++)ca(p[n],"componentUpdated",t,e)}));if(!s)for(n in o)d[n]||ca(o[n],"unbind",e,e,i)}(e,t)}var pa=Object.create(null);function la(e,t){var n,a,r=Object.create(null);if(!e)return r;for(n=0;n<e.length;n++)(a=e[n]).modifiers||(a.modifiers=pa),r[ya(a)]=a,a.def=Pe(t.$options,"directives",a.name);return r}function ya(e){return e.rawName||e.name+"."+Object.keys(e.modifiers||{}).join(".")}function ca(e,t,n,a,r){var s=e.def&&e.def[t];if(s)try{s(n.elm,e,n,a,r)}catch(a){ze(a,n.context,"directive "+e.name+" "+t+" hook")}}var ma=[na,da];function fa(e,t){var n=t.componentOptions;if(!(s(n)&&!1===n.Ctor.options.inheritAttrs||r(e.data.attrs)&&r(t.data.attrs))){var a,i,o=t.elm,d=e.data.attrs||{},u=t.data.attrs||{};for(a in s(u.__ob__)&&(u=t.data.attrs=x({},u)),u)i=u[a],d[a]!==i&&ha(o,a,i);for(a in(K||Z)&&u.value!==d.value&&ha(o,"value",u.value),d)r(u[a])&&(jn(a)?o.removeAttributeNS(Pn,qn(a)):Un(a)||o.removeAttribute(a))}}function ha(e,t,n){e.tagName.indexOf("-")>-1?va(e,t,n):Ln(t)?Hn(n)?e.removeAttribute(t):(n="allowfullscreen"===t&&"EMBED"===e.tagName?"true":t,e.setAttribute(t,n)):Un(t)?e.setAttribute(t,function(e,t){return Hn(t)||"false"===t?"false":"contenteditable"===e&&$n(t)?t:"true"}(t,n)):jn(t)?Hn(n)?e.removeAttributeNS(Pn,qn(t)):e.setAttributeNS(Pn,t,n):va(e,t,n)}function va(e,t,n){if(Hn(n))e.removeAttribute(t);else{if(K&&!X&&"TEXTAREA"===e.tagName&&"placeholder"===t&&""!==n&&!e.__ieph){var a=function(t){t.stopImmediatePropagation(),e.removeEventListener("input",a)};e.addEventListener("input",a),e.__ieph=!0}e.setAttribute(t,n)}}var Ta={create:fa,update:fa};function ba(e,t){var n=t.elm,a=t.data,i=e.data;if(!(r(a.staticClass)&&r(a.class)&&(r(i)||r(i.staticClass)&&r(i.class)))){var o=Bn(t),d=n._transitionClasses;s(d)&&(o=Gn(o,Wn(d))),o!==n._prevClass&&(n.setAttribute("class",o),n._prevClass=o)}}var _a,ga,wa,ka,Ra,Ia,Aa={create:ba,update:ba},Ma=/[\w).+\-_$\]]/;function Ca(e){var t,n,a,r,s,i=!1,o=!1,d=!1,u=!1,p=0,l=0,y=0,c=0;for(a=0;a<e.length;a++)if(n=t,t=e.charCodeAt(a),i)39===t&&92!==n&&(i=!1);else if(o)34===t&&92!==n&&(o=!1);else if(d)96===t&&92!==n&&(d=!1);else if(u)47===t&&92!==n&&(u=!1);else if(124!==t||124===e.charCodeAt(a+1)||124===e.charCodeAt(a-1)||p||l||y){switch(t){case 34:o=!0;break;case 39:i=!0;break;case 96:d=!0;break;case 40:y++;break;case 41:y--;break;case 91:l++;break;case 93:l--;break;case 123:p++;break;case 125:p--}if(47===t){for(var m=a-1,f=void 0;m>=0&&" "===(f=e.charAt(m));m--);f&&Ma.test(f)||(u=!0)}}else void 0===r?(c=a+1,r=e.slice(0,a).trim()):h();function h(){(s||(s=[])).push(e.slice(c,a).trim()),c=a+1}if(void 0===r?r=e.slice(0,a).trim():0!==c&&h(),s)for(a=0;a<s.length;a++)r=Sa(r,s[a]);return r}function Sa(e,t){var n=t.indexOf("(");if(n<0)return'_f("'+t+'")('+e+")";var a=t.slice(0,n),r=t.slice(n+1);return'_f("'+a+'")('+e+(")"!==r?","+r:r)}function xa(e,t){console.error("[Vue compiler]: "+e)}function Ea(e,t){return e?e.map((function(e){return e[t]})).filter((function(e){return e})):[]}function Fa(e,t,n,a,r){(e.props||(e.props=[])).push(qa({name:t,value:n,dynamic:r},a)),e.plain=!1}function Oa(e,t,n,a,r){(r?e.dynamicAttrs||(e.dynamicAttrs=[]):e.attrs||(e.attrs=[])).push(qa({name:t,value:n,dynamic:r},a)),e.plain=!1}function Na(e,t,n,a){e.attrsMap[t]=n,e.attrsList.push(qa({name:t,value:n},a))}function Da(e,t,n,a,r,s,i,o){(e.directives||(e.directives=[])).push(qa({name:t,rawName:n,value:a,arg:r,isDynamicArg:s,modifiers:i},o)),e.plain=!1}function Ua(e,t,n){return n?"_p("+t+',"'+e+'")':e+t}function $a(e,t,n,r,s,i,o,d){var u;(r=r||a).right?d?t="("+t+")==='click'?'contextmenu':("+t+")":"click"===t&&(t="contextmenu",delete r.right):r.middle&&(d?t="("+t+")==='click'?'mouseup':("+t+")":"click"===t&&(t="mouseup")),r.capture&&(delete r.capture,t=Ua("!",t,d)),r.once&&(delete r.once,t=Ua("~",t,d)),r.passive&&(delete r.passive,t=Ua("&",t,d)),r.native?(delete r.native,u=e.nativeEvents||(e.nativeEvents={})):u=e.events||(e.events={});var p=qa({value:n.trim(),dynamic:d},o);r!==a&&(p.modifiers=r);var l=u[t];Array.isArray(l)?s?l.unshift(p):l.push(p):u[t]=l?s?[p,l]:[l,p]:p,e.plain=!1}function La(e,t,n){var a=Pa(e,":"+t)||Pa(e,"v-bind:"+t);if(null!=a)return Ca(a);if(!1!==n){var r=Pa(e,t);if(null!=r)return JSON.stringify(r)}}function Pa(e,t,n){var a;if(null!=(a=e.attrsMap[t]))for(var r=e.attrsList,s=0,i=r.length;s<i;s++)if(r[s].name===t){r.splice(s,1);break}return n&&delete e.attrsMap[t],a}function ja(e,t){for(var n=e.attrsList,a=0,r=n.length;a<r;a++){var s=n[a];if(t.test(s.name))return n.splice(a,1),s}}function qa(e,t){return t&&(null!=t.start&&(e.start=t.start),null!=t.end&&(e.end=t.end)),e}function Ha(e,t,n){var a=n||{},r=a.number,s="$$v";a.trim&&(s="(typeof $$v === 'string'? $$v.trim(): $$v)"),r&&(s="_n("+s+")");var i=Ba(t,s);e.model={value:"("+t+")",expression:JSON.stringify(t),callback:"function ($$v) {"+i+"}"}}function Ba(e,t){var n=function(e){if(e=e.trim(),_a=e.length,e.indexOf("[")<0||e.lastIndexOf("]")<_a-1)return(ka=e.lastIndexOf("."))>-1?{exp:e.slice(0,ka),key:'"'+e.slice(ka+1)+'"'}:{exp:e,key:null};ga=e,ka=Ra=Ia=0;for(;!Ga();)Wa(wa=za())?Ya(wa):91===wa&&Va(wa);return{exp:e.slice(0,Ra),key:e.slice(Ra+1,Ia)}}(e);return null===n.key?e+"="+t:"$set("+n.exp+", "+n.key+", "+t+")"}function za(){return ga.charCodeAt(++ka)}function Ga(){return ka>=_a}function Wa(e){return 34===e||39===e}function Va(e){var t=1;for(Ra=ka;!Ga();)if(Wa(e=za()))Ya(e);else if(91===e&&t++,93===e&&t--,0===t){Ia=ka;break}}function Ya(e){for(var t=e;!Ga()&&(e=za())!==t;);}var Qa;function Ja(e,t,n){var a=Qa;return function r(){var s=t.apply(null,arguments);null!==s&&Za(e,r,n,a)}}var Ka=Qe&&!(te&&Number(te[1])<=53);function Xa(e,t,n,a){if(Ka){var r=un,s=t;t=s._wrapper=function(e){if(e.target===e.currentTarget||e.timeStamp>=r||e.timeStamp<=0||e.target.ownerDocument!==document)return s.apply(this,arguments)}}Qa.addEventListener(e,t,ae?{capture:n,passive:a}:n)}function Za(e,t,n,a){(a||Qa).removeEventListener(e,t._wrapper||t,n)}function er(e,t){if(!r(e.data.on)||!r(t.data.on)){var n=t.data.on||{},a=e.data.on||{};Qa=t.elm,function(e){if(s(e.__r)){var t=K?"change":"input";e[t]=[].concat(e.__r,e[t]||[]),delete e.__r}s(e.__c)&&(e.change=[].concat(e.__c,e.change||[]),delete e.__c)}(n),dt(n,a,Xa,Za,Ja,t.context),Qa=void 0}}var tr,nr={create:er,update:er};function ar(e,t){if(!r(e.data.domProps)||!r(t.data.domProps)){var n,a,i=t.elm,o=e.data.domProps||{},d=t.data.domProps||{};for(n in s(d.__ob__)&&(d=t.data.domProps=x({},d)),o)n in d||(i[n]="");for(n in d){if(a=d[n],"textContent"===n||"innerHTML"===n){if(t.children&&(t.children.length=0),a===o[n])continue;1===i.childNodes.length&&i.removeChild(i.childNodes[0])}if("value"===n&&"PROGRESS"!==i.tagName){i._value=a;var u=r(a)?"":String(a);rr(i,u)&&(i.value=u)}else if("innerHTML"===n&&Qn(i.tagName)&&r(i.innerHTML)){(tr=tr||document.createElement("div")).innerHTML="<svg>"+a+"</svg>";for(var p=tr.firstChild;i.firstChild;)i.removeChild(i.firstChild);for(;p.firstChild;)i.appendChild(p.firstChild)}else if(a!==o[n])try{i[n]=a}catch(e){}}}}function rr(e,t){return!e.composing&&("OPTION"===e.tagName||function(e,t){var n=!0;try{n=document.activeElement!==e}catch(e){}return n&&e.value!==t}(e,t)||function(e,t){var n=e.value,a=e._vModifiers;if(s(a)){if(a.number)return f(n)!==f(t);if(a.trim)return n.trim()!==t.trim()}return n!==t}(e,t))}var sr={create:ar,update:ar},ir=w((function(e){var t={},n=/:(.+)/;return e.split(/;(?![^(]*\))/g).forEach((function(e){if(e){var a=e.split(n);a.length>1&&(t[a[0].trim()]=a[1].trim())}})),t}));function or(e){var t=dr(e.style);return e.staticStyle?x(e.staticStyle,t):t}function dr(e){return Array.isArray(e)?E(e):"string"==typeof e?ir(e):e}var ur,pr=/^--/,lr=/\s*!important$/,yr=function(e,t,n){if(pr.test(t))e.style.setProperty(t,n);else if(lr.test(n))e.style.setProperty(M(t),n.replace(lr,""),"important");else{var a=mr(t);if(Array.isArray(n))for(var r=0,s=n.length;r<s;r++)e.style[a]=n[r];else e.style[a]=n}},cr=["Webkit","Moz","ms"],mr=w((function(e){if(ur=ur||document.createElement("div").style,"filter"!==(e=R(e))&&e in ur)return e;for(var t=e.charAt(0).toUpperCase()+e.slice(1),n=0;n<cr.length;n++){var a=cr[n]+t;if(a in ur)return a}}));function fr(e,t){var n=t.data,a=e.data;if(!(r(n.staticStyle)&&r(n.style)&&r(a.staticStyle)&&r(a.style))){var i,o,d=t.elm,u=a.staticStyle,p=a.normalizedStyle||a.style||{},l=u||p,y=dr(t.data.style)||{};t.data.normalizedStyle=s(y.__ob__)?x({},y):y;var c=function(e,t){var n,a={};if(t)for(var r=e;r.componentInstance;)(r=r.componentInstance._vnode)&&r.data&&(n=or(r.data))&&x(a,n);(n=or(e.data))&&x(a,n);for(var s=e;s=s.parent;)s.data&&(n=or(s.data))&&x(a,n);return a}(t,!0);for(o in l)r(c[o])&&yr(d,o,"");for(o in c)(i=c[o])!==l[o]&&yr(d,o,null==i?"":i)}}var hr={create:fr,update:fr},vr=/\s+/;function Tr(e,t){if(t&&(t=t.trim()))if(e.classList)t.indexOf(" ")>-1?t.split(vr).forEach((function(t){return e.classList.add(t)})):e.classList.add(t);else{var n=" "+(e.getAttribute("class")||"")+" ";n.indexOf(" "+t+" ")<0&&e.setAttribute("class",(n+t).trim())}}function br(e,t){if(t&&(t=t.trim()))if(e.classList)t.indexOf(" ")>-1?t.split(vr).forEach((function(t){return e.classList.remove(t)})):e.classList.remove(t),e.classList.length||e.removeAttribute("class");else{for(var n=" "+(e.getAttribute("class")||"")+" ",a=" "+t+" ";n.indexOf(a)>=0;)n=n.replace(a," ");(n=n.trim())?e.setAttribute("class",n):e.removeAttribute("class")}}function _r(e){if(e){if("object"==typeof e){var t={};return!1!==e.css&&x(t,gr(e.name||"v")),x(t,e),t}return"string"==typeof e?gr(e):void 0}}var gr=w((function(e){return{enterClass:e+"-enter",enterToClass:e+"-enter-to",enterActiveClass:e+"-enter-active",leaveClass:e+"-leave",leaveToClass:e+"-leave-to",leaveActiveClass:e+"-leave-active"}})),wr=V&&!X,kr="transition",Rr="transitionend",Ir="animation",Ar="animationend";wr&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(kr="WebkitTransition",Rr="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Ir="WebkitAnimation",Ar="webkitAnimationEnd"));var Mr=V?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(e){return e()};function Cr(e){Mr((function(){Mr(e)}))}function Sr(e,t){var n=e._transitionClasses||(e._transitionClasses=[]);n.indexOf(t)<0&&(n.push(t),Tr(e,t))}function xr(e,t){e._transitionClasses&&b(e._transitionClasses,t),br(e,t)}function Er(e,t,n){var a=Or(e,t),r=a.type,s=a.timeout,i=a.propCount;if(!r)return n();var o="transition"===r?Rr:Ar,d=0,u=function(){e.removeEventListener(o,p),n()},p=function(t){t.target===e&&++d>=i&&u()};setTimeout((function(){d<i&&u()}),s+1),e.addEventListener(o,p)}var Fr=/\b(transform|all)(,|$)/;function Or(e,t){var n,a=window.getComputedStyle(e),r=(a[kr+"Delay"]||"").split(", "),s=(a[kr+"Duration"]||"").split(", "),i=Nr(r,s),o=(a[Ir+"Delay"]||"").split(", "),d=(a[Ir+"Duration"]||"").split(", "),u=Nr(o,d),p=0,l=0;return"transition"===t?i>0&&(n="transition",p=i,l=s.length):"animation"===t?u>0&&(n="animation",p=u,l=d.length):l=(n=(p=Math.max(i,u))>0?i>u?"transition":"animation":null)?"transition"===n?s.length:d.length:0,{type:n,timeout:p,propCount:l,hasTransform:"transition"===n&&Fr.test(a[kr+"Property"])}}function Nr(e,t){for(;e.length<t.length;)e=e.concat(e);return Math.max.apply(null,t.map((function(t,n){return Dr(t)+Dr(e[n])})))}function Dr(e){return 1e3*Number(e.slice(0,-1).replace(",","."))}function Ur(e,t){var n=e.elm;s(n._leaveCb)&&(n._leaveCb.cancelled=!0,n._leaveCb());var a=_r(e.data.transition);if(!r(a)&&!s(n._enterCb)&&1===n.nodeType){for(var i=a.css,o=a.type,u=a.enterClass,p=a.enterToClass,l=a.enterActiveClass,y=a.appearClass,c=a.appearToClass,m=a.appearActiveClass,h=a.beforeEnter,v=a.enter,T=a.afterEnter,b=a.enterCancelled,_=a.beforeAppear,g=a.appear,w=a.afterAppear,k=a.appearCancelled,R=a.duration,I=Kt,A=Kt.$vnode;A&&A.parent;)I=A.context,A=A.parent;var M=!I._isMounted||!e.isRootInsert;if(!M||g||""===g){var C=M&&y?y:u,S=M&&m?m:l,x=M&&c?c:p,E=M&&_||h,F=M&&"function"==typeof g?g:v,O=M&&w||T,N=M&&k||b,D=f(d(R)?R.enter:R);0;var U=!1!==i&&!X,L=Pr(F),P=n._enterCb=$((function(){U&&(xr(n,x),xr(n,S)),P.cancelled?(U&&xr(n,C),N&&N(n)):O&&O(n),n._enterCb=null}));e.data.show||ut(e,"insert",(function(){var t=n.parentNode,a=t&&t._pending&&t._pending[e.key];a&&a.tag===e.tag&&a.elm._leaveCb&&a.elm._leaveCb(),F&&F(n,P)})),E&&E(n),U&&(Sr(n,C),Sr(n,S),Cr((function(){xr(n,C),P.cancelled||(Sr(n,x),L||(Lr(D)?setTimeout(P,D):Er(n,o,P)))}))),e.data.show&&(t&&t(),F&&F(n,P)),U||L||P()}}}function $r(e,t){var n=e.elm;s(n._enterCb)&&(n._enterCb.cancelled=!0,n._enterCb());var a=_r(e.data.transition);if(r(a)||1!==n.nodeType)return t();if(!s(n._leaveCb)){var i=a.css,o=a.type,u=a.leaveClass,p=a.leaveToClass,l=a.leaveActiveClass,y=a.beforeLeave,c=a.leave,m=a.afterLeave,h=a.leaveCancelled,v=a.delayLeave,T=a.duration,b=!1!==i&&!X,_=Pr(c),g=f(d(T)?T.leave:T);0;var w=n._leaveCb=$((function(){n.parentNode&&n.parentNode._pending&&(n.parentNode._pending[e.key]=null),b&&(xr(n,p),xr(n,l)),w.cancelled?(b&&xr(n,u),h&&h(n)):(t(),m&&m(n)),n._leaveCb=null}));v?v(k):k()}function k(){w.cancelled||(!e.data.show&&n.parentNode&&((n.parentNode._pending||(n.parentNode._pending={}))[e.key]=e),y&&y(n),b&&(Sr(n,u),Sr(n,l),Cr((function(){xr(n,u),w.cancelled||(Sr(n,p),_||(Lr(g)?setTimeout(w,g):Er(n,o,w)))}))),c&&c(n,w),b||_||w())}}function Lr(e){return"number"==typeof e&&!isNaN(e)}function Pr(e){if(r(e))return!1;var t=e.fns;return s(t)?Pr(Array.isArray(t)?t[0]:t):(e._length||e.length)>1}function jr(e,t){!0!==t.data.show&&Ur(t)}var qr=function(e){var t,n,a={},d=e.modules,u=e.nodeOps;for(t=0;t<sa.length;++t)for(a[sa[t]]=[],n=0;n<d.length;++n)s(d[n][sa[t]])&&a[sa[t]].push(d[n][sa[t]]);function p(e){var t=u.parentNode(e);s(t)&&u.removeChild(t,e)}function l(e,t,n,r,o,d,p){if(s(e.elm)&&s(d)&&(e=d[p]=_e(e)),e.isRootInsert=!o,!function(e,t,n,r){var o=e.data;if(s(o)){var d=s(e.componentInstance)&&o.keepAlive;if(s(o=o.hook)&&s(o=o.init)&&o(e,!1),s(e.componentInstance))return y(e,t),c(n,e.elm,r),i(d)&&function(e,t,n,r){var i,o=e;for(;o.componentInstance;)if(o=o.componentInstance._vnode,s(i=o.data)&&s(i=i.transition)){for(i=0;i<a.activate.length;++i)a.activate[i](ra,o);t.push(o);break}c(n,e.elm,r)}(e,t,n,r),!0}}(e,t,n,r)){var l=e.data,f=e.children,h=e.tag;s(h)?(e.elm=e.ns?u.createElementNS(e.ns,h):u.createElement(h,e),T(e),m(e,f,t),s(l)&&v(e,t),c(n,e.elm,r)):i(e.isComment)?(e.elm=u.createComment(e.text),c(n,e.elm,r)):(e.elm=u.createTextNode(e.text),c(n,e.elm,r))}}function y(e,t){s(e.data.pendingInsert)&&(t.push.apply(t,e.data.pendingInsert),e.data.pendingInsert=null),e.elm=e.componentInstance.$el,f(e)?(v(e,t),T(e)):(aa(e),t.push(e))}function c(e,t,n){s(e)&&(s(n)?u.parentNode(n)===e&&u.insertBefore(e,t,n):u.appendChild(e,t))}function m(e,t,n){if(Array.isArray(t)){0;for(var a=0;a<t.length;++a)l(t[a],n,e.elm,null,!0,t,a)}else o(e.text)&&u.appendChild(e.elm,u.createTextNode(String(e.text)))}function f(e){for(;e.componentInstance;)e=e.componentInstance._vnode;return s(e.tag)}function v(e,n){for(var r=0;r<a.create.length;++r)a.create[r](ra,e);s(t=e.data.hook)&&(s(t.create)&&t.create(ra,e),s(t.insert)&&n.push(e))}function T(e){var t;if(s(t=e.fnScopeId))u.setStyleScope(e.elm,t);else for(var n=e;n;)s(t=n.context)&&s(t=t.$options._scopeId)&&u.setStyleScope(e.elm,t),n=n.parent;s(t=Kt)&&t!==e.context&&t!==e.fnContext&&s(t=t.$options._scopeId)&&u.setStyleScope(e.elm,t)}function b(e,t,n,a,r,s){for(;a<=r;++a)l(n[a],s,e,t,!1,n,a)}function _(e){var t,n,r=e.data;if(s(r))for(s(t=r.hook)&&s(t=t.destroy)&&t(e),t=0;t<a.destroy.length;++t)a.destroy[t](e);if(s(t=e.children))for(n=0;n<e.children.length;++n)_(e.children[n])}function g(e,t,n){for(;t<=n;++t){var a=e[t];s(a)&&(s(a.tag)?(w(a),_(a)):p(a.elm))}}function w(e,t){if(s(t)||s(e.data)){var n,r=a.remove.length+1;for(s(t)?t.listeners+=r:t=function(e,t){function n(){0==--n.listeners&&p(e)}return n.listeners=t,n}(e.elm,r),s(n=e.componentInstance)&&s(n=n._vnode)&&s(n.data)&&w(n,t),n=0;n<a.remove.length;++n)a.remove[n](e,t);s(n=e.data.hook)&&s(n=n.remove)?n(e,t):t()}else p(e.elm)}function k(e,t,n,a){for(var r=n;r<a;r++){var i=t[r];if(s(i)&&ia(e,i))return r}}function R(e,t,n,o,d,p){if(e!==t){s(t.elm)&&s(o)&&(t=o[d]=_e(t));var y=t.elm=e.elm;if(i(e.isAsyncPlaceholder))s(t.asyncFactory.resolved)?M(e.elm,t,n):t.isAsyncPlaceholder=!0;else if(i(t.isStatic)&&i(e.isStatic)&&t.key===e.key&&(i(t.isCloned)||i(t.isOnce)))t.componentInstance=e.componentInstance;else{var c,m=t.data;s(m)&&s(c=m.hook)&&s(c=c.prepatch)&&c(e,t);var h=e.children,v=t.children;if(s(m)&&f(t)){for(c=0;c<a.update.length;++c)a.update[c](e,t);s(c=m.hook)&&s(c=c.update)&&c(e,t)}r(t.text)?s(h)&&s(v)?h!==v&&function(e,t,n,a,i){var o,d,p,y=0,c=0,m=t.length-1,f=t[0],h=t[m],v=n.length-1,T=n[0],_=n[v],w=!i;for(0;y<=m&&c<=v;)r(f)?f=t[++y]:r(h)?h=t[--m]:ia(f,T)?(R(f,T,a,n,c),f=t[++y],T=n[++c]):ia(h,_)?(R(h,_,a,n,v),h=t[--m],_=n[--v]):ia(f,_)?(R(f,_,a,n,v),w&&u.insertBefore(e,f.elm,u.nextSibling(h.elm)),f=t[++y],_=n[--v]):ia(h,T)?(R(h,T,a,n,c),w&&u.insertBefore(e,h.elm,f.elm),h=t[--m],T=n[++c]):(r(o)&&(o=oa(t,y,m)),r(d=s(T.key)?o[T.key]:k(T,t,y,m))?l(T,a,e,f.elm,!1,n,c):ia(p=t[d],T)?(R(p,T,a,n,c),t[d]=void 0,w&&u.insertBefore(e,p.elm,f.elm)):l(T,a,e,f.elm,!1,n,c),T=n[++c]);y>m?b(e,r(n[v+1])?null:n[v+1].elm,n,c,v,a):c>v&&g(t,y,m)}(y,h,v,n,p):s(v)?(s(e.text)&&u.setTextContent(y,""),b(y,null,v,0,v.length-1,n)):s(h)?g(h,0,h.length-1):s(e.text)&&u.setTextContent(y,""):e.text!==t.text&&u.setTextContent(y,t.text),s(m)&&s(c=m.hook)&&s(c=c.postpatch)&&c(e,t)}}}function I(e,t,n){if(i(n)&&s(e.parent))e.parent.data.pendingInsert=t;else for(var a=0;a<t.length;++a)t[a].data.hook.insert(t[a])}var A=h("attrs,class,staticClass,staticStyle,key");function M(e,t,n,a){var r,o=t.tag,d=t.data,u=t.children;if(a=a||d&&d.pre,t.elm=e,i(t.isComment)&&s(t.asyncFactory))return t.isAsyncPlaceholder=!0,!0;if(s(d)&&(s(r=d.hook)&&s(r=r.init)&&r(t,!0),s(r=t.componentInstance)))return y(t,n),!0;if(s(o)){if(s(u))if(e.hasChildNodes())if(s(r=d)&&s(r=r.domProps)&&s(r=r.innerHTML)){if(r!==e.innerHTML)return!1}else{for(var p=!0,l=e.firstChild,c=0;c<u.length;c++){if(!l||!M(l,u[c],n,a)){p=!1;break}l=l.nextSibling}if(!p||l)return!1}else m(t,u,n);if(s(d)){var f=!1;for(var h in d)if(!A(h)){f=!0,v(t,n);break}!f&&d.class&&st(d.class)}}else e.data!==t.text&&(e.data=t.text);return!0}return function(e,t,n,o){if(!r(t)){var d,p=!1,y=[];if(r(e))p=!0,l(t,y);else{var c=s(e.nodeType);if(!c&&ia(e,t))R(e,t,y,null,null,o);else{if(c){if(1===e.nodeType&&e.hasAttribute("data-server-rendered")&&(e.removeAttribute("data-server-rendered"),n=!0),i(n)&&M(e,t,y))return I(t,y,!0),e;d=e,e=new he(u.tagName(d).toLowerCase(),{},[],void 0,d)}var m=e.elm,h=u.parentNode(m);if(l(t,y,m._leaveCb?null:h,u.nextSibling(m)),s(t.parent))for(var v=t.parent,T=f(t);v;){for(var b=0;b<a.destroy.length;++b)a.destroy[b](v);if(v.elm=t.elm,T){for(var w=0;w<a.create.length;++w)a.create[w](ra,v);var k=v.data.hook.insert;if(k.merged)for(var A=1;A<k.fns.length;A++)k.fns[A]()}else aa(v);v=v.parent}s(h)?g([e],0,0):s(e.tag)&&_(e)}}return I(t,y,p),t.elm}s(e)&&_(e)}}({nodeOps:ta,modules:[Ta,Aa,nr,sr,hr,V?{create:jr,activate:jr,remove:function(e,t){!0!==e.data.show?$r(e,t):t()}}:{}].concat(ma)});X&&document.addEventListener("selectionchange",(function(){var e=document.activeElement;e&&e.vmodel&&Qr(e,"input")}));var Hr={inserted:function(e,t,n,a){"select"===n.tag?(a.elm&&!a.elm._vOptions?ut(n,"postpatch",(function(){Hr.componentUpdated(e,t,n)})):Br(e,t,n.context),e._vOptions=[].map.call(e.options,Wr)):("textarea"===n.tag||Zn(e.type))&&(e._vModifiers=t.modifiers,t.modifiers.lazy||(e.addEventListener("compositionstart",Vr),e.addEventListener("compositionend",Yr),e.addEventListener("change",Yr),X&&(e.vmodel=!0)))},componentUpdated:function(e,t,n){if("select"===n.tag){Br(e,t,n.context);var a=e._vOptions,r=e._vOptions=[].map.call(e.options,Wr);if(r.some((function(e,t){return!D(e,a[t])})))(e.multiple?t.value.some((function(e){return Gr(e,r)})):t.value!==t.oldValue&&Gr(t.value,r))&&Qr(e,"change")}}};function Br(e,t,n){zr(e,t,n),(K||Z)&&setTimeout((function(){zr(e,t,n)}),0)}function zr(e,t,n){var a=t.value,r=e.multiple;if(!r||Array.isArray(a)){for(var s,i,o=0,d=e.options.length;o<d;o++)if(i=e.options[o],r)s=U(a,Wr(i))>-1,i.selected!==s&&(i.selected=s);else if(D(Wr(i),a))return void(e.selectedIndex!==o&&(e.selectedIndex=o));r||(e.selectedIndex=-1)}}function Gr(e,t){return t.every((function(t){return!D(t,e)}))}function Wr(e){return"_value"in e?e._value:e.value}function Vr(e){e.target.composing=!0}function Yr(e){e.target.composing&&(e.target.composing=!1,Qr(e.target,"input"))}function Qr(e,t){var n=document.createEvent("HTMLEvents");n.initEvent(t,!0,!0),e.dispatchEvent(n)}function Jr(e){return!e.componentInstance||e.data&&e.data.transition?e:Jr(e.componentInstance._vnode)}var Kr={model:Hr,show:{bind:function(e,t,n){var a=t.value,r=(n=Jr(n)).data&&n.data.transition,s=e.__vOriginalDisplay="none"===e.style.display?"":e.style.display;a&&r?(n.data.show=!0,Ur(n,(function(){e.style.display=s}))):e.style.display=a?s:"none"},update:function(e,t,n){var a=t.value;!a!=!t.oldValue&&((n=Jr(n)).data&&n.data.transition?(n.data.show=!0,a?Ur(n,(function(){e.style.display=e.__vOriginalDisplay})):$r(n,(function(){e.style.display="none"}))):e.style.display=a?e.__vOriginalDisplay:"none")},unbind:function(e,t,n,a,r){r||(e.style.display=e.__vOriginalDisplay)}}},Xr={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Zr(e){var t=e&&e.componentOptions;return t&&t.Ctor.options.abstract?Zr(Wt(t.children)):e}function es(e){var t={},n=e.$options;for(var a in n.propsData)t[a]=e[a];var r=n._parentListeners;for(var s in r)t[R(s)]=r[s];return t}function ts(e,t){if(/\d-keep-alive$/.test(t.tag))return e("keep-alive",{props:t.componentOptions.propsData})}var ns=function(e){return e.tag||Gt(e)},as=function(e){return"show"===e.name},rs={name:"transition",props:Xr,abstract:!0,render:function(e){var t=this,n=this.$slots.default;if(n&&(n=n.filter(ns)).length){0;var a=this.mode;0;var r=n[0];if(function(e){for(;e=e.parent;)if(e.data.transition)return!0}(this.$vnode))return r;var s=Zr(r);if(!s)return r;if(this._leaving)return ts(e,r);var i="__transition-"+this._uid+"-";s.key=null==s.key?s.isComment?i+"comment":i+s.tag:o(s.key)?0===String(s.key).indexOf(i)?s.key:i+s.key:s.key;var d=(s.data||(s.data={})).transition=es(this),u=this._vnode,p=Zr(u);if(s.data.directives&&s.data.directives.some(as)&&(s.data.show=!0),p&&p.data&&!function(e,t){return t.key===e.key&&t.tag===e.tag}(s,p)&&!Gt(p)&&(!p.componentInstance||!p.componentInstance._vnode.isComment)){var l=p.data.transition=x({},d);if("out-in"===a)return this._leaving=!0,ut(l,"afterLeave",(function(){t._leaving=!1,t.$forceUpdate()})),ts(e,r);if("in-out"===a){if(Gt(s))return u;var y,c=function(){y()};ut(d,"afterEnter",c),ut(d,"enterCancelled",c),ut(l,"delayLeave",(function(e){y=e}))}}return r}}},ss=x({tag:String,moveClass:String},Xr);function is(e){e.elm._moveCb&&e.elm._moveCb(),e.elm._enterCb&&e.elm._enterCb()}function os(e){e.data.newPos=e.elm.getBoundingClientRect()}function ds(e){var t=e.data.pos,n=e.data.newPos,a=t.left-n.left,r=t.top-n.top;if(a||r){e.data.moved=!0;var s=e.elm.style;s.transform=s.WebkitTransform="translate("+a+"px,"+r+"px)",s.transitionDuration="0s"}}delete ss.mode;var us={Transition:rs,TransitionGroup:{props:ss,beforeMount:function(){var e=this,t=this._update;this._update=function(n,a){var r=Xt(e);e.__patch__(e._vnode,e.kept,!1,!0),e._vnode=e.kept,r(),t.call(e,n,a)}},render:function(e){for(var t=this.tag||this.$vnode.data.tag||"span",n=Object.create(null),a=this.prevChildren=this.children,r=this.$slots.default||[],s=this.children=[],i=es(this),o=0;o<r.length;o++){var d=r[o];if(d.tag)if(null!=d.key&&0!==String(d.key).indexOf("__vlist"))s.push(d),n[d.key]=d,(d.data||(d.data={})).transition=i;else;}if(a){for(var u=[],p=[],l=0;l<a.length;l++){var y=a[l];y.data.transition=i,y.data.pos=y.elm.getBoundingClientRect(),n[y.key]?u.push(y):p.push(y)}this.kept=e(t,null,u),this.removed=p}return e(t,null,s)},updated:function(){var e=this.prevChildren,t=this.moveClass||(this.name||"v")+"-move";e.length&&this.hasMove(e[0].elm,t)&&(e.forEach(is),e.forEach(os),e.forEach(ds),this._reflow=document.body.offsetHeight,e.forEach((function(e){if(e.data.moved){var n=e.elm,a=n.style;Sr(n,t),a.transform=a.WebkitTransform=a.transitionDuration="",n.addEventListener(Rr,n._moveCb=function e(a){a&&a.target!==n||a&&!/transform$/.test(a.propertyName)||(n.removeEventListener(Rr,e),n._moveCb=null,xr(n,t))})}})))},methods:{hasMove:function(e,t){if(!wr)return!1;if(this._hasMove)return this._hasMove;var n=e.cloneNode();e._transitionClasses&&e._transitionClasses.forEach((function(e){br(n,e)})),Tr(n,t),n.style.display="none",this.$el.appendChild(n);var a=Or(n);return this.$el.removeChild(n),this._hasMove=a.hasTransform}}}};In.config.mustUseProp=Dn,In.config.isReservedTag=Jn,In.config.isReservedAttr=On,In.config.getTagNamespace=Kn,In.config.isUnknownElement=function(e){if(!V)return!0;if(Jn(e))return!1;if(e=e.toLowerCase(),null!=Xn[e])return Xn[e];var t=document.createElement(e);return e.indexOf("-")>-1?Xn[e]=t.constructor===window.HTMLUnknownElement||t.constructor===window.HTMLElement:Xn[e]=/HTMLUnknownElement/.test(t.toString())},x(In.options.directives,Kr),x(In.options.components,us),In.prototype.__patch__=V?qr:F,In.prototype.$mount=function(e,t){return function(e,t,n){var a;return e.$el=t,e.$options.render||(e.$options.render=Te),tn(e,"beforeMount"),a=function(){e._update(e._render(),n)},new mn(e,a,F,{before:function(){e._isMounted&&!e._isDestroyed&&tn(e,"beforeUpdate")}},!0),n=!1,null==e.$vnode&&(e._isMounted=!0,tn(e,"mounted")),e}(this,e=e&&V?ea(e):void 0,t)},V&&setTimeout((function(){j.devtools&&ie&&ie.emit("init",In)}),0);var ps=/\{\{((?:.|\r?\n)+?)\}\}/g,ls=/[-.*+?^${}()|[\]\/\\]/g,ys=w((function(e){var t=e[0].replace(ls,"\\$&"),n=e[1].replace(ls,"\\$&");return new RegExp(t+"((?:.|\\n)+?)"+n,"g")}));var cs={staticKeys:["staticClass"],transformNode:function(e,t){t.warn;var n=Pa(e,"class");n&&(e.staticClass=JSON.stringify(n));var a=La(e,"class",!1);a&&(e.classBinding=a)},genData:function(e){var t="";return e.staticClass&&(t+="staticClass:"+e.staticClass+","),e.classBinding&&(t+="class:"+e.classBinding+","),t}};var ms,fs={staticKeys:["staticStyle"],transformNode:function(e,t){t.warn;var n=Pa(e,"style");n&&(e.staticStyle=JSON.stringify(ir(n)));var a=La(e,"style",!1);a&&(e.styleBinding=a)},genData:function(e){var t="";return e.staticStyle&&(t+="staticStyle:"+e.staticStyle+","),e.styleBinding&&(t+="style:("+e.styleBinding+"),"),t}},hs=function(e){return(ms=ms||document.createElement("div")).innerHTML=e,ms.textContent},vs=h("area,base,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr"),Ts=h("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source"),bs=h("address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track"),_s=/^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,gs=/^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,ws="[a-zA-Z_][\\-\\.0-9_a-zA-Z"+q.source+"]*",ks="((?:"+ws+"\\:)?"+ws+")",Rs=new RegExp("^<"+ks),Is=/^\s*(\/?)>/,As=new RegExp("^<\\/"+ks+"[^>]*>"),Ms=/^<!DOCTYPE [^>]+>/i,Cs=/^<!\--/,Ss=/^<!\[/,xs=h("script,style,textarea",!0),Es={},Fs={"&lt;":"<","&gt;":">","&quot;":'"',"&amp;":"&","&#10;":"\n","&#9;":"\t","&#39;":"'"},Os=/&(?:lt|gt|quot|amp|#39);/g,Ns=/&(?:lt|gt|quot|amp|#39|#10|#9);/g,Ds=h("pre,textarea",!0),Us=function(e,t){return e&&Ds(e)&&"\n"===t[0]};function $s(e,t){var n=t?Ns:Os;return e.replace(n,(function(e){return Fs[e]}))}var Ls,Ps,js,qs,Hs,Bs,zs,Gs,Ws=/^@|^v-on:/,Vs=/^v-|^@|^:|^#/,Ys=/([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/,Qs=/,([^,\}\]]*)(?:,([^,\}\]]*))?$/,Js=/^\(|\)$/g,Ks=/^\[.*\]$/,Xs=/:(.*)$/,Zs=/^:|^\.|^v-bind:/,ei=/\.[^.\]]+(?=[^\]]*$)/g,ti=/^v-slot(:|$)|^#/,ni=/[\r\n]/,ai=/\s+/g,ri=w(hs);function si(e,t,n){return{type:1,tag:e,attrsList:t,attrsMap:yi(t),rawAttrsMap:{},parent:n,children:[]}}function ii(e,t){Ls=t.warn||xa,Bs=t.isPreTag||O,zs=t.mustUseProp||O,Gs=t.getTagNamespace||O;var n=t.isReservedTag||O;(function(e){return!!e.component||!n(e.tag)}),js=Ea(t.modules,"transformNode"),qs=Ea(t.modules,"preTransformNode"),Hs=Ea(t.modules,"postTransformNode"),Ps=t.delimiters;var a,r,s=[],i=!1!==t.preserveWhitespace,o=t.whitespace,d=!1,u=!1;function p(e){if(l(e),d||e.processed||(e=oi(e,t)),s.length||e===a||a.if&&(e.elseif||e.else)&&ui(a,{exp:e.elseif,block:e}),r&&!e.forbidden)if(e.elseif||e.else)i=e,(o=function(e){for(var t=e.length;t--;){if(1===e[t].type)return e[t];e.pop()}}(r.children))&&o.if&&ui(o,{exp:i.elseif,block:i});else{if(e.slotScope){var n=e.slotTarget||'"default"';(r.scopedSlots||(r.scopedSlots={}))[n]=e}r.children.push(e),e.parent=r}var i,o;e.children=e.children.filter((function(e){return!e.slotScope})),l(e),e.pre&&(d=!1),Bs(e.tag)&&(u=!1);for(var p=0;p<Hs.length;p++)Hs[p](e,t)}function l(e){if(!u)for(var t;(t=e.children[e.children.length-1])&&3===t.type&&" "===t.text;)e.children.pop()}return function(e,t){for(var n,a,r=[],s=t.expectHTML,i=t.isUnaryTag||O,o=t.canBeLeftOpenTag||O,d=0;e;){if(n=e,a&&xs(a)){var u=0,p=a.toLowerCase(),l=Es[p]||(Es[p]=new RegExp("([\\s\\S]*?)(</"+p+"[^>]*>)","i")),y=e.replace(l,(function(e,n,a){return u=a.length,xs(p)||"noscript"===p||(n=n.replace(/<!\--([\s\S]*?)-->/g,"$1").replace(/<!\[CDATA\[([\s\S]*?)]]>/g,"$1")),Us(p,n)&&(n=n.slice(1)),t.chars&&t.chars(n),""}));d+=e.length-y.length,e=y,A(p,d-u,d)}else{var c=e.indexOf("<");if(0===c){if(Cs.test(e)){var m=e.indexOf("--\x3e");if(m>=0){t.shouldKeepComment&&t.comment(e.substring(4,m),d,d+m+3),k(m+3);continue}}if(Ss.test(e)){var f=e.indexOf("]>");if(f>=0){k(f+2);continue}}var h=e.match(Ms);if(h){k(h[0].length);continue}var v=e.match(As);if(v){var T=d;k(v[0].length),A(v[1],T,d);continue}var b=R();if(b){I(b),Us(b.tagName,e)&&k(1);continue}}var _=void 0,g=void 0,w=void 0;if(c>=0){for(g=e.slice(c);!(As.test(g)||Rs.test(g)||Cs.test(g)||Ss.test(g)||(w=g.indexOf("<",1))<0);)c+=w,g=e.slice(c);_=e.substring(0,c)}c<0&&(_=e),_&&k(_.length),t.chars&&_&&t.chars(_,d-_.length,d)}if(e===n){t.chars&&t.chars(e);break}}function k(t){d+=t,e=e.substring(t)}function R(){var t=e.match(Rs);if(t){var n,a,r={tagName:t[1],attrs:[],start:d};for(k(t[0].length);!(n=e.match(Is))&&(a=e.match(gs)||e.match(_s));)a.start=d,k(a[0].length),a.end=d,r.attrs.push(a);if(n)return r.unarySlash=n[1],k(n[0].length),r.end=d,r}}function I(e){var n=e.tagName,d=e.unarySlash;s&&("p"===a&&bs(n)&&A(a),o(n)&&a===n&&A(n));for(var u=i(n)||!!d,p=e.attrs.length,l=new Array(p),y=0;y<p;y++){var c=e.attrs[y],m=c[3]||c[4]||c[5]||"",f="a"===n&&"href"===c[1]?t.shouldDecodeNewlinesForHref:t.shouldDecodeNewlines;l[y]={name:c[1],value:$s(m,f)}}u||(r.push({tag:n,lowerCasedTag:n.toLowerCase(),attrs:l,start:e.start,end:e.end}),a=n),t.start&&t.start(n,l,u,e.start,e.end)}function A(e,n,s){var i,o;if(null==n&&(n=d),null==s&&(s=d),e)for(o=e.toLowerCase(),i=r.length-1;i>=0&&r[i].lowerCasedTag!==o;i--);else i=0;if(i>=0){for(var u=r.length-1;u>=i;u--)t.end&&t.end(r[u].tag,n,s);r.length=i,a=i&&r[i-1].tag}else"br"===o?t.start&&t.start(e,[],!0,n,s):"p"===o&&(t.start&&t.start(e,[],!1,n,s),t.end&&t.end(e,n,s))}A()}(e,{warn:Ls,expectHTML:t.expectHTML,isUnaryTag:t.isUnaryTag,canBeLeftOpenTag:t.canBeLeftOpenTag,shouldDecodeNewlines:t.shouldDecodeNewlines,shouldDecodeNewlinesForHref:t.shouldDecodeNewlinesForHref,shouldKeepComment:t.comments,outputSourceRange:t.outputSourceRange,start:function(e,n,i,o,l){var y=r&&r.ns||Gs(e);K&&"svg"===y&&(n=function(e){for(var t=[],n=0;n<e.length;n++){var a=e[n];ci.test(a.name)||(a.name=a.name.replace(mi,""),t.push(a))}return t}(n));var c,m=si(e,n,r);y&&(m.ns=y),"style"!==(c=m).tag&&("script"!==c.tag||c.attrsMap.type&&"text/javascript"!==c.attrsMap.type)||se()||(m.forbidden=!0);for(var f=0;f<qs.length;f++)m=qs[f](m,t)||m;d||(!function(e){null!=Pa(e,"v-pre")&&(e.pre=!0)}(m),m.pre&&(d=!0)),Bs(m.tag)&&(u=!0),d?function(e){var t=e.attrsList,n=t.length;if(n)for(var a=e.attrs=new Array(n),r=0;r<n;r++)a[r]={name:t[r].name,value:JSON.stringify(t[r].value)},null!=t[r].start&&(a[r].start=t[r].start,a[r].end=t[r].end);else e.pre||(e.plain=!0)}(m):m.processed||(di(m),function(e){var t=Pa(e,"v-if");if(t)e.if=t,ui(e,{exp:t,block:e});else{null!=Pa(e,"v-else")&&(e.else=!0);var n=Pa(e,"v-else-if");n&&(e.elseif=n)}}(m),function(e){null!=Pa(e,"v-once")&&(e.once=!0)}(m)),a||(a=m),i?p(m):(r=m,s.push(m))},end:function(e,t,n){var a=s[s.length-1];s.length-=1,r=s[s.length-1],p(a)},chars:function(e,t,n){if(r&&(!K||"textarea"!==r.tag||r.attrsMap.placeholder!==e)){var a,s,p,l=r.children;if(e=u||e.trim()?"script"===(a=r).tag||"style"===a.tag?e:ri(e):l.length?o?"condense"===o&&ni.test(e)?"":" ":i?" ":"":"")u||"condense"!==o||(e=e.replace(ai," ")),!d&&" "!==e&&(s=function(e,t){var n=t?ys(t):ps;if(n.test(e)){for(var a,r,s,i=[],o=[],d=n.lastIndex=0;a=n.exec(e);){(r=a.index)>d&&(o.push(s=e.slice(d,r)),i.push(JSON.stringify(s)));var u=Ca(a[1].trim());i.push("_s("+u+")"),o.push({"@binding":u}),d=r+a[0].length}return d<e.length&&(o.push(s=e.slice(d)),i.push(JSON.stringify(s))),{expression:i.join("+"),tokens:o}}}(e,Ps))?p={type:2,expression:s.expression,tokens:s.tokens,text:e}:" "===e&&l.length&&" "===l[l.length-1].text||(p={type:3,text:e}),p&&l.push(p)}},comment:function(e,t,n){if(r){var a={type:3,text:e,isComment:!0};0,r.children.push(a)}}}),a}function oi(e,t){var n;!function(e){var t=La(e,"key");if(t){e.key=t}}(e),e.plain=!e.key&&!e.scopedSlots&&!e.attrsList.length,function(e){var t=La(e,"ref");t&&(e.ref=t,e.refInFor=function(e){var t=e;for(;t;){if(void 0!==t.for)return!0;t=t.parent}return!1}(e))}(e),function(e){var t;"template"===e.tag?(t=Pa(e,"scope"),e.slotScope=t||Pa(e,"slot-scope")):(t=Pa(e,"slot-scope"))&&(e.slotScope=t);var n=La(e,"slot");n&&(e.slotTarget='""'===n?'"default"':n,e.slotTargetDynamic=!(!e.attrsMap[":slot"]&&!e.attrsMap["v-bind:slot"]),"template"===e.tag||e.slotScope||Oa(e,"slot",n,function(e,t){return e.rawAttrsMap[":"+t]||e.rawAttrsMap["v-bind:"+t]||e.rawAttrsMap[t]}(e,"slot")));if("template"===e.tag){var a=ja(e,ti);if(a){0;var r=pi(a),s=r.name,i=r.dynamic;e.slotTarget=s,e.slotTargetDynamic=i,e.slotScope=a.value||"_empty_"}}else{var o=ja(e,ti);if(o){0;var d=e.scopedSlots||(e.scopedSlots={}),u=pi(o),p=u.name,l=u.dynamic,y=d[p]=si("template",[],e);y.slotTarget=p,y.slotTargetDynamic=l,y.children=e.children.filter((function(e){if(!e.slotScope)return e.parent=y,!0})),y.slotScope=o.value||"_empty_",e.children=[],e.plain=!1}}}(e),"slot"===(n=e).tag&&(n.slotName=La(n,"name")),function(e){var t;(t=La(e,"is"))&&(e.component=t);null!=Pa(e,"inline-template")&&(e.inlineTemplate=!0)}(e);for(var a=0;a<js.length;a++)e=js[a](e,t)||e;return function(e){var t,n,a,r,s,i,o,d,u=e.attrsList;for(t=0,n=u.length;t<n;t++){if(a=r=u[t].name,s=u[t].value,Vs.test(a))if(e.hasBindings=!0,(i=li(a.replace(Vs,"")))&&(a=a.replace(ei,"")),Zs.test(a))a=a.replace(Zs,""),s=Ca(s),(d=Ks.test(a))&&(a=a.slice(1,-1)),i&&(i.prop&&!d&&"innerHtml"===(a=R(a))&&(a="innerHTML"),i.camel&&!d&&(a=R(a)),i.sync&&(o=Ba(s,"$event"),d?$a(e,'"update:"+('+a+")",o,null,!1,0,u[t],!0):($a(e,"update:"+R(a),o,null,!1,0,u[t]),M(a)!==R(a)&&$a(e,"update:"+M(a),o,null,!1,0,u[t])))),i&&i.prop||!e.component&&zs(e.tag,e.attrsMap.type,a)?Fa(e,a,s,u[t],d):Oa(e,a,s,u[t],d);else if(Ws.test(a))a=a.replace(Ws,""),(d=Ks.test(a))&&(a=a.slice(1,-1)),$a(e,a,s,i,!1,0,u[t],d);else{var p=(a=a.replace(Vs,"")).match(Xs),l=p&&p[1];d=!1,l&&(a=a.slice(0,-(l.length+1)),Ks.test(l)&&(l=l.slice(1,-1),d=!0)),Da(e,a,r,s,l,d,i,u[t])}else Oa(e,a,JSON.stringify(s),u[t]),!e.component&&"muted"===a&&zs(e.tag,e.attrsMap.type,a)&&Fa(e,a,"true",u[t])}}(e),e}function di(e){var t;if(t=Pa(e,"v-for")){var n=function(e){var t=e.match(Ys);if(!t)return;var n={};n.for=t[2].trim();var a=t[1].trim().replace(Js,""),r=a.match(Qs);r?(n.alias=a.replace(Qs,"").trim(),n.iterator1=r[1].trim(),r[2]&&(n.iterator2=r[2].trim())):n.alias=a;return n}(t);n&&x(e,n)}}function ui(e,t){e.ifConditions||(e.ifConditions=[]),e.ifConditions.push(t)}function pi(e){var t=e.name.replace(ti,"");return t||"#"!==e.name[0]&&(t="default"),Ks.test(t)?{name:t.slice(1,-1),dynamic:!0}:{name:'"'+t+'"',dynamic:!1}}function li(e){var t=e.match(ei);if(t){var n={};return t.forEach((function(e){n[e.slice(1)]=!0})),n}}function yi(e){for(var t={},n=0,a=e.length;n<a;n++)t[e[n].name]=e[n].value;return t}var ci=/^xmlns:NS\d+/,mi=/^NS\d+:/;function fi(e){return si(e.tag,e.attrsList.slice(),e.parent)}var hi=[cs,fs,{preTransformNode:function(e,t){if("input"===e.tag){var n,a=e.attrsMap;if(!a["v-model"])return;if((a[":type"]||a["v-bind:type"])&&(n=La(e,"type")),a.type||n||!a["v-bind"]||(n="("+a["v-bind"]+").type"),n){var r=Pa(e,"v-if",!0),s=r?"&&("+r+")":"",i=null!=Pa(e,"v-else",!0),o=Pa(e,"v-else-if",!0),d=fi(e);di(d),Na(d,"type","checkbox"),oi(d,t),d.processed=!0,d.if="("+n+")==='checkbox'"+s,ui(d,{exp:d.if,block:d});var u=fi(e);Pa(u,"v-for",!0),Na(u,"type","radio"),oi(u,t),ui(d,{exp:"("+n+")==='radio'"+s,block:u});var p=fi(e);return Pa(p,"v-for",!0),Na(p,":type",n),oi(p,t),ui(d,{exp:r,block:p}),i?d.else=!0:o&&(d.elseif=o),d}}}}];var vi,Ti,bi={expectHTML:!0,modules:hi,directives:{model:function(e,t,n){n;var a=t.value,r=t.modifiers,s=e.tag,i=e.attrsMap.type;if(e.component)return Ha(e,a,r),!1;if("select"===s)!function(e,t,n){var a='var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return '+(n&&n.number?"_n(val)":"val")+"});";a=a+" "+Ba(t,"$event.target.multiple ? $$selectedVal : $$selectedVal[0]"),$a(e,"change",a,null,!0)}(e,a,r);else if("input"===s&&"checkbox"===i)!function(e,t,n){var a=n&&n.number,r=La(e,"value")||"null",s=La(e,"true-value")||"true",i=La(e,"false-value")||"false";Fa(e,"checked","Array.isArray("+t+")?_i("+t+","+r+")>-1"+("true"===s?":("+t+")":":_q("+t+","+s+")")),$a(e,"change","var $$a="+t+",$$el=$event.target,$$c=$$el.checked?("+s+"):("+i+");if(Array.isArray($$a)){var $$v="+(a?"_n("+r+")":r)+",$$i=_i($$a,$$v);if($$el.checked){$$i<0&&("+Ba(t,"$$a.concat([$$v])")+")}else{$$i>-1&&("+Ba(t,"$$a.slice(0,$$i).concat($$a.slice($$i+1))")+")}}else{"+Ba(t,"$$c")+"}",null,!0)}(e,a,r);else if("input"===s&&"radio"===i)!function(e,t,n){var a=n&&n.number,r=La(e,"value")||"null";Fa(e,"checked","_q("+t+","+(r=a?"_n("+r+")":r)+")"),$a(e,"change",Ba(t,r),null,!0)}(e,a,r);else if("input"===s||"textarea"===s)!function(e,t,n){var a=e.attrsMap.type;0;var r=n||{},s=r.lazy,i=r.number,o=r.trim,d=!s&&"range"!==a,u=s?"change":"range"===a?"__r":"input",p="$event.target.value";o&&(p="$event.target.value.trim()");i&&(p="_n("+p+")");var l=Ba(t,p);d&&(l="if($event.target.composing)return;"+l);Fa(e,"value","("+t+")"),$a(e,u,l,null,!0),(o||i)&&$a(e,"blur","$forceUpdate()")}(e,a,r);else{if(!j.isReservedTag(s))return Ha(e,a,r),!1}return!0},text:function(e,t){t.value&&Fa(e,"textContent","_s("+t.value+")",t)},html:function(e,t){t.value&&Fa(e,"innerHTML","_s("+t.value+")",t)}},isPreTag:function(e){return"pre"===e},isUnaryTag:vs,mustUseProp:Dn,canBeLeftOpenTag:Ts,isReservedTag:Jn,getTagNamespace:Kn,staticKeys:function(e){return e.reduce((function(e,t){return e.concat(t.staticKeys||[])}),[]).join(",")}(hi)},_i=w((function(e){return h("type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap"+(e?","+e:""))}));function gi(e,t){e&&(vi=_i(t.staticKeys||""),Ti=t.isReservedTag||O,function e(t){if(t.static=function(e){if(2===e.type)return!1;if(3===e.type)return!0;return!(!e.pre&&(e.hasBindings||e.if||e.for||v(e.tag)||!Ti(e.tag)||function(e){for(;e.parent;){if("template"!==(e=e.parent).tag)return!1;if(e.for)return!0}return!1}(e)||!Object.keys(e).every(vi)))}(t),1===t.type){if(!Ti(t.tag)&&"slot"!==t.tag&&null==t.attrsMap["inline-template"])return;for(var n=0,a=t.children.length;n<a;n++){var r=t.children[n];e(r),r.static||(t.static=!1)}if(t.ifConditions)for(var s=1,i=t.ifConditions.length;s<i;s++){var o=t.ifConditions[s].block;e(o),o.static||(t.static=!1)}}}(e),function e(t,n){if(1===t.type){if((t.static||t.once)&&(t.staticInFor=n),t.static&&t.children.length&&(1!==t.children.length||3!==t.children[0].type))return void(t.staticRoot=!0);if(t.staticRoot=!1,t.children)for(var a=0,r=t.children.length;a<r;a++)e(t.children[a],n||!!t.for);if(t.ifConditions)for(var s=1,i=t.ifConditions.length;s<i;s++)e(t.ifConditions[s].block,n)}}(e,!1))}var wi=/^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/,ki=/\([^)]*?\);*$/,Ri=/^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/,Ii={esc:27,tab:9,enter:13,space:32,up:38,left:37,right:39,down:40,delete:[8,46]},Ai={esc:["Esc","Escape"],tab:"Tab",enter:"Enter",space:[" ","Spacebar"],up:["Up","ArrowUp"],left:["Left","ArrowLeft"],right:["Right","ArrowRight"],down:["Down","ArrowDown"],delete:["Backspace","Delete","Del"]},Mi=function(e){return"if("+e+")return null;"},Ci={stop:"$event.stopPropagation();",prevent:"$event.preventDefault();",self:Mi("$event.target !== $event.currentTarget"),ctrl:Mi("!$event.ctrlKey"),shift:Mi("!$event.shiftKey"),alt:Mi("!$event.altKey"),meta:Mi("!$event.metaKey"),left:Mi("'button' in $event && $event.button !== 0"),middle:Mi("'button' in $event && $event.button !== 1"),right:Mi("'button' in $event && $event.button !== 2")};function Si(e,t){var n=t?"nativeOn:":"on:",a="",r="";for(var s in e){var i=xi(e[s]);e[s]&&e[s].dynamic?r+=s+","+i+",":a+='"'+s+'":'+i+","}return a="{"+a.slice(0,-1)+"}",r?n+"_d("+a+",["+r.slice(0,-1)+"])":n+a}function xi(e){if(!e)return"function(){}";if(Array.isArray(e))return"["+e.map((function(e){return xi(e)})).join(",")+"]";var t=Ri.test(e.value),n=wi.test(e.value),a=Ri.test(e.value.replace(ki,""));if(e.modifiers){var r="",s="",i=[];for(var o in e.modifiers)if(Ci[o])s+=Ci[o],Ii[o]&&i.push(o);else if("exact"===o){var d=e.modifiers;s+=Mi(["ctrl","shift","alt","meta"].filter((function(e){return!d[e]})).map((function(e){return"$event."+e+"Key"})).join("||"))}else i.push(o);return i.length&&(r+=function(e){return"if(!$event.type.indexOf('key')&&"+e.map(Ei).join("&&")+")return null;"}(i)),s&&(r+=s),"function($event){"+r+(t?"return "+e.value+"($event)":n?"return ("+e.value+")($event)":a?"return "+e.value:e.value)+"}"}return t||n?e.value:"function($event){"+(a?"return "+e.value:e.value)+"}"}function Ei(e){var t=parseInt(e,10);if(t)return"$event.keyCode!=="+t;var n=Ii[e],a=Ai[e];return"_k($event.keyCode,"+JSON.stringify(e)+","+JSON.stringify(n)+",$event.key,"+JSON.stringify(a)+")"}var Fi={on:function(e,t){e.wrapListeners=function(e){return"_g("+e+","+t.value+")"}},bind:function(e,t){e.wrapData=function(n){return"_b("+n+",'"+e.tag+"',"+t.value+","+(t.modifiers&&t.modifiers.prop?"true":"false")+(t.modifiers&&t.modifiers.sync?",true":"")+")"}},cloak:F},Oi=function(e){this.options=e,this.warn=e.warn||xa,this.transforms=Ea(e.modules,"transformCode"),this.dataGenFns=Ea(e.modules,"genData"),this.directives=x(x({},Fi),e.directives);var t=e.isReservedTag||O;this.maybeComponent=function(e){return!!e.component||!t(e.tag)},this.onceId=0,this.staticRenderFns=[],this.pre=!1};function Ni(e,t){var n=new Oi(t);return{render:"with(this){return "+(e?Di(e,n):'_c("div")')+"}",staticRenderFns:n.staticRenderFns}}function Di(e,t){if(e.parent&&(e.pre=e.pre||e.parent.pre),e.staticRoot&&!e.staticProcessed)return Ui(e,t);if(e.once&&!e.onceProcessed)return $i(e,t);if(e.for&&!e.forProcessed)return Pi(e,t);if(e.if&&!e.ifProcessed)return Li(e,t);if("template"!==e.tag||e.slotTarget||t.pre){if("slot"===e.tag)return function(e,t){var n=e.slotName||'"default"',a=Bi(e,t),r="_t("+n+(a?","+a:""),s=e.attrs||e.dynamicAttrs?Wi((e.attrs||[]).concat(e.dynamicAttrs||[]).map((function(e){return{name:R(e.name),value:e.value,dynamic:e.dynamic}}))):null,i=e.attrsMap["v-bind"];!s&&!i||a||(r+=",null");s&&(r+=","+s);i&&(r+=(s?"":",null")+","+i);return r+")"}(e,t);var n;if(e.component)n=function(e,t,n){var a=t.inlineTemplate?null:Bi(t,n,!0);return"_c("+e+","+ji(t,n)+(a?","+a:"")+")"}(e.component,e,t);else{var a;(!e.plain||e.pre&&t.maybeComponent(e))&&(a=ji(e,t));var r=e.inlineTemplate?null:Bi(e,t,!0);n="_c('"+e.tag+"'"+(a?","+a:"")+(r?","+r:"")+")"}for(var s=0;s<t.transforms.length;s++)n=t.transforms[s](e,n);return n}return Bi(e,t)||"void 0"}function Ui(e,t){e.staticProcessed=!0;var n=t.pre;return e.pre&&(t.pre=e.pre),t.staticRenderFns.push("with(this){return "+Di(e,t)+"}"),t.pre=n,"_m("+(t.staticRenderFns.length-1)+(e.staticInFor?",true":"")+")"}function $i(e,t){if(e.onceProcessed=!0,e.if&&!e.ifProcessed)return Li(e,t);if(e.staticInFor){for(var n="",a=e.parent;a;){if(a.for){n=a.key;break}a=a.parent}return n?"_o("+Di(e,t)+","+t.onceId+++","+n+")":Di(e,t)}return Ui(e,t)}function Li(e,t,n,a){return e.ifProcessed=!0,function e(t,n,a,r){if(!t.length)return r||"_e()";var s=t.shift();return s.exp?"("+s.exp+")?"+i(s.block)+":"+e(t,n,a,r):""+i(s.block);function i(e){return a?a(e,n):e.once?$i(e,n):Di(e,n)}}(e.ifConditions.slice(),t,n,a)}function Pi(e,t,n,a){var r=e.for,s=e.alias,i=e.iterator1?","+e.iterator1:"",o=e.iterator2?","+e.iterator2:"";return e.forProcessed=!0,(a||"_l")+"(("+r+"),function("+s+i+o+"){return "+(n||Di)(e,t)+"})"}function ji(e,t){var n="{",a=function(e,t){var n=e.directives;if(!n)return;var a,r,s,i,o="directives:[",d=!1;for(a=0,r=n.length;a<r;a++){s=n[a],i=!0;var u=t.directives[s.name];u&&(i=!!u(e,s,t.warn)),i&&(d=!0,o+='{name:"'+s.name+'",rawName:"'+s.rawName+'"'+(s.value?",value:("+s.value+"),expression:"+JSON.stringify(s.value):"")+(s.arg?",arg:"+(s.isDynamicArg?s.arg:'"'+s.arg+'"'):"")+(s.modifiers?",modifiers:"+JSON.stringify(s.modifiers):"")+"},")}if(d)return o.slice(0,-1)+"]"}(e,t);a&&(n+=a+","),e.key&&(n+="key:"+e.key+","),e.ref&&(n+="ref:"+e.ref+","),e.refInFor&&(n+="refInFor:true,"),e.pre&&(n+="pre:true,"),e.component&&(n+='tag:"'+e.tag+'",');for(var r=0;r<t.dataGenFns.length;r++)n+=t.dataGenFns[r](e);if(e.attrs&&(n+="attrs:"+Wi(e.attrs)+","),e.props&&(n+="domProps:"+Wi(e.props)+","),e.events&&(n+=Si(e.events,!1)+","),e.nativeEvents&&(n+=Si(e.nativeEvents,!0)+","),e.slotTarget&&!e.slotScope&&(n+="slot:"+e.slotTarget+","),e.scopedSlots&&(n+=function(e,t,n){var a=e.for||Object.keys(t).some((function(e){var n=t[e];return n.slotTargetDynamic||n.if||n.for||qi(n)})),r=!!e.if;if(!a)for(var s=e.parent;s;){if(s.slotScope&&"_empty_"!==s.slotScope||s.for){a=!0;break}s.if&&(r=!0),s=s.parent}var i=Object.keys(t).map((function(e){return Hi(t[e],n)})).join(",");return"scopedSlots:_u(["+i+"]"+(a?",null,true":"")+(!a&&r?",null,false,"+function(e){var t=5381,n=e.length;for(;n;)t=33*t^e.charCodeAt(--n);return t>>>0}(i):"")+")"}(e,e.scopedSlots,t)+","),e.model&&(n+="model:{value:"+e.model.value+",callback:"+e.model.callback+",expression:"+e.model.expression+"},"),e.inlineTemplate){var s=function(e,t){var n=e.children[0];0;if(n&&1===n.type){var a=Ni(n,t.options);return"inlineTemplate:{render:function(){"+a.render+"},staticRenderFns:["+a.staticRenderFns.map((function(e){return"function(){"+e+"}"})).join(",")+"]}"}}(e,t);s&&(n+=s+",")}return n=n.replace(/,$/,"")+"}",e.dynamicAttrs&&(n="_b("+n+',"'+e.tag+'",'+Wi(e.dynamicAttrs)+")"),e.wrapData&&(n=e.wrapData(n)),e.wrapListeners&&(n=e.wrapListeners(n)),n}function qi(e){return 1===e.type&&("slot"===e.tag||e.children.some(qi))}function Hi(e,t){var n=e.attrsMap["slot-scope"];if(e.if&&!e.ifProcessed&&!n)return Li(e,t,Hi,"null");if(e.for&&!e.forProcessed)return Pi(e,t,Hi);var a="_empty_"===e.slotScope?"":String(e.slotScope),r="function("+a+"){return "+("template"===e.tag?e.if&&n?"("+e.if+")?"+(Bi(e,t)||"undefined")+":undefined":Bi(e,t)||"undefined":Di(e,t))+"}",s=a?"":",proxy:true";return"{key:"+(e.slotTarget||'"default"')+",fn:"+r+s+"}"}function Bi(e,t,n,a,r){var s=e.children;if(s.length){var i=s[0];if(1===s.length&&i.for&&"template"!==i.tag&&"slot"!==i.tag){var o=n?t.maybeComponent(i)?",1":",0":"";return""+(a||Di)(i,t)+o}var d=n?function(e,t){for(var n=0,a=0;a<e.length;a++){var r=e[a];if(1===r.type){if(zi(r)||r.ifConditions&&r.ifConditions.some((function(e){return zi(e.block)}))){n=2;break}(t(r)||r.ifConditions&&r.ifConditions.some((function(e){return t(e.block)})))&&(n=1)}}return n}(s,t.maybeComponent):0,u=r||Gi;return"["+s.map((function(e){return u(e,t)})).join(",")+"]"+(d?","+d:"")}}function zi(e){return void 0!==e.for||"template"===e.tag||"slot"===e.tag}function Gi(e,t){return 1===e.type?Di(e,t):3===e.type&&e.isComment?function(e){return"_e("+JSON.stringify(e.text)+")"}(e):function(e){return"_v("+(2===e.type?e.expression:Vi(JSON.stringify(e.text)))+")"}(e)}function Wi(e){for(var t="",n="",a=0;a<e.length;a++){var r=e[a],s=Vi(r.value);r.dynamic?n+=r.name+","+s+",":t+='"'+r.name+'":'+s+","}return t="{"+t.slice(0,-1)+"}",n?"_d("+t+",["+n.slice(0,-1)+"])":t}function Vi(e){return e.replace(/\u2028/g,"\\u2028").replace(/\u2029/g,"\\u2029")}new RegExp("\\b"+"do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments".split(",").join("\\b|\\b")+"\\b"),new RegExp("\\b"+"delete,typeof,void".split(",").join("\\s*\\([^\\)]*\\)|\\b")+"\\s*\\([^\\)]*\\)");function Yi(e,t){try{return new Function(e)}catch(n){return t.push({err:n,code:e}),F}}function Qi(e){var t=Object.create(null);return function(n,a,r){(a=x({},a)).warn;delete a.warn;var s=a.delimiters?String(a.delimiters)+n:n;if(t[s])return t[s];var i=e(n,a);var o={},d=[];return o.render=Yi(i.render,d),o.staticRenderFns=i.staticRenderFns.map((function(e){return Yi(e,d)})),t[s]=o}}var Ji,Ki,Xi=(Ji=function(e,t){var n=ii(e.trim(),t);!1!==t.optimize&&gi(n,t);var a=Ni(n,t);return{ast:n,render:a.render,staticRenderFns:a.staticRenderFns}},function(e){function t(t,n){var a=Object.create(e),r=[],s=[];if(n)for(var i in n.modules&&(a.modules=(e.modules||[]).concat(n.modules)),n.directives&&(a.directives=x(Object.create(e.directives||null),n.directives)),n)"modules"!==i&&"directives"!==i&&(a[i]=n[i]);a.warn=function(e,t,n){(n?s:r).push(e)};var o=Ji(t.trim(),a);return o.errors=r,o.tips=s,o}return{compile:t,compileToFunctions:Qi(t)}})(bi),Zi=(Xi.compile,Xi.compileToFunctions);function eo(e){return(Ki=Ki||document.createElement("div")).innerHTML=e?'<a href="\n"/>':'<div a="\n"/>',Ki.innerHTML.indexOf("&#10;")>0}var to=!!V&&eo(!1),no=!!V&&eo(!0),ao=w((function(e){var t=ea(e);return t&&t.innerHTML})),ro=In.prototype.$mount;In.prototype.$mount=function(e,t){if((e=e&&ea(e))===document.body||e===document.documentElement)return this;var n=this.$options;if(!n.render){var a=n.template;if(a)if("string"==typeof a)"#"===a.charAt(0)&&(a=ao(a));else{if(!a.nodeType)return this;a=a.innerHTML}else e&&(a=function(e){if(e.outerHTML)return e.outerHTML;var t=document.createElement("div");return t.appendChild(e.cloneNode(!0)),t.innerHTML}(e));if(a){0;var r=Zi(a,{outputSourceRange:!1,shouldDecodeNewlines:to,shouldDecodeNewlinesForHref:no,delimiters:n.delimiters,comments:n.comments},this),s=r.render,i=r.staticRenderFns;n.render=s,n.staticRenderFns=i}}return ro.call(this,e,t)},In.compile=Zi,t.a=In}).call(this,n(0),n(7).setImmediate)},function(e){e.exports=JSON.parse('{"a":"hardhat-docgen","b":{"type":"git","url":"git+https://github.com/ItsNickBarry/hardhat-docgen.git"}}')},function(e,t,n){var a=n(5);"string"==typeof a&&(a=[[e.i,a,""]]),a.locals&&(e.exports=a.locals);(0,n(11).default)("0b345cf4",a,!1,{})},function(e,t,n){"use strict";n(3)},function(e,t,n){(t=e.exports=n(6)(!1)).push([e.i,"@import url(https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;500;600;700&display=swap);",""]),t.push([e.i,"\nhtml,\nbody {\n  font-family: 'Source Code Pro', monospace;\n}\n",""])},function(e,t,n){"use strict";e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n=function(e,t){var n=e[1]||"",a=e[3];if(!a)return n;if(t&&"function"==typeof btoa){var r=(i=a,"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(i))))+" */"),s=a.sources.map((function(e){return"/*# sourceURL="+a.sourceRoot+e+" */"}));return[n].concat(s).concat([r]).join("\n")}var i;return[n].join("\n")}(t,e);return t[2]?"@media "+t[2]+"{"+n+"}":n})).join("")},t.i=function(e,n){"string"==typeof e&&(e=[[null,e,""]]);for(var a={},r=0;r<this.length;r++){var s=this[r][0];null!=s&&(a[s]=!0)}for(r=0;r<e.length;r++){var i=e[r];null!=i[0]&&a[i[0]]||(n&&!i[2]?i[2]=n:n&&(i[2]="("+i[2]+") and ("+n+")"),t.push(i))}},t}},function(e,t,n){(function(e){var a=void 0!==e&&e||"undefined"!=typeof self&&self||window,r=Function.prototype.apply;function s(e,t){this._id=e,this._clearFn=t}t.setTimeout=function(){return new s(r.call(setTimeout,a,arguments),clearTimeout)},t.setInterval=function(){return new s(r.call(setInterval,a,arguments),clearInterval)},t.clearTimeout=t.clearInterval=function(e){e&&e.close()},s.prototype.unref=s.prototype.ref=function(){},s.prototype.close=function(){this._clearFn.call(a,this._id)},t.enroll=function(e,t){clearTimeout(e._idleTimeoutId),e._idleTimeout=t},t.unenroll=function(e){clearTimeout(e._idleTimeoutId),e._idleTimeout=-1},t._unrefActive=t.active=function(e){clearTimeout(e._idleTimeoutId);var t=e._idleTimeout;t>=0&&(e._idleTimeoutId=setTimeout((function(){e._onTimeout&&e._onTimeout()}),t))},n(8),t.setImmediate="undefined"!=typeof self&&self.setImmediate||void 0!==e&&e.setImmediate||this&&this.setImmediate,t.clearImmediate="undefined"!=typeof self&&self.clearImmediate||void 0!==e&&e.clearImmediate||this&&this.clearImmediate}).call(this,n(0))},function(e,t,n){(function(e,t){!function(e,n){"use strict";if(!e.setImmediate){var a,r,s,i,o,d=1,u={},p=!1,l=e.document,y=Object.getPrototypeOf&&Object.getPrototypeOf(e);y=y&&y.setTimeout?y:e,"[object process]"==={}.toString.call(e.process)?a=function(e){t.nextTick((function(){m(e)}))}:!function(){if(e.postMessage&&!e.importScripts){var t=!0,n=e.onmessage;return e.onmessage=function(){t=!1},e.postMessage("","*"),e.onmessage=n,t}}()?e.MessageChannel?((s=new MessageChannel).port1.onmessage=function(e){m(e.data)},a=function(e){s.port2.postMessage(e)}):l&&"onreadystatechange"in l.createElement("script")?(r=l.documentElement,a=function(e){var t=l.createElement("script");t.onreadystatechange=function(){m(e),t.onreadystatechange=null,r.removeChild(t),t=null},r.appendChild(t)}):a=function(e){setTimeout(m,0,e)}:(i="setImmediate$"+Math.random()+"$",o=function(t){t.source===e&&"string"==typeof t.data&&0===t.data.indexOf(i)&&m(+t.data.slice(i.length))},e.addEventListener?e.addEventListener("message",o,!1):e.attachEvent("onmessage",o),a=function(t){e.postMessage(i+t,"*")}),y.setImmediate=function(e){"function"!=typeof e&&(e=new Function(""+e));for(var t=new Array(arguments.length-1),n=0;n<t.length;n++)t[n]=arguments[n+1];var r={callback:e,args:t};return u[d]=r,a(d),d++},y.clearImmediate=c}function c(e){delete u[e]}function m(e){if(p)setTimeout(m,0,e);else{var t=u[e];if(t){p=!0;try{!function(e){var t=e.callback,n=e.args;switch(n.length){case 0:t();break;case 1:t(n[0]);break;case 2:t(n[0],n[1]);break;case 3:t(n[0],n[1],n[2]);break;default:t.apply(void 0,n)}}(t)}finally{c(e),p=!1}}}}}("undefined"==typeof self?void 0===e?this:e:self)}).call(this,n(0),n(9))},function(e,t){var n,a,r=e.exports={};function s(){throw new Error("setTimeout has not been defined")}function i(){throw new Error("clearTimeout has not been defined")}function o(e){if(n===setTimeout)return setTimeout(e,0);if((n===s||!n)&&setTimeout)return n=setTimeout,setTimeout(e,0);try{return n(e,0)}catch(t){try{return n.call(null,e,0)}catch(t){return n.call(this,e,0)}}}!function(){try{n="function"==typeof setTimeout?setTimeout:s}catch(e){n=s}try{a="function"==typeof clearTimeout?clearTimeout:i}catch(e){a=i}}();var d,u=[],p=!1,l=-1;function y(){p&&d&&(p=!1,d.length?u=d.concat(u):l=-1,u.length&&c())}function c(){if(!p){var e=o(y);p=!0;for(var t=u.length;t;){for(d=u,u=[];++l<t;)d&&d[l].run();l=-1,t=u.length}d=null,p=!1,function(e){if(a===clearTimeout)return clearTimeout(e);if((a===i||!a)&&clearTimeout)return a=clearTimeout,clearTimeout(e);try{a(e)}catch(t){try{return a.call(null,e)}catch(t){return a.call(this,e)}}}(e)}}function m(e,t){this.fun=e,this.array=t}function f(){}r.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)t[n-1]=arguments[n];u.push(new m(e,t)),1!==u.length||p||o(c)},m.prototype.run=function(){this.fun.apply(null,this.array)},r.title="browser",r.browser=!0,r.env={},r.argv=[],r.version="",r.versions={},r.on=f,r.addListener=f,r.once=f,r.off=f,r.removeListener=f,r.removeAllListeners=f,r.emit=f,r.prependListener=f,r.prependOnceListener=f,r.listeners=function(e){return[]},r.binding=function(e){throw new Error("process.binding is not supported")},r.cwd=function(){return"/"},r.chdir=function(e){throw new Error("process.chdir is not supported")},r.umask=function(){return 0}},function(e,t,n){"use strict";n.r(t);var a=n(1);
/*!
  * vue-router v3.5.1
  * (c) 2021 Evan You
  * @license MIT
  */function r(e,t){for(var n in t)e[n]=t[n];return e}var s=/[!'()*]/g,i=function(e){return"%"+e.charCodeAt(0).toString(16)},o=/%2C/g,d=function(e){return encodeURIComponent(e).replace(s,i).replace(o,",")};function u(e){try{return decodeURIComponent(e)}catch(e){0}return e}var p=function(e){return null==e||"object"==typeof e?e:String(e)};function l(e){var t={};return(e=e.trim().replace(/^(\?|#|&)/,""))?(e.split("&").forEach((function(e){var n=e.replace(/\+/g," ").split("="),a=u(n.shift()),r=n.length>0?u(n.join("=")):null;void 0===t[a]?t[a]=r:Array.isArray(t[a])?t[a].push(r):t[a]=[t[a],r]})),t):t}function y(e){var t=e?Object.keys(e).map((function(t){var n=e[t];if(void 0===n)return"";if(null===n)return d(t);if(Array.isArray(n)){var a=[];return n.forEach((function(e){void 0!==e&&(null===e?a.push(d(t)):a.push(d(t)+"="+d(e)))})),a.join("&")}return d(t)+"="+d(n)})).filter((function(e){return e.length>0})).join("&"):null;return t?"?"+t:""}var c=/\/?$/;function m(e,t,n,a){var r=a&&a.options.stringifyQuery,s=t.query||{};try{s=f(s)}catch(e){}var i={name:t.name||e&&e.name,meta:e&&e.meta||{},path:t.path||"/",hash:t.hash||"",query:s,params:t.params||{},fullPath:T(t,r),matched:e?v(e):[]};return n&&(i.redirectedFrom=T(n,r)),Object.freeze(i)}function f(e){if(Array.isArray(e))return e.map(f);if(e&&"object"==typeof e){var t={};for(var n in e)t[n]=f(e[n]);return t}return e}var h=m(null,{path:"/"});function v(e){for(var t=[];e;)t.unshift(e),e=e.parent;return t}function T(e,t){var n=e.path,a=e.query;void 0===a&&(a={});var r=e.hash;return void 0===r&&(r=""),(n||"/")+(t||y)(a)+r}function b(e,t,n){return t===h?e===t:!!t&&(e.path&&t.path?e.path.replace(c,"")===t.path.replace(c,"")&&(n||e.hash===t.hash&&_(e.query,t.query)):!(!e.name||!t.name)&&(e.name===t.name&&(n||e.hash===t.hash&&_(e.query,t.query)&&_(e.params,t.params))))}function _(e,t){if(void 0===e&&(e={}),void 0===t&&(t={}),!e||!t)return e===t;var n=Object.keys(e).sort(),a=Object.keys(t).sort();return n.length===a.length&&n.every((function(n,r){var s=e[n];if(a[r]!==n)return!1;var i=t[n];return null==s||null==i?s===i:"object"==typeof s&&"object"==typeof i?_(s,i):String(s)===String(i)}))}function g(e){for(var t=0;t<e.matched.length;t++){var n=e.matched[t];for(var a in n.instances){var r=n.instances[a],s=n.enteredCbs[a];if(r&&s){delete n.enteredCbs[a];for(var i=0;i<s.length;i++)r._isBeingDestroyed||s[i](r)}}}}var w={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(e,t){var n=t.props,a=t.children,s=t.parent,i=t.data;i.routerView=!0;for(var o=s.$createElement,d=n.name,u=s.$route,p=s._routerViewCache||(s._routerViewCache={}),l=0,y=!1;s&&s._routerRoot!==s;){var c=s.$vnode?s.$vnode.data:{};c.routerView&&l++,c.keepAlive&&s._directInactive&&s._inactive&&(y=!0),s=s.$parent}if(i.routerViewDepth=l,y){var m=p[d],f=m&&m.component;return f?(m.configProps&&k(f,i,m.route,m.configProps),o(f,i,a)):o()}var h=u.matched[l],v=h&&h.components[d];if(!h||!v)return p[d]=null,o();p[d]={component:v},i.registerRouteInstance=function(e,t){var n=h.instances[d];(t&&n!==e||!t&&n===e)&&(h.instances[d]=t)},(i.hook||(i.hook={})).prepatch=function(e,t){h.instances[d]=t.componentInstance},i.hook.init=function(e){e.data.keepAlive&&e.componentInstance&&e.componentInstance!==h.instances[d]&&(h.instances[d]=e.componentInstance),g(u)};var T=h.props&&h.props[d];return T&&(r(p[d],{route:u,configProps:T}),k(v,i,u,T)),o(v,i,a)}};function k(e,t,n,a){var s=t.props=function(e,t){switch(typeof t){case"undefined":return;case"object":return t;case"function":return t(e);case"boolean":return t?e.params:void 0;default:0}}(n,a);if(s){s=t.props=r({},s);var i=t.attrs=t.attrs||{};for(var o in s)e.props&&o in e.props||(i[o]=s[o],delete s[o])}}function R(e,t,n){var a=e.charAt(0);if("/"===a)return e;if("?"===a||"#"===a)return t+e;var r=t.split("/");n&&r[r.length-1]||r.pop();for(var s=e.replace(/^\//,"").split("/"),i=0;i<s.length;i++){var o=s[i];".."===o?r.pop():"."!==o&&r.push(o)}return""!==r[0]&&r.unshift(""),r.join("/")}function I(e){return e.replace(/\/\//g,"/")}var A=Array.isArray||function(e){return"[object Array]"==Object.prototype.toString.call(e)},M=q,C=O,S=function(e,t){return D(O(e,t),t)},x=D,E=j,F=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function O(e,t){for(var n,a=[],r=0,s=0,i="",o=t&&t.delimiter||"/";null!=(n=F.exec(e));){var d=n[0],u=n[1],p=n.index;if(i+=e.slice(s,p),s=p+d.length,u)i+=u[1];else{var l=e[s],y=n[2],c=n[3],m=n[4],f=n[5],h=n[6],v=n[7];i&&(a.push(i),i="");var T=null!=y&&null!=l&&l!==y,b="+"===h||"*"===h,_="?"===h||"*"===h,g=n[2]||o,w=m||f;a.push({name:c||r++,prefix:y||"",delimiter:g,optional:_,repeat:b,partial:T,asterisk:!!v,pattern:w?$(w):v?".*":"[^"+U(g)+"]+?"})}}return s<e.length&&(i+=e.substr(s)),i&&a.push(i),a}function N(e){return encodeURI(e).replace(/[\/?#]/g,(function(e){return"%"+e.charCodeAt(0).toString(16).toUpperCase()}))}function D(e,t){for(var n=new Array(e.length),a=0;a<e.length;a++)"object"==typeof e[a]&&(n[a]=new RegExp("^(?:"+e[a].pattern+")$",P(t)));return function(t,a){for(var r="",s=t||{},i=(a||{}).pretty?N:encodeURIComponent,o=0;o<e.length;o++){var d=e[o];if("string"!=typeof d){var u,p=s[d.name];if(null==p){if(d.optional){d.partial&&(r+=d.prefix);continue}throw new TypeError('Expected "'+d.name+'" to be defined')}if(A(p)){if(!d.repeat)throw new TypeError('Expected "'+d.name+'" to not repeat, but received `'+JSON.stringify(p)+"`");if(0===p.length){if(d.optional)continue;throw new TypeError('Expected "'+d.name+'" to not be empty')}for(var l=0;l<p.length;l++){if(u=i(p[l]),!n[o].test(u))throw new TypeError('Expected all "'+d.name+'" to match "'+d.pattern+'", but received `'+JSON.stringify(u)+"`");r+=(0===l?d.prefix:d.delimiter)+u}}else{if(u=d.asterisk?encodeURI(p).replace(/[?#]/g,(function(e){return"%"+e.charCodeAt(0).toString(16).toUpperCase()})):i(p),!n[o].test(u))throw new TypeError('Expected "'+d.name+'" to match "'+d.pattern+'", but received "'+u+'"');r+=d.prefix+u}}else r+=d}return r}}function U(e){return e.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function $(e){return e.replace(/([=!:$\/()])/g,"\\$1")}function L(e,t){return e.keys=t,e}function P(e){return e&&e.sensitive?"":"i"}function j(e,t,n){A(t)||(n=t||n,t=[]);for(var a=(n=n||{}).strict,r=!1!==n.end,s="",i=0;i<e.length;i++){var o=e[i];if("string"==typeof o)s+=U(o);else{var d=U(o.prefix),u="(?:"+o.pattern+")";t.push(o),o.repeat&&(u+="(?:"+d+u+")*"),s+=u=o.optional?o.partial?d+"("+u+")?":"(?:"+d+"("+u+"))?":d+"("+u+")"}}var p=U(n.delimiter||"/"),l=s.slice(-p.length)===p;return a||(s=(l?s.slice(0,-p.length):s)+"(?:"+p+"(?=$))?"),s+=r?"$":a&&l?"":"(?="+p+"|$)",L(new RegExp("^"+s,P(n)),t)}function q(e,t,n){return A(t)||(n=t||n,t=[]),n=n||{},e instanceof RegExp?function(e,t){var n=e.source.match(/\((?!\?)/g);if(n)for(var a=0;a<n.length;a++)t.push({name:a,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return L(e,t)}(e,t):A(e)?function(e,t,n){for(var a=[],r=0;r<e.length;r++)a.push(q(e[r],t,n).source);return L(new RegExp("(?:"+a.join("|")+")",P(n)),t)}(e,t,n):function(e,t,n){return j(O(e,n),t,n)}(e,t,n)}M.parse=C,M.compile=S,M.tokensToFunction=x,M.tokensToRegExp=E;var H=Object.create(null);function B(e,t,n){t=t||{};try{var a=H[e]||(H[e]=M.compile(e));return"string"==typeof t.pathMatch&&(t[0]=t.pathMatch),a(t,{pretty:!0})}catch(e){return""}finally{delete t[0]}}function z(e,t,n,a){var s="string"==typeof e?{path:e}:e;if(s._normalized)return s;if(s.name){var i=(s=r({},e)).params;return i&&"object"==typeof i&&(s.params=r({},i)),s}if(!s.path&&s.params&&t){(s=r({},s))._normalized=!0;var o=r(r({},t.params),s.params);if(t.name)s.name=t.name,s.params=o;else if(t.matched.length){var d=t.matched[t.matched.length-1].path;s.path=B(d,o,t.path)}else 0;return s}var u=function(e){var t="",n="",a=e.indexOf("#");a>=0&&(t=e.slice(a),e=e.slice(0,a));var r=e.indexOf("?");return r>=0&&(n=e.slice(r+1),e=e.slice(0,r)),{path:e,query:n,hash:t}}(s.path||""),y=t&&t.path||"/",c=u.path?R(u.path,y,n||s.append):y,m=function(e,t,n){void 0===t&&(t={});var a,r=n||l;try{a=r(e||"")}catch(e){a={}}for(var s in t){var i=t[s];a[s]=Array.isArray(i)?i.map(p):p(i)}return a}(u.query,s.query,a&&a.options.parseQuery),f=s.hash||u.hash;return f&&"#"!==f.charAt(0)&&(f="#"+f),{_normalized:!0,path:c,query:m,hash:f}}var G,W=function(){},V={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(e){var t=this,n=this.$router,a=this.$route,s=n.resolve(this.to,a,this.append),i=s.location,o=s.route,d=s.href,u={},p=n.options.linkActiveClass,l=n.options.linkExactActiveClass,y=null==p?"router-link-active":p,f=null==l?"router-link-exact-active":l,h=null==this.activeClass?y:this.activeClass,v=null==this.exactActiveClass?f:this.exactActiveClass,T=o.redirectedFrom?m(null,z(o.redirectedFrom),null,n):o;u[v]=b(a,T,this.exactPath),u[h]=this.exact||this.exactPath?u[v]:function(e,t){return 0===e.path.replace(c,"/").indexOf(t.path.replace(c,"/"))&&(!t.hash||e.hash===t.hash)&&function(e,t){for(var n in t)if(!(n in e))return!1;return!0}(e.query,t.query)}(a,T);var _=u[v]?this.ariaCurrentValue:null,g=function(e){Y(e)&&(t.replace?n.replace(i,W):n.push(i,W))},w={click:Y};Array.isArray(this.event)?this.event.forEach((function(e){w[e]=g})):w[this.event]=g;var k={class:u},R=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:d,route:o,navigate:g,isActive:u[h],isExactActive:u[v]});if(R){if(1===R.length)return R[0];if(R.length>1||!R.length)return 0===R.length?e():e("span",{},R)}if("a"===this.tag)k.on=w,k.attrs={href:d,"aria-current":_};else{var I=function e(t){var n;if(t)for(var a=0;a<t.length;a++){if("a"===(n=t[a]).tag)return n;if(n.children&&(n=e(n.children)))return n}}(this.$slots.default);if(I){I.isStatic=!1;var A=I.data=r({},I.data);for(var M in A.on=A.on||{},A.on){var C=A.on[M];M in w&&(A.on[M]=Array.isArray(C)?C:[C])}for(var S in w)S in A.on?A.on[S].push(w[S]):A.on[S]=g;var x=I.data.attrs=r({},I.data.attrs);x.href=d,x["aria-current"]=_}else k.on=w}return e(this.tag,k,this.$slots.default)}};function Y(e){if(!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey||e.defaultPrevented||void 0!==e.button&&0!==e.button)){if(e.currentTarget&&e.currentTarget.getAttribute){var t=e.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(t))return}return e.preventDefault&&e.preventDefault(),!0}}var Q="undefined"!=typeof window;function J(e,t,n,a,r){var s=t||[],i=n||Object.create(null),o=a||Object.create(null);e.forEach((function(e){!function e(t,n,a,r,s,i){var o=r.path,d=r.name;0;var u=r.pathToRegexpOptions||{},p=function(e,t,n){n||(e=e.replace(/\/$/,""));if("/"===e[0])return e;if(null==t)return e;return I(t.path+"/"+e)}(o,s,u.strict);"boolean"==typeof r.caseSensitive&&(u.sensitive=r.caseSensitive);var l={path:p,regex:K(p,u),components:r.components||{default:r.component},alias:r.alias?"string"==typeof r.alias?[r.alias]:r.alias:[],instances:{},enteredCbs:{},name:d,parent:s,matchAs:i,redirect:r.redirect,beforeEnter:r.beforeEnter,meta:r.meta||{},props:null==r.props?{}:r.components?r.props:{default:r.props}};r.children&&r.children.forEach((function(r){var s=i?I(i+"/"+r.path):void 0;e(t,n,a,r,l,s)}));n[l.path]||(t.push(l.path),n[l.path]=l);if(void 0!==r.alias)for(var y=Array.isArray(r.alias)?r.alias:[r.alias],c=0;c<y.length;++c){0;var m={path:y[c],children:r.children};e(t,n,a,m,s,l.path||"/")}d&&(a[d]||(a[d]=l))}(s,i,o,e,r)}));for(var d=0,u=s.length;d<u;d++)"*"===s[d]&&(s.push(s.splice(d,1)[0]),u--,d--);return{pathList:s,pathMap:i,nameMap:o}}function K(e,t){return M(e,[],t)}function X(e,t){var n=J(e),a=n.pathList,r=n.pathMap,s=n.nameMap;function i(e,n,i){var o=z(e,n,!1,t),u=o.name;if(u){var p=s[u];if(!p)return d(null,o);var l=p.regex.keys.filter((function(e){return!e.optional})).map((function(e){return e.name}));if("object"!=typeof o.params&&(o.params={}),n&&"object"==typeof n.params)for(var y in n.params)!(y in o.params)&&l.indexOf(y)>-1&&(o.params[y]=n.params[y]);return o.path=B(p.path,o.params),d(p,o,i)}if(o.path){o.params={};for(var c=0;c<a.length;c++){var m=a[c],f=r[m];if(Z(f.regex,o.path,o.params))return d(f,o,i)}}return d(null,o)}function o(e,n){var a=e.redirect,r="function"==typeof a?a(m(e,n,null,t)):a;if("string"==typeof r&&(r={path:r}),!r||"object"!=typeof r)return d(null,n);var o=r,u=o.name,p=o.path,l=n.query,y=n.hash,c=n.params;if(l=o.hasOwnProperty("query")?o.query:l,y=o.hasOwnProperty("hash")?o.hash:y,c=o.hasOwnProperty("params")?o.params:c,u){s[u];return i({_normalized:!0,name:u,query:l,hash:y,params:c},void 0,n)}if(p){var f=function(e,t){return R(e,t.parent?t.parent.path:"/",!0)}(p,e);return i({_normalized:!0,path:B(f,c),query:l,hash:y},void 0,n)}return d(null,n)}function d(e,n,a){return e&&e.redirect?o(e,a||n):e&&e.matchAs?function(e,t,n){var a=i({_normalized:!0,path:B(n,t.params)});if(a){var r=a.matched,s=r[r.length-1];return t.params=a.params,d(s,t)}return d(null,t)}(0,n,e.matchAs):m(e,n,a,t)}return{match:i,addRoute:function(e,t){var n="object"!=typeof e?s[e]:void 0;J([t||e],a,r,s,n),n&&J(n.alias.map((function(e){return{path:e,children:[t]}})),a,r,s,n)},getRoutes:function(){return a.map((function(e){return r[e]}))},addRoutes:function(e){J(e,a,r,s)}}}function Z(e,t,n){var a=t.match(e);if(!a)return!1;if(!n)return!0;for(var r=1,s=a.length;r<s;++r){var i=e.keys[r-1];i&&(n[i.name||"pathMatch"]="string"==typeof a[r]?u(a[r]):a[r])}return!0}var ee=Q&&window.performance&&window.performance.now?window.performance:Date;function te(){return ee.now().toFixed(3)}var ne=te();function ae(){return ne}function re(e){return ne=e}var se=Object.create(null);function ie(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var e=window.location.protocol+"//"+window.location.host,t=window.location.href.replace(e,""),n=r({},window.history.state);return n.key=ae(),window.history.replaceState(n,"",t),window.addEventListener("popstate",ue),function(){window.removeEventListener("popstate",ue)}}function oe(e,t,n,a){if(e.app){var r=e.options.scrollBehavior;r&&e.app.$nextTick((function(){var s=function(){var e=ae();if(e)return se[e]}(),i=r.call(e,t,n,a?s:null);i&&("function"==typeof i.then?i.then((function(e){me(e,s)})).catch((function(e){0})):me(i,s))}))}}function de(){var e=ae();e&&(se[e]={x:window.pageXOffset,y:window.pageYOffset})}function ue(e){de(),e.state&&e.state.key&&re(e.state.key)}function pe(e){return ye(e.x)||ye(e.y)}function le(e){return{x:ye(e.x)?e.x:window.pageXOffset,y:ye(e.y)?e.y:window.pageYOffset}}function ye(e){return"number"==typeof e}var ce=/^#\d/;function me(e,t){var n,a="object"==typeof e;if(a&&"string"==typeof e.selector){var r=ce.test(e.selector)?document.getElementById(e.selector.slice(1)):document.querySelector(e.selector);if(r){var s=e.offset&&"object"==typeof e.offset?e.offset:{};t=function(e,t){var n=document.documentElement.getBoundingClientRect(),a=e.getBoundingClientRect();return{x:a.left-n.left-t.x,y:a.top-n.top-t.y}}(r,s={x:ye((n=s).x)?n.x:0,y:ye(n.y)?n.y:0})}else pe(e)&&(t=le(e))}else a&&pe(e)&&(t=le(e));t&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:t.x,top:t.y,behavior:e.behavior}):window.scrollTo(t.x,t.y))}var fe,he=Q&&((-1===(fe=window.navigator.userAgent).indexOf("Android 2.")&&-1===fe.indexOf("Android 4.0")||-1===fe.indexOf("Mobile Safari")||-1!==fe.indexOf("Chrome")||-1!==fe.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function ve(e,t){de();var n=window.history;try{if(t){var a=r({},n.state);a.key=ae(),n.replaceState(a,"",e)}else n.pushState({key:re(te())},"",e)}catch(n){window.location[t?"replace":"assign"](e)}}function Te(e){ve(e,!0)}function be(e,t,n){var a=function(r){r>=e.length?n():e[r]?t(e[r],(function(){a(r+1)})):a(r+1)};a(0)}var _e={redirected:2,aborted:4,cancelled:8,duplicated:16};function ge(e,t){return ke(e,t,_e.redirected,'Redirected when going from "'+e.fullPath+'" to "'+function(e){if("string"==typeof e)return e;if("path"in e)return e.path;var t={};return Re.forEach((function(n){n in e&&(t[n]=e[n])})),JSON.stringify(t,null,2)}(t)+'" via a navigation guard.')}function we(e,t){return ke(e,t,_e.cancelled,'Navigation cancelled from "'+e.fullPath+'" to "'+t.fullPath+'" with a new navigation.')}function ke(e,t,n,a){var r=new Error(a);return r._isRouter=!0,r.from=e,r.to=t,r.type=n,r}var Re=["params","query","hash"];function Ie(e){return Object.prototype.toString.call(e).indexOf("Error")>-1}function Ae(e,t){return Ie(e)&&e._isRouter&&(null==t||e.type===t)}function Me(e){return function(t,n,a){var r=!1,s=0,i=null;Ce(e,(function(e,t,n,o){if("function"==typeof e&&void 0===e.cid){r=!0,s++;var d,u=Ee((function(t){var r;((r=t).__esModule||xe&&"Module"===r[Symbol.toStringTag])&&(t=t.default),e.resolved="function"==typeof t?t:G.extend(t),n.components[o]=t,--s<=0&&a()})),p=Ee((function(e){var t="Failed to resolve async component "+o+": "+e;i||(i=Ie(e)?e:new Error(t),a(i))}));try{d=e(u,p)}catch(e){p(e)}if(d)if("function"==typeof d.then)d.then(u,p);else{var l=d.component;l&&"function"==typeof l.then&&l.then(u,p)}}})),r||a()}}function Ce(e,t){return Se(e.map((function(e){return Object.keys(e.components).map((function(n){return t(e.components[n],e.instances[n],e,n)}))})))}function Se(e){return Array.prototype.concat.apply([],e)}var xe="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function Ee(e){var t=!1;return function(){for(var n=[],a=arguments.length;a--;)n[a]=arguments[a];if(!t)return t=!0,e.apply(this,n)}}var Fe=function(e,t){this.router=e,this.base=function(e){if(!e)if(Q){var t=document.querySelector("base");e=(e=t&&t.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else e="/";"/"!==e.charAt(0)&&(e="/"+e);return e.replace(/\/$/,"")}(t),this.current=h,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function Oe(e,t,n,a){var r=Ce(e,(function(e,a,r,s){var i=function(e,t){"function"!=typeof e&&(e=G.extend(e));return e.options[t]}(e,t);if(i)return Array.isArray(i)?i.map((function(e){return n(e,a,r,s)})):n(i,a,r,s)}));return Se(a?r.reverse():r)}function Ne(e,t){if(t)return function(){return e.apply(t,arguments)}}Fe.prototype.listen=function(e){this.cb=e},Fe.prototype.onReady=function(e,t){this.ready?e():(this.readyCbs.push(e),t&&this.readyErrorCbs.push(t))},Fe.prototype.onError=function(e){this.errorCbs.push(e)},Fe.prototype.transitionTo=function(e,t,n){var a,r=this;try{a=this.router.match(e,this.current)}catch(e){throw this.errorCbs.forEach((function(t){t(e)})),e}var s=this.current;this.confirmTransition(a,(function(){r.updateRoute(a),t&&t(a),r.ensureURL(),r.router.afterHooks.forEach((function(e){e&&e(a,s)})),r.ready||(r.ready=!0,r.readyCbs.forEach((function(e){e(a)})))}),(function(e){n&&n(e),e&&!r.ready&&(Ae(e,_e.redirected)&&s===h||(r.ready=!0,r.readyErrorCbs.forEach((function(t){t(e)}))))}))},Fe.prototype.confirmTransition=function(e,t,n){var a=this,r=this.current;this.pending=e;var s,i,o=function(e){!Ae(e)&&Ie(e)&&(a.errorCbs.length?a.errorCbs.forEach((function(t){t(e)})):console.error(e)),n&&n(e)},d=e.matched.length-1,u=r.matched.length-1;if(b(e,r)&&d===u&&e.matched[d]===r.matched[u])return this.ensureURL(),o(((i=ke(s=r,e,_e.duplicated,'Avoided redundant navigation to current location: "'+s.fullPath+'".')).name="NavigationDuplicated",i));var p=function(e,t){var n,a=Math.max(e.length,t.length);for(n=0;n<a&&e[n]===t[n];n++);return{updated:t.slice(0,n),activated:t.slice(n),deactivated:e.slice(n)}}(this.current.matched,e.matched),l=p.updated,y=p.deactivated,c=p.activated,m=[].concat(function(e){return Oe(e,"beforeRouteLeave",Ne,!0)}(y),this.router.beforeHooks,function(e){return Oe(e,"beforeRouteUpdate",Ne)}(l),c.map((function(e){return e.beforeEnter})),Me(c)),f=function(t,n){if(a.pending!==e)return o(we(r,e));try{t(e,r,(function(t){!1===t?(a.ensureURL(!0),o(function(e,t){return ke(e,t,_e.aborted,'Navigation aborted from "'+e.fullPath+'" to "'+t.fullPath+'" via a navigation guard.')}(r,e))):Ie(t)?(a.ensureURL(!0),o(t)):"string"==typeof t||"object"==typeof t&&("string"==typeof t.path||"string"==typeof t.name)?(o(ge(r,e)),"object"==typeof t&&t.replace?a.replace(t):a.push(t)):n(t)}))}catch(e){o(e)}};be(m,f,(function(){be(function(e){return Oe(e,"beforeRouteEnter",(function(e,t,n,a){return function(e,t,n){return function(a,r,s){return e(a,r,(function(e){"function"==typeof e&&(t.enteredCbs[n]||(t.enteredCbs[n]=[]),t.enteredCbs[n].push(e)),s(e)}))}}(e,n,a)}))}(c).concat(a.router.resolveHooks),f,(function(){if(a.pending!==e)return o(we(r,e));a.pending=null,t(e),a.router.app&&a.router.app.$nextTick((function(){g(e)}))}))}))},Fe.prototype.updateRoute=function(e){this.current=e,this.cb&&this.cb(e)},Fe.prototype.setupListeners=function(){},Fe.prototype.teardown=function(){this.listeners.forEach((function(e){e()})),this.listeners=[],this.current=h,this.pending=null};var De=function(e){function t(t,n){e.call(this,t,n),this._startLocation=Ue(this.base)}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.setupListeners=function(){var e=this;if(!(this.listeners.length>0)){var t=this.router,n=t.options.scrollBehavior,a=he&&n;a&&this.listeners.push(ie());var r=function(){var n=e.current,r=Ue(e.base);e.current===h&&r===e._startLocation||e.transitionTo(r,(function(e){a&&oe(t,e,n,!0)}))};window.addEventListener("popstate",r),this.listeners.push((function(){window.removeEventListener("popstate",r)}))}},t.prototype.go=function(e){window.history.go(e)},t.prototype.push=function(e,t,n){var a=this,r=this.current;this.transitionTo(e,(function(e){ve(I(a.base+e.fullPath)),oe(a.router,e,r,!1),t&&t(e)}),n)},t.prototype.replace=function(e,t,n){var a=this,r=this.current;this.transitionTo(e,(function(e){Te(I(a.base+e.fullPath)),oe(a.router,e,r,!1),t&&t(e)}),n)},t.prototype.ensureURL=function(e){if(Ue(this.base)!==this.current.fullPath){var t=I(this.base+this.current.fullPath);e?ve(t):Te(t)}},t.prototype.getCurrentLocation=function(){return Ue(this.base)},t}(Fe);function Ue(e){var t=window.location.pathname;return e&&0===t.toLowerCase().indexOf(e.toLowerCase())&&(t=t.slice(e.length)),(t||"/")+window.location.search+window.location.hash}var $e=function(e){function t(t,n,a){e.call(this,t,n),a&&function(e){var t=Ue(e);if(!/^\/#/.test(t))return window.location.replace(I(e+"/#"+t)),!0}(this.base)||Le()}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.setupListeners=function(){var e=this;if(!(this.listeners.length>0)){var t=this.router.options.scrollBehavior,n=he&&t;n&&this.listeners.push(ie());var a=function(){var t=e.current;Le()&&e.transitionTo(Pe(),(function(a){n&&oe(e.router,a,t,!0),he||He(a.fullPath)}))},r=he?"popstate":"hashchange";window.addEventListener(r,a),this.listeners.push((function(){window.removeEventListener(r,a)}))}},t.prototype.push=function(e,t,n){var a=this,r=this.current;this.transitionTo(e,(function(e){qe(e.fullPath),oe(a.router,e,r,!1),t&&t(e)}),n)},t.prototype.replace=function(e,t,n){var a=this,r=this.current;this.transitionTo(e,(function(e){He(e.fullPath),oe(a.router,e,r,!1),t&&t(e)}),n)},t.prototype.go=function(e){window.history.go(e)},t.prototype.ensureURL=function(e){var t=this.current.fullPath;Pe()!==t&&(e?qe(t):He(t))},t.prototype.getCurrentLocation=function(){return Pe()},t}(Fe);function Le(){var e=Pe();return"/"===e.charAt(0)||(He("/"+e),!1)}function Pe(){var e=window.location.href,t=e.indexOf("#");return t<0?"":e=e.slice(t+1)}function je(e){var t=window.location.href,n=t.indexOf("#");return(n>=0?t.slice(0,n):t)+"#"+e}function qe(e){he?ve(je(e)):window.location.hash=e}function He(e){he?Te(je(e)):window.location.replace(je(e))}var Be=function(e){function t(t,n){e.call(this,t,n),this.stack=[],this.index=-1}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.push=function(e,t,n){var a=this;this.transitionTo(e,(function(e){a.stack=a.stack.slice(0,a.index+1).concat(e),a.index++,t&&t(e)}),n)},t.prototype.replace=function(e,t,n){var a=this;this.transitionTo(e,(function(e){a.stack=a.stack.slice(0,a.index).concat(e),t&&t(e)}),n)},t.prototype.go=function(e){var t=this,n=this.index+e;if(!(n<0||n>=this.stack.length)){var a=this.stack[n];this.confirmTransition(a,(function(){var e=t.current;t.index=n,t.updateRoute(a),t.router.afterHooks.forEach((function(t){t&&t(a,e)}))}),(function(e){Ae(e,_e.duplicated)&&(t.index=n)}))}},t.prototype.getCurrentLocation=function(){var e=this.stack[this.stack.length-1];return e?e.fullPath:"/"},t.prototype.ensureURL=function(){},t}(Fe),ze=function(e){void 0===e&&(e={}),this.app=null,this.apps=[],this.options=e,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=X(e.routes||[],this);var t=e.mode||"hash";switch(this.fallback="history"===t&&!he&&!1!==e.fallback,this.fallback&&(t="hash"),Q||(t="abstract"),this.mode=t,t){case"history":this.history=new De(this,e.base);break;case"hash":this.history=new $e(this,e.base,this.fallback);break;case"abstract":this.history=new Be(this,e.base);break;default:0}},Ge={currentRoute:{configurable:!0}};function We(e,t){return e.push(t),function(){var n=e.indexOf(t);n>-1&&e.splice(n,1)}}ze.prototype.match=function(e,t,n){return this.matcher.match(e,t,n)},Ge.currentRoute.get=function(){return this.history&&this.history.current},ze.prototype.init=function(e){var t=this;if(this.apps.push(e),e.$once("hook:destroyed",(function(){var n=t.apps.indexOf(e);n>-1&&t.apps.splice(n,1),t.app===e&&(t.app=t.apps[0]||null),t.app||t.history.teardown()})),!this.app){this.app=e;var n=this.history;if(n instanceof De||n instanceof $e){var a=function(e){n.setupListeners(),function(e){var a=n.current,r=t.options.scrollBehavior;he&&r&&"fullPath"in e&&oe(t,e,a,!1)}(e)};n.transitionTo(n.getCurrentLocation(),a,a)}n.listen((function(e){t.apps.forEach((function(t){t._route=e}))}))}},ze.prototype.beforeEach=function(e){return We(this.beforeHooks,e)},ze.prototype.beforeResolve=function(e){return We(this.resolveHooks,e)},ze.prototype.afterEach=function(e){return We(this.afterHooks,e)},ze.prototype.onReady=function(e,t){this.history.onReady(e,t)},ze.prototype.onError=function(e){this.history.onError(e)},ze.prototype.push=function(e,t,n){var a=this;if(!t&&!n&&"undefined"!=typeof Promise)return new Promise((function(t,n){a.history.push(e,t,n)}));this.history.push(e,t,n)},ze.prototype.replace=function(e,t,n){var a=this;if(!t&&!n&&"undefined"!=typeof Promise)return new Promise((function(t,n){a.history.replace(e,t,n)}));this.history.replace(e,t,n)},ze.prototype.go=function(e){this.history.go(e)},ze.prototype.back=function(){this.go(-1)},ze.prototype.forward=function(){this.go(1)},ze.prototype.getMatchedComponents=function(e){var t=e?e.matched?e:this.resolve(e).route:this.currentRoute;return t?[].concat.apply([],t.matched.map((function(e){return Object.keys(e.components).map((function(t){return e.components[t]}))}))):[]},ze.prototype.resolve=function(e,t,n){var a=z(e,t=t||this.history.current,n,this),r=this.match(a,t),s=r.redirectedFrom||r.fullPath;return{location:a,route:r,href:function(e,t,n){var a="hash"===n?"#"+t:t;return e?I(e+"/"+a):a}(this.history.base,s,this.mode),normalizedTo:a,resolved:r}},ze.prototype.getRoutes=function(){return this.matcher.getRoutes()},ze.prototype.addRoute=function(e,t){this.matcher.addRoute(e,t),this.history.current!==h&&this.history.transitionTo(this.history.getCurrentLocation())},ze.prototype.addRoutes=function(e){this.matcher.addRoutes(e),this.history.current!==h&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(ze.prototype,Ge),ze.install=function e(t){if(!e.installed||G!==t){e.installed=!0,G=t;var n=function(e){return void 0!==e},a=function(e,t){var a=e.$options._parentVnode;n(a)&&n(a=a.data)&&n(a=a.registerRouteInstance)&&a(e,t)};t.mixin({beforeCreate:function(){n(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),t.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,a(this,this)},destroyed:function(){a(this)}}),Object.defineProperty(t.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(t.prototype,"$route",{get:function(){return this._routerRoot._route}}),t.component("RouterView",w),t.component("RouterLink",V);var r=t.config.optionMergeStrategies;r.beforeRouteEnter=r.beforeRouteLeave=r.beforeRouteUpdate=r.created}},ze.version="3.5.1",ze.isNavigationFailure=Ae,ze.NavigationFailureType=_e,ze.START_LOCATION=h,Q&&window.Vue&&window.Vue.use(ze);var Ve=ze,Ye=function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"min-h-screen bg-gray-100 px-4 pt-6"},[t("router-view")],1)};Ye._withStripped=!0;n(4);function Qe(e,t,n,a,r,s,i,o){var d,u="function"==typeof e?e.options:e;if(t&&(u.render=t,u.staticRenderFns=n,u._compiled=!0),a&&(u.functional=!0),s&&(u._scopeId="data-v-"+s),i?(d=function(e){(e=e||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(e=__VUE_SSR_CONTEXT__),r&&r.call(this,e),e&&e._registeredComponents&&e._registeredComponents.add(i)},u._ssrRegister=d):r&&(d=o?function(){r.call(this,(u.functional?this.parent:this).$root.$options.shadowRoot)}:r),d)if(u.functional){u._injectStyles=d;var p=u.render;u.render=function(e,t){return d.call(t),p(e,t)}}else{var l=u.beforeCreate;u.beforeCreate=l?[].concat(l,d):[d]}return{exports:e,options:u}}var Je=Qe({},Ye,[],!1,null,null,null);Je.options.__file="node_modules/hardhat-docgen/src/App.vue";var Ke=Je.exports,Xe=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"w-full space-y-10 md:max-w-screen-sm lg:max-w-screen-md mx-auto"},[n("HeaderBar"),e._v(" "),n("div",{staticClass:"pb-32"},[n("div",{staticClass:"space-y-4"},[n("span",{staticClass:"text-lg"},[e._v("\n        "+e._s(e.json.source)+"\n      ")]),e._v(" "),n("h1",{staticClass:"text-xl"},[e._v("\n        "+e._s(e.json.name)+"\n      ")]),e._v(" "),n("h2",{staticClass:"text-lg"},[e._v("\n        "+e._s(e.json.title)+"\n      ")]),e._v(" "),n("h2",{staticClass:"text-lg"},[e._v("\n        "+e._s(e.json.author)+"\n      ")]),e._v(" "),n("p",[e._v(e._s(e.json.notice))]),e._v(" "),n("p",[e._v(e._s(e.json.details))])]),e._v(" "),n("div",{staticClass:"mt-8"},[e.json.hasOwnProperty("constructor")?n("Member",{attrs:{json:e.json.constructor}}):e._e()],1),e._v(" "),n("div",{staticClass:"mt-8"},[e.json.receive?n("Member",{attrs:{json:e.json.receive}}):e._e()],1),e._v(" "),n("div",{staticClass:"mt-8"},[e.json.fallback?n("Member",{attrs:{json:e.json.fallback}}):e._e()],1),e._v(" "),e.json.events?n("MemberSet",{attrs:{title:"Events",json:e.json.events}}):e._e(),e._v(" "),e.json.stateVariables?n("MemberSet",{attrs:{title:"State Variables",json:e.json.stateVariables}}):e._e(),e._v(" "),e.json.methods?n("MemberSet",{attrs:{title:"Methods",json:e.json.methods}}):e._e()],1),e._v(" "),n("FooterBar")],1)};Xe._withStripped=!0;var Ze=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"bg-gray-100 fixed bottom-0 right-0 w-full border-t border-dashed border-gray-300"},[n("div",{staticClass:"w-full text-center py-2 md:max-w-screen-sm lg:max-w-screen-md mx-auto"},[n("button",{staticClass:"py-1 px-2 text-gray-500",on:{click:function(t){return e.openLink(e.repository)}}},[e._v("\n      built with "+e._s(e.name)+"\n    ")])])])};Ze._withStripped=!0;var et=n(2),tt=Qe({data:function(){return{repository:et.b,name:et.a}},methods:{openLink(e){window.open(e,"_blank")}}},Ze,[],!1,null,null,null);tt.options.__file="node_modules/hardhat-docgen/src/components/FooterBar.vue";var nt=tt.exports,at=function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"w-full border-b border-dashed py-2 border-gray-300"},[t("router-link",{staticClass:"py-2 text-gray-500",attrs:{to:"/"}},[this._v("\n    <- Go back\n  ")])],1)};at._withStripped=!0;var rt=Qe({},at,[],!1,null,null,null);rt.options.__file="node_modules/hardhat-docgen/src/components/HeaderBar.vue";var st=rt.exports,it=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"border-2 border-gray-400 border-dashed w-full p-2"},[n("h3",{staticClass:"text-lg pb-2 mb-2 border-b-2 border-gray-400 border-dashed"},[e._v("\n    "+e._s(e.name)+" "+e._s(e.keywords)+" "+e._s(e.inputSignature)+"\n  ")]),e._v(" "),n("div",{staticClass:"space-y-3"},[n("p",[e._v(e._s(e.json.notice))]),e._v(" "),n("p",[e._v(e._s(e.json.details))]),e._v(" "),n("MemberSection",{attrs:{name:"Parameters",items:e.inputs}}),e._v(" "),n("MemberSection",{attrs:{name:"Return Values",items:e.outputs}})],1)])};it._withStripped=!0;var ot=function(){var e=this,t=e.$createElement,n=e._self._c||t;return e.items.length>0?n("ul",[n("h4",{staticClass:"text-lg"},[e._v("\n    "+e._s(e.name)+"\n  ")]),e._v(" "),e._l(e.items,(function(t,a){return n("li",{key:a},[n("span",{staticClass:"bg-gray-300"},[e._v(e._s(t.type))]),e._v(" "),n("b",[e._v(e._s(t.name||"_"+a))]),t.desc?n("span",[e._v(": "),n("i",[e._v(e._s(t.desc))])]):e._e()])}))],2):e._e()};ot._withStripped=!0;var dt=Qe({props:{name:{type:String,default:""},items:{type:Array,default:()=>new Array}}},ot,[],!1,null,null,null);dt.options.__file="node_modules/hardhat-docgen/src/components/MemberSection.vue";var ut=Qe({components:{MemberSection:dt.exports},props:{json:{type:Object,default:()=>new Object}},computed:{name:function(){return this.json.name||this.json.type},keywords:function(){let e=[];return this.json.stateMutability&&e.push(this.json.stateMutability),"true"===this.json.anonymous&&e.push("anonymous"),e.join(" ")},params:function(){return this.json.params||{}},returns:function(){return this.json.returns||{}},inputs:function(){return(this.json.inputs||[]).map(e=>({...e,desc:this.params[e.name]}))},inputSignature:function(){return`(${this.inputs.map(e=>e.type).join(",")})`},outputs:function(){return(this.json.outputs||[]).map((e,t)=>({...e,desc:this.returns[e.name||"_"+t]}))},outputSignature:function(){return`(${this.outputs.map(e=>e.type).join(",")})`}}},it,[],!1,null,null,null);ut.options.__file="node_modules/hardhat-docgen/src/components/Member.vue";var pt=ut.exports,lt=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"w-full mt-8"},[n("h2",{staticClass:"text-lg"},[e._v(e._s(e.title))]),e._v(" "),e._l(Object.keys(e.json),(function(t){return n("Member",{key:t,staticClass:"mt-3",attrs:{json:e.json[t]}})}))],2)};lt._withStripped=!0;var yt=Qe({components:{Member:pt},props:{title:{type:String,default:""},json:{type:Object,default:()=>new Object}}},lt,[],!1,null,null,null);yt.options.__file="node_modules/hardhat-docgen/src/components/MemberSet.vue";var ct=Qe({components:{Member:pt,MemberSet:yt.exports,HeaderBar:st,FooterBar:nt},props:{json:{type:Object,default:()=>new Object}}},Xe,[],!1,null,null,null);ct.options.__file="node_modules/hardhat-docgen/src/components/Contract.vue";var mt=ct.exports,ft=function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"w-full space-y-10 md:max-w-screen-sm lg:max-w-screen-md mx-auto pb-32"},[t("Branch",{attrs:{json:this.trees,name:"Sources:"}}),this._v(" "),t("FooterBar",{staticClass:"mt-20"})],1)};ft._withStripped=!0;var ht=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",[e._v("\n  "+e._s(e.name)+"\n  "),Array.isArray(e.json)?n("div",{staticClass:"pl-5"},e._l(e.json,(function(t,a){return n("div",{key:a},[n("router-link",{attrs:{to:t.source+":"+t.name}},[e._v("\n        "+e._s(t.name)+"\n      ")])],1)})),0):n("div",{staticClass:"pl-5"},e._l(Object.keys(e.json),(function(t){return n("div",{key:t},[n("Branch",{attrs:{json:e.json[t],name:t}})],1)})),0)])};ht._withStripped=!0;var vt=Qe({name:"Branch",props:{name:{type:String,default:null},json:{type:[Object,Array],default:()=>new Object}}},ht,[],!1,null,null,null);vt.options.__file="node_modules/hardhat-docgen/src/components/Branch.vue";var Tt=Qe({components:{Branch:vt.exports,FooterBar:nt},props:{json:{type:Object,default:()=>new Object}},computed:{trees:function(){let e={};for(let t in this.json)t.split(/(?<=\/)/).reduce(function(e,n){if(!n.includes(":"))return e[n]=e[n]||{},e[n];{let[a]=n.split(":");e[a]=e[a]||[],e[a].push(this.json[t])}}.bind(this),e);return e}}},ft,[],!1,null,null,null);Tt.options.__file="node_modules/hardhat-docgen/src/components/Index.vue";var bt=Tt.exports;a.a.use(Ve);const _t={"contracts/ERC1155ERC721.sol:ERC1155ERC721":{source:"contracts/ERC1155ERC721.sol",name:"ERC1155ERC721",title:"A ERC1155 and ERC721 Implmentation",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_owner",type:"address"},{indexed:!0,internalType:"address",name:"_approved",type:"address"},{indexed:!0,internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"Approval",type:"event",details:"Emitted when `_owner` enables `_approved` to manage the `_tokenId` token.Not included in ERC721 interface because it causes a conflict between ERC1155 and ERC721"},"ApprovalForAll(address,address,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_owner",type:"address"},{indexed:!0,internalType:"address",name:"_operator",type:"address"},{indexed:!1,internalType:"bool",name:"_approved",type:"bool"}],name:"ApprovalForAll",type:"event"},"RecordingTransferSingle(address,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"_operator",type:"address"},{indexed:!0,internalType:"address",name:"_from",type:"address"},{indexed:!0,internalType:"address",name:"_to",type:"address"},{indexed:!0,internalType:"uint256",name:"_tokenId",type:"uint256"},{indexed:!1,internalType:"uint256",name:"_value",type:"uint256"}],name:"RecordingTransferSingle",type:"event",details:"Emitted when `_value` amount of `_tokenId` recording token is transferred from `_from` to `_to` by `_operator`."},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_from",type:"address"},{indexed:!0,internalType:"address",name:"_to",type:"address"},{indexed:!0,internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"Transfer",type:"event",details:"Emitted when `_tokenId` token is transferred from `_from` to `_to`.Not included in ERC721 interface because it causes a conflict between ERC1155 and ERC721"},"TransferBatch(address,address,address,uint256[],uint256[])":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_operator",type:"address"},{indexed:!0,internalType:"address",name:"_from",type:"address"},{indexed:!0,internalType:"address",name:"_to",type:"address"},{indexed:!1,internalType:"uint256[]",name:"_tokenIds",type:"uint256[]"},{indexed:!1,internalType:"uint256[]",name:"_values",type:"uint256[]"}],name:"TransferBatch",type:"event"},"TransferSingle(address,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_operator",type:"address"},{indexed:!0,internalType:"address",name:"_from",type:"address"},{indexed:!0,internalType:"address",name:"_to",type:"address"},{indexed:!1,internalType:"uint256",name:"_tokenId",type:"uint256"},{indexed:!1,internalType:"uint256",name:"_value",type:"uint256"}],name:"TransferSingle",type:"event"},"URI(string,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"string",name:"_value",type:"string"},{indexed:!0,internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"URI",type:"event"}},methods:{"approve(address,uint256)":{inputs:[{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"approve",outputs:[],stateMutability:"nonpayable",type:"function",details:"The zero address indicates there is no approved address.  Throws unless `msg.sender` is the current NFT owner, or an authorized  operator of the current owner.",params:{_to:"The new approved NFT controller",_tokenId:"The NFT to approve"},notice:"Change or reaffirm the approved address for an NFT"},"balanceOf(address,uint256)":{inputs:[{internalType:"address",name:"_owner",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"It accept both ",params:{_owner:"The address of the token holder",_tokenId:"ID of the Token"},returns:{_0:"The _owner's balance of the Token type requested"},notice:"Get the balance of an account's Tokens."},"balanceOf(address)":{inputs:[{internalType:"address",name:"_owner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_owner:"An address for whom to query the balance"},returns:{_0:"The number of NFTs owned by `_owner`, possibly zero"},notice:"Count all NFTs assigned to an owner"},"balanceOfBatch(address[],uint256[])":{inputs:[{internalType:"address[]",name:"_owners",type:"address[]"},{internalType:"uint256[]",name:"_tokenIds",type:"uint256[]"}],name:"balanceOfBatch",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"view",type:"function",params:{_owners:"The addresses of the token holders",_tokenIds:"ID of the Tokens"},returns:{_0:"The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)"},notice:"Get the balance of multiple account/token pairs"},"getApproved(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"getApproved",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Throws if `_tokenId` is not a valid NFT.",params:{_tokenId:"The NFT to find the approved address for"},returns:{_0:"The approved address for this NFT, or the zero address if there is none"},notice:"Get the approved address for a single NFT"},"isApprovedForAll(address,address)":{inputs:[{internalType:"address",name:"_owner",type:"address"},{internalType:"address",name:"_operator",type:"address"}],name:"isApprovedForAll",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{_operator:"Address of authorized operator",_owner:"The owner of the Tokens"},returns:{_0:"True if the operator is approved, false if not"},notice:"Queries the approval status of an operator for a given owner."},"ownerOf(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"ownerOf",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"NFTs assigned to zero address or FT token are considered invalid,  and queries about them do throw.",params:{_tokenId:"The identifier for an NFT"},returns:{_0:"The address of the owner of the NFT"},notice:"Find the owner of an NFT"},"recordingBalanceOf(address,uint256)":{inputs:[{internalType:"address",name:"_owner",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"recordingBalanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_owner:"An address for whom to query the balance",_tokenId:"The token ID to be queried"},notice:"Count all recording token assigned to an address"},"recordingOperatorOf(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"recordingOperatorOf",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",params:{_tokenId:"Token ID to be queried"},returns:{_0:"The recording operator address"},notice:"Returns the recording operator of a token"},"recordingTransferFrom(address,address,uint256,uint256)":{inputs:[{internalType:"address",name:"_from",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"},{internalType:"uint256",name:"_value",type:"uint256"}],name:"recordingTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"If `_to` is zeroaddress or `msg.sender` is not recording operator,  it throwsa.",params:{_from:"Current owner of recording token",_to:"New owner",_tokenId:"The token to transfer",_value:"The amount to transfer"},notice:"Transfer recording token"},"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)":{inputs:[{internalType:"address",name:"_from",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256[]",name:"_tokenIds",type:"uint256[]"},{internalType:"uint256[]",name:"_values",type:"uint256[]"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"safeBatchTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:'Caller must be approved to manage the tokens being transferred out of the `_from` account (see "Approval" section of the standard). MUST revert if `_to` is the zero address. MUST revert if length of `_tokenIds` is not the same as length of `_values`. MUST revert if any of the balance(s) of the holder(s) for token(s) in `_tokenIds` is lower than the respective amount(s) in `_values` sent to the recipient. MUST revert on any other error. MUST emit `TransferSingle` or `TransferBatch` event(s) such that all the balance changes are reflected (see "Safe Transfer Rules" section of the standard). Balance changes and events MUST follow the ordering of the arrays (_tokenIds[0]/_values[0] before _tokenIds[1]/_values[1], etc). After the above conditions for the transfer(s) in the batch are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call the relevant `ERC1155TokenReceiver` hook(s) on `_to` and act appropriately (see "Safe Transfer Rules" section of the standard).',params:{_data:"Additional data with no specified format, MUST be sent unaltered in call to the `ERC1155TokenReceiver` hook(s) on `_to`",_from:"Source address",_to:"Target address",_tokenIds:"IDs of each token type (order and length must match _values array)",_values:"Transfer amounts per token type (order and length must match _tokenIds array)"},notice:"Transfers `_values` amount(s) of `_tokenIds` from the `_from` address to the `_to` address specified (with safety call)."},"safeTransferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"_from",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:'This works identically to the other function with an extra data parameter,  except this function just sets data to "".',params:{_from:"The current owner of the NFT",_to:"The new owner",_tokenId:"The NFT to transfer"},notice:"Transfers the ownership of an NFT from one address to another address"},"safeTransferFrom(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"_from",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:'Throws unless `msg.sender` is the current owner, an authorized  operator, or the approved address for this NFT. Throws if `_from` is  not the current owner. Throws if `_to` is the zero address. Throws if  `_tokenId` is not a valid NFT. When transfer is complete, this function  checks if `_to` is a smart contract (code size > 0). If so, it calls  `onERC721Received` on `_to` and throws if the return value is not  `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`.',params:{_data:"Additional data with no specified format, sent in call to `_to`",_from:"The current owner of the NFT",_to:"The new owner",_tokenId:"The NFT to transfer"},notice:"Transfers the ownership of an NFT from one address to another address"},"safeTransferFrom(address,address,uint256,uint256,bytes)":{inputs:[{internalType:"address",name:"_from",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"},{internalType:"uint256",name:"_value",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:'Caller must be approved to manage the tokens being transferred out of the `_from` account (see "Approval" section of the standard). MUST revert if `_to` is the zero address. MUST revert if balance of holder for token `_tokenId` is lower than the `_value` sent. MUST revert on any other error. MUST emit the `TransferSingle` event to reflect the balance change (see "Safe Transfer Rules" section of the standard). After the above conditions are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call `onERC1155Received` on `_to` and act appropriately (see "Safe Transfer Rules" section of the standard).',params:{_data:"Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `_to`",_from:"Source address",_to:"Target address",_tokenId:"ID of the token type",_value:"Transfer amount"},notice:"Transfers `_value` amount of an `_tokenId` from the `_from` address to the `_to` address specified (with safety call)."},"setApprovalForAll(address,bool)":{inputs:[{internalType:"address",name:"_operator",type:"address"},{internalType:"bool",name:"_approved",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"MUST emit the ApprovalForAll event on success.",params:{_approved:"True if the operator is approved, false to revoke approval",_operator:"Address to add to the set of authorized operators"},notice:'Enable or disable approval for a third party ("operator") to manage all of the caller\'s tokens.'},"settingOperatorOf(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"settingOperatorOf",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",params:{_tokenId:"Token ID to be queried"},returns:{_0:"The setting operator address"},notice:"Returns the setting operator of a token"},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"_interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"pure",type:"function",details:"Interface identification is specified in ERC-165. This function  uses less than 30,000 gas.",params:{_interfaceId:"The interface identifier, as specified in ERC-165"},returns:{_0:"`true` if the contract implements `_interfaceId`,  `false` otherwise"},notice:"Query if a contract implements an interface"},"timeIntervalOf(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"timeIntervalOf",outputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_tokenId:"Token ID to be queried"},returns:{_0:"The starting time in unix time",_1:"The ending time in unix time"},notice:"Returns the starting time and ending time of token holding time calculation"},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"_from",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"transferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Throws unless `msg.sender` is the current owner, an authorized  operator, or the approved address for this NFT. Throws if `_from` is  not the current owner. Throws if `_to` is the zero address. Throws if  `_tokenId` is not a valid NFT.",params:{_from:"The current owner of the NFT",_to:"The new owner",_tokenId:"The NFT to transfer"},notice:"Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE  THEY MAY BE PERMANENTLY LOST"}}},"contracts/ERC1155ERC721Metadata.sol:ERC1155ERC721Metadata":{source:"contracts/ERC1155ERC721Metadata.sol",name:"ERC1155ERC721Metadata",title:"A metadata extension implementation for ERC1155 and ERC721",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_owner",type:"address"},{indexed:!0,internalType:"address",name:"_approved",type:"address"},{indexed:!0,internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"Approval",type:"event"},"ApprovalForAll(address,address,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_owner",type:"address"},{indexed:!0,internalType:"address",name:"_operator",type:"address"},{indexed:!1,internalType:"bool",name:"_approved",type:"bool"}],name:"ApprovalForAll",type:"event"},"RecordingTransferSingle(address,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"_operator",type:"address"},{indexed:!0,internalType:"address",name:"_from",type:"address"},{indexed:!0,internalType:"address",name:"_to",type:"address"},{indexed:!0,internalType:"uint256",name:"_tokenId",type:"uint256"},{indexed:!1,internalType:"uint256",name:"_value",type:"uint256"}],name:"RecordingTransferSingle",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_from",type:"address"},{indexed:!0,internalType:"address",name:"_to",type:"address"},{indexed:!0,internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"Transfer",type:"event"},"TransferBatch(address,address,address,uint256[],uint256[])":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_operator",type:"address"},{indexed:!0,internalType:"address",name:"_from",type:"address"},{indexed:!0,internalType:"address",name:"_to",type:"address"},{indexed:!1,internalType:"uint256[]",name:"_tokenIds",type:"uint256[]"},{indexed:!1,internalType:"uint256[]",name:"_values",type:"uint256[]"}],name:"TransferBatch",type:"event"},"TransferSingle(address,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_operator",type:"address"},{indexed:!0,internalType:"address",name:"_from",type:"address"},{indexed:!0,internalType:"address",name:"_to",type:"address"},{indexed:!1,internalType:"uint256",name:"_tokenId",type:"uint256"},{indexed:!1,internalType:"uint256",name:"_value",type:"uint256"}],name:"TransferSingle",type:"event"},"URI(string,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"string",name:"_value",type:"string"},{indexed:!0,internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"URI",type:"event"}},methods:{"approve(address,uint256)":{inputs:[{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"approve",outputs:[],stateMutability:"nonpayable",type:"function",details:"The zero address indicates there is no approved address.  Throws unless `msg.sender` is the current NFT owner, or an authorized  operator of the current owner.",params:{_to:"The new approved NFT controller",_tokenId:"The NFT to approve"},notice:"Change or reaffirm the approved address for an NFT"},"balanceOf(address,uint256)":{inputs:[{internalType:"address",name:"_owner",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"It accept both ",params:{_owner:"The address of the token holder",_tokenId:"ID of the Token"},returns:{_0:"The _owner's balance of the Token type requested"},notice:"Get the balance of an account's Tokens."},"balanceOf(address)":{inputs:[{internalType:"address",name:"_owner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_owner:"An address for whom to query the balance"},returns:{_0:"The number of NFTs owned by `_owner`, possibly zero"},notice:"Count all NFTs assigned to an owner"},"balanceOfBatch(address[],uint256[])":{inputs:[{internalType:"address[]",name:"_owners",type:"address[]"},{internalType:"uint256[]",name:"_tokenIds",type:"uint256[]"}],name:"balanceOfBatch",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"view",type:"function",params:{_owners:"The addresses of the token holders",_tokenIds:"ID of the Tokens"},returns:{_0:"The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)"},notice:"Get the balance of multiple account/token pairs"},"getApproved(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"getApproved",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Throws if `_tokenId` is not a valid NFT.",params:{_tokenId:"The NFT to find the approved address for"},returns:{_0:"The approved address for this NFT, or the zero address if there is none"},notice:"Get the approved address for a single NFT"},"isApprovedForAll(address,address)":{inputs:[{internalType:"address",name:"_owner",type:"address"},{internalType:"address",name:"_operator",type:"address"}],name:"isApprovedForAll",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{_operator:"Address of authorized operator",_owner:"The owner of the Tokens"},returns:{_0:"True if the operator is approved, false if not"},notice:"Queries the approval status of an operator for a given owner."},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"pure",type:"function",notice:"A descriptive name for a collection of NFTs in this contract"},"ownerOf(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"ownerOf",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"NFTs assigned to zero address or FT token are considered invalid,  and queries about them do throw.",params:{_tokenId:"The identifier for an NFT"},returns:{_0:"The address of the owner of the NFT"},notice:"Find the owner of an NFT"},"recordingBalanceOf(address,uint256)":{inputs:[{internalType:"address",name:"_owner",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"recordingBalanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_owner:"An address for whom to query the balance",_tokenId:"The token ID to be queried"},notice:"Count all recording token assigned to an address"},"recordingOperatorOf(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"recordingOperatorOf",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",params:{_tokenId:"Token ID to be queried"},returns:{_0:"The recording operator address"},notice:"Returns the recording operator of a token"},"recordingTransferFrom(address,address,uint256,uint256)":{inputs:[{internalType:"address",name:"_from",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"},{internalType:"uint256",name:"_value",type:"uint256"}],name:"recordingTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"If `_to` is zeroaddress or `msg.sender` is not recording operator,  it throwsa.",params:{_from:"Current owner of recording token",_to:"New owner",_tokenId:"The token to transfer",_value:"The amount to transfer"},notice:"Transfer recording token"},"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)":{inputs:[{internalType:"address",name:"_from",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256[]",name:"_tokenIds",type:"uint256[]"},{internalType:"uint256[]",name:"_values",type:"uint256[]"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"safeBatchTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:'Caller must be approved to manage the tokens being transferred out of the `_from` account (see "Approval" section of the standard). MUST revert if `_to` is the zero address. MUST revert if length of `_tokenIds` is not the same as length of `_values`. MUST revert if any of the balance(s) of the holder(s) for token(s) in `_tokenIds` is lower than the respective amount(s) in `_values` sent to the recipient. MUST revert on any other error. MUST emit `TransferSingle` or `TransferBatch` event(s) such that all the balance changes are reflected (see "Safe Transfer Rules" section of the standard). Balance changes and events MUST follow the ordering of the arrays (_tokenIds[0]/_values[0] before _tokenIds[1]/_values[1], etc). After the above conditions for the transfer(s) in the batch are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call the relevant `ERC1155TokenReceiver` hook(s) on `_to` and act appropriately (see "Safe Transfer Rules" section of the standard).',params:{_data:"Additional data with no specified format, MUST be sent unaltered in call to the `ERC1155TokenReceiver` hook(s) on `_to`",_from:"Source address",_to:"Target address",_tokenIds:"IDs of each token type (order and length must match _values array)",_values:"Transfer amounts per token type (order and length must match _tokenIds array)"},notice:"Transfers `_values` amount(s) of `_tokenIds` from the `_from` address to the `_to` address specified (with safety call)."},"safeTransferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"_from",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:'This works identically to the other function with an extra data parameter,  except this function just sets data to "".',params:{_from:"The current owner of the NFT",_to:"The new owner",_tokenId:"The NFT to transfer"},notice:"Transfers the ownership of an NFT from one address to another address"},"safeTransferFrom(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"_from",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:'Throws unless `msg.sender` is the current owner, an authorized  operator, or the approved address for this NFT. Throws if `_from` is  not the current owner. Throws if `_to` is the zero address. Throws if  `_tokenId` is not a valid NFT. When transfer is complete, this function  checks if `_to` is a smart contract (code size > 0). If so, it calls  `onERC721Received` on `_to` and throws if the return value is not  `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`.',params:{_data:"Additional data with no specified format, sent in call to `_to`",_from:"The current owner of the NFT",_to:"The new owner",_tokenId:"The NFT to transfer"},notice:"Transfers the ownership of an NFT from one address to another address"},"safeTransferFrom(address,address,uint256,uint256,bytes)":{inputs:[{internalType:"address",name:"_from",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"},{internalType:"uint256",name:"_value",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:'Caller must be approved to manage the tokens being transferred out of the `_from` account (see "Approval" section of the standard). MUST revert if `_to` is the zero address. MUST revert if balance of holder for token `_tokenId` is lower than the `_value` sent. MUST revert on any other error. MUST emit the `TransferSingle` event to reflect the balance change (see "Safe Transfer Rules" section of the standard). After the above conditions are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call `onERC1155Received` on `_to` and act appropriately (see "Safe Transfer Rules" section of the standard).',params:{_data:"Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `_to`",_from:"Source address",_to:"Target address",_tokenId:"ID of the token type",_value:"Transfer amount"},notice:"Transfers `_value` amount of an `_tokenId` from the `_from` address to the `_to` address specified (with safety call)."},"setApprovalForAll(address,bool)":{inputs:[{internalType:"address",name:"_operator",type:"address"},{internalType:"bool",name:"_approved",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"MUST emit the ApprovalForAll event on success.",params:{_approved:"True if the operator is approved, false to revoke approval",_operator:"Address to add to the set of authorized operators"},notice:'Enable or disable approval for a third party ("operator") to manage all of the caller\'s tokens.'},"settingOperatorOf(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"settingOperatorOf",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",params:{_tokenId:"Token ID to be queried"},returns:{_0:"The setting operator address"},notice:"Returns the setting operator of a token"},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"_interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"pure",type:"function",details:"Interface identification is specified in ERC-165. This function  uses less than 30,000 gas.",params:{_interfaceId:"The interface identifier, as specified in ERC-165"},returns:{_0:"`true` if the contract implements `_interfaceId`,  `false` otherwise"},notice:"Query if a contract implements an interface"},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"pure",type:"function",notice:"An abbreviated name for NFTs in this contract"},"timeIntervalOf(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"timeIntervalOf",outputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_tokenId:"Token ID to be queried"},returns:{_0:"The starting time in unix time",_1:"The ending time in unix time"},notice:"Returns the starting time and ending time of token holding time calculation"},"tokenURI(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"tokenURI",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:'Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC  3986. The URI may point to a JSON file that conforms to the "ERC721  Metadata JSON Schema".',notice:"A distinct Uniform Resource Identifier (URI) for a given asset."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"_from",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"transferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Throws unless `msg.sender` is the current owner, an authorized  operator, or the approved address for this NFT. Throws if `_from` is  not the current owner. Throws if `_to` is the zero address. Throws if  `_tokenId` is not a valid NFT.",params:{_from:"The current owner of the NFT",_to:"The new owner",_tokenId:"The NFT to transfer"},notice:"Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE  THEY MAY BE PERMANENTLY LOST"},"uri(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"uri",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:'URIs are defined in RFC 3986. The URI MUST point to a JSON file that conforms to the "ERC-1155 Metadata URI JSON Schema".        ',returns:{_0:"URI string"},notice:"A distinct Uniform Resource Identifier (URI) for a given token."}}},"contracts/ERC1155ERC721WithAdapter.sol:ERC1155ERC721WithAdapter":{source:"contracts/ERC1155ERC721WithAdapter.sol",name:"ERC1155ERC721WithAdapter",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_owner",type:"address"},{indexed:!0,internalType:"address",name:"_approved",type:"address"},{indexed:!0,internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"Approval",type:"event"},"ApprovalForAll(address,address,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_owner",type:"address"},{indexed:!0,internalType:"address",name:"_operator",type:"address"},{indexed:!1,internalType:"bool",name:"_approved",type:"bool"}],name:"ApprovalForAll",type:"event"},"NewAdapter(uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"_tokenId",type:"uint256"},{indexed:!0,internalType:"address",name:"_adapter",type:"address"}],name:"NewAdapter",type:"event",details:"MUST emit when a new erc20 adapter is created for `_tokenId`"},"RecordingTransferSingle(address,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"_operator",type:"address"},{indexed:!0,internalType:"address",name:"_from",type:"address"},{indexed:!0,internalType:"address",name:"_to",type:"address"},{indexed:!0,internalType:"uint256",name:"_tokenId",type:"uint256"},{indexed:!1,internalType:"uint256",name:"_value",type:"uint256"}],name:"RecordingTransferSingle",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_from",type:"address"},{indexed:!0,internalType:"address",name:"_to",type:"address"},{indexed:!0,internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"Transfer",type:"event"},"TransferBatch(address,address,address,uint256[],uint256[])":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_operator",type:"address"},{indexed:!0,internalType:"address",name:"_from",type:"address"},{indexed:!0,internalType:"address",name:"_to",type:"address"},{indexed:!1,internalType:"uint256[]",name:"_tokenIds",type:"uint256[]"},{indexed:!1,internalType:"uint256[]",name:"_values",type:"uint256[]"}],name:"TransferBatch",type:"event"},"TransferSingle(address,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_operator",type:"address"},{indexed:!0,internalType:"address",name:"_from",type:"address"},{indexed:!0,internalType:"address",name:"_to",type:"address"},{indexed:!1,internalType:"uint256",name:"_tokenId",type:"uint256"},{indexed:!1,internalType:"uint256",name:"_value",type:"uint256"}],name:"TransferSingle",type:"event"},"URI(string,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"string",name:"_value",type:"string"},{indexed:!0,internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"URI",type:"event"}},methods:{"approve(address,uint256)":{inputs:[{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"approve",outputs:[],stateMutability:"nonpayable",type:"function",details:"The zero address indicates there is no approved address.  Throws unless `msg.sender` is the current NFT owner, or an authorized  operator of the current owner.",params:{_to:"The new approved NFT controller",_tokenId:"The NFT to approve"},notice:"Change or reaffirm the approved address for an NFT"},"balanceOf(address,uint256)":{inputs:[{internalType:"address",name:"_owner",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"It accept both ",params:{_owner:"The address of the token holder",_tokenId:"ID of the Token"},returns:{_0:"The _owner's balance of the Token type requested"},notice:"Get the balance of an account's Tokens."},"balanceOf(address)":{inputs:[{internalType:"address",name:"_owner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_owner:"An address for whom to query the balance"},returns:{_0:"The number of NFTs owned by `_owner`, possibly zero"},notice:"Count all NFTs assigned to an owner"},"balanceOfBatch(address[],uint256[])":{inputs:[{internalType:"address[]",name:"_owners",type:"address[]"},{internalType:"uint256[]",name:"_tokenIds",type:"uint256[]"}],name:"balanceOfBatch",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"view",type:"function",params:{_owners:"The addresses of the token holders",_tokenIds:"ID of the Tokens"},returns:{_0:"The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)"},notice:"Get the balance of multiple account/token pairs"},"getAdapter(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"getAdapter",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns zero address if does not have a adapter",params:{_tokenId:"Token ID to be queried"},returns:{_0:"ERC20 adapter contract address"},notice:"Queries the erc20 adapter contract address for a given token ID"},"getApproved(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"getApproved",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Throws if `_tokenId` is not a valid NFT.",params:{_tokenId:"The NFT to find the approved address for"},returns:{_0:"The approved address for this NFT, or the zero address if there is none"},notice:"Get the approved address for a single NFT"},"isApprovedForAll(address,address)":{inputs:[{internalType:"address",name:"_owner",type:"address"},{internalType:"address",name:"_operator",type:"address"}],name:"isApprovedForAll",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{_operator:"Address of authorized operator",_owner:"The owner of the Tokens"},returns:{_0:"True if the operator is approved, false if not"},notice:"Queries the approval status of an operator for a given owner."},"ownerOf(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"ownerOf",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"NFTs assigned to zero address or FT token are considered invalid,  and queries about them do throw.",params:{_tokenId:"The identifier for an NFT"},returns:{_0:"The address of the owner of the NFT"},notice:"Find the owner of an NFT"},"recordingBalanceOf(address,uint256)":{inputs:[{internalType:"address",name:"_owner",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"recordingBalanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_owner:"An address for whom to query the balance",_tokenId:"The token ID to be queried"},notice:"Count all recording token assigned to an address"},"recordingOperatorOf(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"recordingOperatorOf",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",params:{_tokenId:"Token ID to be queried"},returns:{_0:"The recording operator address"},notice:"Returns the recording operator of a token"},"recordingTransferFrom(address,address,uint256,uint256)":{inputs:[{internalType:"address",name:"_from",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"},{internalType:"uint256",name:"_value",type:"uint256"}],name:"recordingTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"If `_to` is zeroaddress or `msg.sender` is not recording operator,  it throwsa.",params:{_from:"Current owner of recording token",_to:"New owner",_tokenId:"The token to transfer",_value:"The amount to transfer"},notice:"Transfer recording token"},"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)":{inputs:[{internalType:"address",name:"_from",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256[]",name:"_tokenIds",type:"uint256[]"},{internalType:"uint256[]",name:"_values",type:"uint256[]"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"safeBatchTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:'Caller must be approved to manage the tokens being transferred out of the `_from` account (see "Approval" section of the standard). MUST revert if `_to` is the zero address. MUST revert if length of `_tokenIds` is not the same as length of `_values`. MUST revert if any of the balance(s) of the holder(s) for token(s) in `_tokenIds` is lower than the respective amount(s) in `_values` sent to the recipient. MUST revert on any other error. MUST emit `TransferSingle` or `TransferBatch` event(s) such that all the balance changes are reflected (see "Safe Transfer Rules" section of the standard). Balance changes and events MUST follow the ordering of the arrays (_tokenIds[0]/_values[0] before _tokenIds[1]/_values[1], etc). After the above conditions for the transfer(s) in the batch are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call the relevant `ERC1155TokenReceiver` hook(s) on `_to` and act appropriately (see "Safe Transfer Rules" section of the standard).',params:{_data:"Additional data with no specified format, MUST be sent unaltered in call to the `ERC1155TokenReceiver` hook(s) on `_to`",_from:"Source address",_to:"Target address",_tokenIds:"IDs of each token type (order and length must match _values array)",_values:"Transfer amounts per token type (order and length must match _tokenIds array)"},notice:"Transfers `_values` amount(s) of `_tokenIds` from the `_from` address to the `_to` address specified (with safety call)."},"safeTransferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"_from",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:'This works identically to the other function with an extra data parameter,  except this function just sets data to "".',params:{_from:"The current owner of the NFT",_to:"The new owner",_tokenId:"The NFT to transfer"},notice:"Transfers the ownership of an NFT from one address to another address"},"safeTransferFrom(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"_from",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:'Throws unless `msg.sender` is the current owner, an authorized  operator, or the approved address for this NFT. Throws if `_from` is  not the current owner. Throws if `_to` is the zero address. Throws if  `_tokenId` is not a valid NFT. When transfer is complete, this function  checks if `_to` is a smart contract (code size > 0). If so, it calls  `onERC721Received` on `_to` and throws if the return value is not  `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`.',params:{_data:"Additional data with no specified format, sent in call to `_to`",_from:"The current owner of the NFT",_to:"The new owner",_tokenId:"The NFT to transfer"},notice:"Transfers the ownership of an NFT from one address to another address"},"safeTransferFrom(address,address,uint256,uint256,bytes)":{inputs:[{internalType:"address",name:"_from",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"},{internalType:"uint256",name:"_value",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:'Caller must be approved to manage the tokens being transferred out of the `_from` account (see "Approval" section of the standard). MUST revert if `_to` is the zero address. MUST revert if balance of holder for token `_tokenId` is lower than the `_value` sent. MUST revert on any other error. MUST emit the `TransferSingle` event to reflect the balance change (see "Safe Transfer Rules" section of the standard). After the above conditions are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call `onERC1155Received` on `_to` and act appropriately (see "Safe Transfer Rules" section of the standard).',params:{_data:"Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `_to`",_from:"Source address",_to:"Target address",_tokenId:"ID of the token type",_value:"Transfer amount"},notice:"Transfers `_value` amount of an `_tokenId` from the `_from` address to the `_to` address specified (with safety call)."},"setApprovalForAll(address,bool)":{inputs:[{internalType:"address",name:"_operator",type:"address"},{internalType:"bool",name:"_approved",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"MUST emit the ApprovalForAll event on success.",params:{_approved:"True if the operator is approved, false to revoke approval",_operator:"Address to add to the set of authorized operators"},notice:'Enable or disable approval for a third party ("operator") to manage all of the caller\'s tokens.'},"settingOperatorOf(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"settingOperatorOf",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",params:{_tokenId:"Token ID to be queried"},returns:{_0:"The setting operator address"},notice:"Returns the setting operator of a token"},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"_interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"pure",type:"function",details:"Interface identification is specified in ERC-165. This function  uses less than 30,000 gas.",params:{_interfaceId:"The interface identifier, as specified in ERC-165"},returns:{_0:"`true` if the contract implements `_interfaceId`,  `false` otherwise"},notice:"Query if a contract implements an interface"},"template()":{inputs:[],name:"template",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"timeIntervalOf(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"timeIntervalOf",outputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_tokenId:"Token ID to be queried"},returns:{_0:"The starting time in unix time",_1:"The ending time in unix time"},notice:"Returns the starting time and ending time of token holding time calculation"},"totalSupply(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_tokenId:"Token ID to be queried"},returns:{_0:"Total supply of a token"},notice:"Returns total supply of a token"},"transferByAdapter(address,address,uint256,uint256)":{inputs:[{internalType:"address",name:"_from",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"},{internalType:"uint256",name:"_value",type:"uint256"}],name:"transferByAdapter",outputs:[],stateMutability:"nonpayable",type:"function",details:"This function should only be called from erc20 adapter",params:{_from:"Source address",_to:"Target address",_tokenId:"ID of the token type",_value:"Transfer amount"},notice:"Transfers `_value` amount of `_tokenId` from `_from` to `_to`"},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"_from",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"transferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Throws unless `msg.sender` is the current owner, an authorized  operator, or the approved address for this NFT. Throws if `_from` is  not the current owner. Throws if `_to` is the zero address. Throws if  `_tokenId` is not a valid NFT.",params:{_from:"The current owner of the NFT",_to:"The new owner",_tokenId:"The NFT to transfer"},notice:"Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE  THEY MAY BE PERMANENTLY LOST"}}},"contracts/ERC1155ERC721WithAdapter.sol:ERC20Adapter":{source:"contracts/ERC1155ERC721WithAdapter.sol",name:"ERC20Adapter",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_owner",type:"address"},{indexed:!0,internalType:"address",name:"_spender",type:"address"},{indexed:!1,internalType:"uint256",name:"_value",type:"uint256"}],name:"Approval",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_from",type:"address"},{indexed:!0,internalType:"address",name:"_to",type:"address"},{indexed:!1,internalType:"uint256",name:"_value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"allowance(address,address)":{inputs:[{internalType:"address",name:"_owner",type:"address"},{internalType:"address",name:"_spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"approve(address,uint256)":{inputs:[{internalType:"address",name:"_spender",type:"address"},{internalType:"uint256",name:"_value",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"balanceOf(address)":{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"emitTransfer(address,address,uint256)":{inputs:[{internalType:"address",name:"_from",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_value",type:"uint256"}],name:"emitTransfer",outputs:[],stateMutability:"nonpayable",type:"function"},"entity()":{inputs:[],name:"entity",outputs:[{internalType:"contract ERC1155ERC721WithAdapter",name:"",type:"address"}],stateMutability:"view",type:"function"},"initialize(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"setAttribute(string,string,uint8)":{inputs:[{internalType:"string",name:"_name",type:"string"},{internalType:"string",name:"_symbol",type:"string"},{internalType:"uint8",name:"_decimals",type:"uint8"}],name:"setAttribute",outputs:[],stateMutability:"nonpayable",type:"function"},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"tokenId()":{inputs:[],name:"tokenId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens in existence."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_value",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"_from",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_value",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"}}},"contracts/GSN/BasePaymaster.sol:BasePaymaster":{source:"contracts/GSN/BasePaymaster.sol",name:"BasePaymaster",notice:"Abstract base class to be inherited by a concrete Paymaster A subclass must implement:  - preRelayedCall  - postRelayedCall",receive:{stateMutability:"payable",type:"receive"},events:{"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"}},methods:{"FORWARDER_HUB_OVERHEAD()":{inputs:[],name:"FORWARDER_HUB_OVERHEAD",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"PAYMASTER_ACCEPTANCE_BUDGET()":{inputs:[],name:"PAYMASTER_ACCEPTANCE_BUDGET",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"POST_RELAYED_CALL_GAS_LIMIT()":{inputs:[],name:"POST_RELAYED_CALL_GAS_LIMIT",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"PRE_RELAYED_CALL_GAS_LIMIT()":{inputs:[],name:"PRE_RELAYED_CALL_GAS_LIMIT",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"_verifyForwarder(((address,address,uint256,uint256,uint256,bytes),(uint256,uint256,uint256,address,address,bytes,uint256,address)))":{inputs:[{components:[{components:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"gas",type:"uint256"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],internalType:"struct IForwarder.ForwardRequest",name:"request",type:"tuple"},{components:[{internalType:"uint256",name:"gasPrice",type:"uint256"},{internalType:"uint256",name:"pctRelayFee",type:"uint256"},{internalType:"uint256",name:"baseRelayFee",type:"uint256"},{internalType:"address",name:"relayWorker",type:"address"},{internalType:"address",name:"paymaster",type:"address"},{internalType:"bytes",name:"paymasterData",type:"bytes"},{internalType:"uint256",name:"clientId",type:"uint256"},{internalType:"address",name:"forwarder",type:"address"}],internalType:"struct GsnTypes.RelayData",name:"relayData",type:"tuple"}],internalType:"struct GsnTypes.RelayRequest",name:"relayRequest",type:"tuple"}],name:"_verifyForwarder",outputs:[],stateMutability:"view",type:"function"},"_verifySignature(((address,address,uint256,uint256,uint256,bytes),(uint256,uint256,uint256,address,address,bytes,uint256,address)),bytes)":{inputs:[{components:[{components:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"gas",type:"uint256"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],internalType:"struct IForwarder.ForwardRequest",name:"request",type:"tuple"},{components:[{internalType:"uint256",name:"gasPrice",type:"uint256"},{internalType:"uint256",name:"pctRelayFee",type:"uint256"},{internalType:"uint256",name:"baseRelayFee",type:"uint256"},{internalType:"address",name:"relayWorker",type:"address"},{internalType:"address",name:"paymaster",type:"address"},{internalType:"bytes",name:"paymasterData",type:"bytes"},{internalType:"uint256",name:"clientId",type:"uint256"},{internalType:"address",name:"forwarder",type:"address"}],internalType:"struct GsnTypes.RelayData",name:"relayData",type:"tuple"}],internalType:"struct GsnTypes.RelayRequest",name:"relayRequest",type:"tuple"},{internalType:"bytes",name:"signature",type:"bytes"}],name:"_verifySignature",outputs:[],stateMutability:"view",type:"function"},"acceptOwnership()":{inputs:[],name:"acceptOwnership",outputs:[],stateMutability:"nonpayable",type:"function"},"getGasLimits()":{inputs:[],name:"getGasLimits",outputs:[{components:[{internalType:"uint256",name:"acceptanceBudget",type:"uint256"},{internalType:"uint256",name:"preRelayedCallGasLimit",type:"uint256"},{internalType:"uint256",name:"postRelayedCallGasLimit",type:"uint256"}],internalType:"struct IPaymaster.GasLimits",name:"limits",type:"tuple"}],stateMutability:"view",type:"function",notice:"Return the GasLimits constants used by the Paymaster."},"getHubAddr()":{inputs:[],name:"getHubAddr",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"return the relayHub of this contract."},"getRelayHubDeposit()":{inputs:[],name:"getRelayHubDeposit",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"check current deposit on relay hub."},"newOwner()":{inputs:[],name:"newOwner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"postRelayedCall(bytes,bool,uint256,(uint256,uint256,uint256,address,address,bytes,uint256,address))":{inputs:[{internalType:"bytes",name:"context",type:"bytes"},{internalType:"bool",name:"success",type:"bool"},{internalType:"uint256",name:"gasUseWithoutPost",type:"uint256"},{components:[{internalType:"uint256",name:"gasPrice",type:"uint256"},{internalType:"uint256",name:"pctRelayFee",type:"uint256"},{internalType:"uint256",name:"baseRelayFee",type:"uint256"},{internalType:"address",name:"relayWorker",type:"address"},{internalType:"address",name:"paymaster",type:"address"},{internalType:"bytes",name:"paymasterData",type:"bytes"},{internalType:"uint256",name:"clientId",type:"uint256"},{internalType:"address",name:"forwarder",type:"address"}],internalType:"struct GsnTypes.RelayData",name:"relayData",type:"tuple"}],name:"postRelayedCall",outputs:[],stateMutability:"nonpayable",type:"function",params:{context:"- the call context, as returned by the preRelayedCall",gasUseWithoutPost:"- the actual amount of gas used by the entire transaction, EXCEPT        the gas used by the postRelayedCall itself.",relayData:"- the relay params of the request. can be used by relayHub.calculateCharge() Revert in this functions causes a revert of the client's relayed call (and preRelayedCall(), but the Paymaster is still committed to pay the relay for the entire transaction.",success:"- true if the relayed call succeeded, false if it reverted"},notice:"This method is called after the actual relayed function call. It may be used to record the transaction (e.g. charge the caller by some contract logic) for this call. MUST be protected with relayHubOnly() in case it modifies state."},"preRelayedCall(((address,address,uint256,uint256,uint256,bytes),(uint256,uint256,uint256,address,address,bytes,uint256,address)),bytes,bytes,uint256)":{inputs:[{components:[{components:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"gas",type:"uint256"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],internalType:"struct IForwarder.ForwardRequest",name:"request",type:"tuple"},{components:[{internalType:"uint256",name:"gasPrice",type:"uint256"},{internalType:"uint256",name:"pctRelayFee",type:"uint256"},{internalType:"uint256",name:"baseRelayFee",type:"uint256"},{internalType:"address",name:"relayWorker",type:"address"},{internalType:"address",name:"paymaster",type:"address"},{internalType:"bytes",name:"paymasterData",type:"bytes"},{internalType:"uint256",name:"clientId",type:"uint256"},{internalType:"address",name:"forwarder",type:"address"}],internalType:"struct GsnTypes.RelayData",name:"relayData",type:"tuple"}],internalType:"struct GsnTypes.RelayRequest",name:"relayRequest",type:"tuple"},{internalType:"bytes",name:"signature",type:"bytes"},{internalType:"bytes",name:"approvalData",type:"bytes"},{internalType:"uint256",name:"maxPossibleGas",type:"uint256"}],name:"preRelayedCall",outputs:[{internalType:"bytes",name:"context",type:"bytes"},{internalType:"bool",name:"rejectOnRecipientRevert",type:"bool"}],stateMutability:"nonpayable",type:"function",params:{approvalData:"- extra dapp-specific data (e.g. signature from trusted party)",maxPossibleGas:'- based on values returned from {@link getGasLimits},         the RelayHub will calculate the maximum possible amount of gas the user may be charged for.         In order to convert this value to wei, the Paymaster has to call "relayHub.calculateCharge()"  return:      a context to be passed to postRelayedCall      rejectOnRecipientRevert - TRUE if paymaster want to reject the TX if the recipient reverts.          FALSE means that rejects by the recipient will be completed on chain, and paid by the paymaster.          (note that in the latter case, the preRelayedCall and postRelayedCall are not reverted).',relayRequest:"- the full relay request structure",signature:"- user's EIP712-compatible signature of the {@link relayRequest}.              Note that in most cases the paymaster shouldn't try use it at all. It is always checked              by the forwarder immediately after preRelayedCall returns."},notice:'Called by Relay (and RelayHub), to validate if the paymaster agrees to pay for this call. MUST be protected with relayHubOnly() in case it modifies state. The Paymaster rejects by the following "revert" operations  - preRelayedCall() method reverts  - the forwarder reverts because of nonce or signature error  - the paymaster returned "rejectOnRecipientRevert", and the recipient contract reverted. In any of the above cases, all paymaster calls (and recipient call) are reverted. In any other case, the paymaster agrees to pay for the gas cost of the transaction (note  that this includes also postRelayedCall revert) The rejectOnRecipientRevert flag means the Paymaster "delegate" the rejection to the recipient  code.  It also means the Paymaster trust the recipient to reject fast: both preRelayedCall,  forwarder check and receipient checks must fit into the GasLimits.acceptanceBudget,  otherwise the TX is paid by the Paymaster.'},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"setRelayHub(address)":{inputs:[{internalType:"contract IRelayHub",name:"hub",type:"address"}],name:"setRelayHub",outputs:[],stateMutability:"nonpayable",type:"function"},"setTrustedForwarder(address)":{inputs:[{internalType:"contract IForwarder",name:"forwarder",type:"address"}],name:"setTrustedForwarder",outputs:[],stateMutability:"nonpayable",type:"function"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"_newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"trustedForwarder()":{inputs:[],name:"trustedForwarder",outputs:[{internalType:"contract IForwarder",name:"",type:"address"}],stateMutability:"view",type:"function"},"versionPaymaster()":{inputs:[],name:"versionPaymaster",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"withdrawRelayHubDepositTo(uint256,address)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"address payable",name:"target",type:"address"}],name:"withdrawRelayHubDepositTo",outputs:[],stateMutability:"nonpayable",type:"function",notice:"withdraw deposit from relayHub"}}},"contracts/GSN/BaseRelayRecipient.sol:BaseRelayRecipient":{source:"contracts/GSN/BaseRelayRecipient.sol",name:"BaseRelayRecipient",notice:'A base contract to be inherited by any contract that want to receive relayed transactions A subclass must use "_msgSender()" instead of "msg.sender"',methods:{"isTrustedForwarder(address)":{inputs:[{internalType:"address",name:"forwarder",type:"address"}],name:"isTrustedForwarder",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"return if the forwarder is trusted to forward relayed transactions to us. the forwarder is required to verify the sender's signature, and verify the call is not a replay."},"trustedForwarder()":{inputs:[],name:"trustedForwarder",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"versionRecipient()":{inputs:[],name:"versionRecipient",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"}}},"contracts/GSN/forwarder/Forwarder.sol:Forwarder":{source:"contracts/GSN/forwarder/Forwarder.sol",name:"Forwarder",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},receive:{stateMutability:"payable",type:"receive"},events:{"DomainRegistered(bytes32,bytes)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"domainSeparator",type:"bytes32"},{indexed:!1,internalType:"bytes",name:"domainValue",type:"bytes"}],name:"DomainRegistered",type:"event"},"RequestTypeRegistered(bytes32,string)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"typeHash",type:"bytes32"},{indexed:!1,internalType:"string",name:"typeStr",type:"string"}],name:"RequestTypeRegistered",type:"event"}},methods:{"EIP712_DOMAIN_TYPE()":{inputs:[],name:"EIP712_DOMAIN_TYPE",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"GENERIC_PARAMS()":{inputs:[],name:"GENERIC_PARAMS",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"_getEncoded((address,address,uint256,uint256,uint256,bytes),bytes32,bytes)":{inputs:[{components:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"gas",type:"uint256"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],internalType:"struct IForwarder.ForwardRequest",name:"req",type:"tuple"},{internalType:"bytes32",name:"requestTypeHash",type:"bytes32"},{internalType:"bytes",name:"suffixData",type:"bytes"}],name:"_getEncoded",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"pure",type:"function"},"domains(bytes32)":{inputs:[{internalType:"bytes32",name:"",type:"bytes32"}],name:"domains",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"execute((address,address,uint256,uint256,uint256,bytes),bytes32,bytes32,bytes,bytes)":{inputs:[{components:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"gas",type:"uint256"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],internalType:"struct IForwarder.ForwardRequest",name:"req",type:"tuple"},{internalType:"bytes32",name:"domainSeparator",type:"bytes32"},{internalType:"bytes32",name:"requestTypeHash",type:"bytes32"},{internalType:"bytes",name:"suffixData",type:"bytes"},{internalType:"bytes",name:"sig",type:"bytes"}],name:"execute",outputs:[{internalType:"bool",name:"success",type:"bool"},{internalType:"bytes",name:"ret",type:"bytes"}],stateMutability:"payable",type:"function"},"getNonce(address)":{inputs:[{internalType:"address",name:"from",type:"address"}],name:"getNonce",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"registerDomainSeparator(string,string)":{inputs:[{internalType:"string",name:"name",type:"string"},{internalType:"string",name:"version",type:"string"}],name:"registerDomainSeparator",outputs:[],stateMutability:"nonpayable",type:"function",params:{name:"the domain's display name",version:"the domain/protocol version"},notice:"Register a new domain separator. The domain separator must have the following fields: name,version,chainId, verifyingContract. the chainId is the current network's chainId, and the verifyingContract is this forwarder. This method is given the domain name and version to create and register the domain separator value."},"registerRequestType(string,string)":{inputs:[{internalType:"string",name:"typeName",type:"string"},{internalType:"string",name:"typeSuffix",type:"string"}],name:"registerRequestType",outputs:[],stateMutability:"nonpayable",type:"function",params:{typeName:"- the name of the request type.",typeSuffix:"- anything after the generic params can be empty string (if no extra fields are needed)        if it does contain a value, then a comma is added first."},notice:"Register a new Request typehash."},"typeHashes(bytes32)":{inputs:[{internalType:"bytes32",name:"",type:"bytes32"}],name:"typeHashes",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"verify((address,address,uint256,uint256,uint256,bytes),bytes32,bytes32,bytes,bytes)":{inputs:[{components:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"gas",type:"uint256"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],internalType:"struct IForwarder.ForwardRequest",name:"req",type:"tuple"},{internalType:"bytes32",name:"domainSeparator",type:"bytes32"},{internalType:"bytes32",name:"requestTypeHash",type:"bytes32"},{internalType:"bytes",name:"suffixData",type:"bytes"},{internalType:"bytes",name:"sig",type:"bytes"}],name:"verify",outputs:[],stateMutability:"view",type:"function"}}},"contracts/GSN/forwarder/IForwarder.sol:IForwarder":{source:"contracts/GSN/forwarder/IForwarder.sol",name:"IForwarder",methods:{"execute((address,address,uint256,uint256,uint256,bytes),bytes32,bytes32,bytes,bytes)":{inputs:[{components:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"gas",type:"uint256"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],internalType:"struct IForwarder.ForwardRequest",name:"forwardRequest",type:"tuple"},{internalType:"bytes32",name:"domainSeparator",type:"bytes32"},{internalType:"bytes32",name:"requestTypeHash",type:"bytes32"},{internalType:"bytes",name:"suffixData",type:"bytes"},{internalType:"bytes",name:"signature",type:"bytes"}],name:"execute",outputs:[{internalType:"bool",name:"success",type:"bool"},{internalType:"bytes",name:"ret",type:"bytes"}],stateMutability:"payable",type:"function",params:{domainSeparator:"- domain used when signing this request",forwardRequest:"- all transaction parameters",requestTypeHash:"- request type used when signing this request.",signature:'- signature to validate. the transaction is verified, and then executed. the success and ret of "call" are returned. This method would revert only verification errors. target errors are reported using the returned "success" and ret string',suffixData:"- the extension data used when signing this request."},notice:"execute a transaction"},"getNonce(address)":{inputs:[{internalType:"address",name:"from",type:"address"}],name:"getNonce",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"registerDomainSeparator(string,string)":{inputs:[{internalType:"string",name:"name",type:"string"},{internalType:"string",name:"version",type:"string"}],name:"registerDomainSeparator",outputs:[],stateMutability:"nonpayable",type:"function",params:{name:"the domain's display name",version:"the domain/protocol version"},notice:"Register a new domain separator. The domain separator must have the following fields: name,version,chainId, verifyingContract. the chainId is the current network's chainId, and the verifyingContract is this forwarder. This method is given the domain name and version to create and register the domain separator value."},"registerRequestType(string,string)":{inputs:[{internalType:"string",name:"typeName",type:"string"},{internalType:"string",name:"typeSuffix",type:"string"}],name:"registerRequestType",outputs:[],stateMutability:"nonpayable",type:"function",params:{typeName:"- the name of the request type.",typeSuffix:"- anything after the generic params can be empty string (if no extra fields are needed)        if it does contain a value, then a comma is added first."},notice:"Register a new Request typehash."},"verify((address,address,uint256,uint256,uint256,bytes),bytes32,bytes32,bytes,bytes)":{inputs:[{components:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"gas",type:"uint256"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],internalType:"struct IForwarder.ForwardRequest",name:"forwardRequest",type:"tuple"},{internalType:"bytes32",name:"domainSeparator",type:"bytes32"},{internalType:"bytes32",name:"requestTypeHash",type:"bytes32"},{internalType:"bytes",name:"suffixData",type:"bytes"},{internalType:"bytes",name:"signature",type:"bytes"}],name:"verify",outputs:[],stateMutability:"view",type:"function",notice:"verify the transaction would execute. validate the signature and the nonce of the request. revert if either signature or nonce are incorrect."}}},"contracts/GSN/interfaces/GsnTypes.sol:GsnTypes":{source:"contracts/GSN/interfaces/GsnTypes.sol",name:"GsnTypes"},"contracts/GSN/interfaces/IPaymaster.sol:IPaymaster":{source:"contracts/GSN/interfaces/IPaymaster.sol",name:"IPaymaster",methods:{"getGasLimits()":{inputs:[],name:"getGasLimits",outputs:[{components:[{internalType:"uint256",name:"acceptanceBudget",type:"uint256"},{internalType:"uint256",name:"preRelayedCallGasLimit",type:"uint256"},{internalType:"uint256",name:"postRelayedCallGasLimit",type:"uint256"}],internalType:"struct IPaymaster.GasLimits",name:"limits",type:"tuple"}],stateMutability:"view",type:"function",notice:"Return the GasLimits constants used by the Paymaster."},"getHubAddr()":{inputs:[],name:"getHubAddr",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"return the relayHub of this contract."},"getRelayHubDeposit()":{inputs:[],name:"getRelayHubDeposit",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"the paymaster's deposit in the RelayHub."},notice:"Can be used to determine if the contract can pay for incoming calls before making any."},"postRelayedCall(bytes,bool,uint256,(uint256,uint256,uint256,address,address,bytes,uint256,address))":{inputs:[{internalType:"bytes",name:"context",type:"bytes"},{internalType:"bool",name:"success",type:"bool"},{internalType:"uint256",name:"gasUseWithoutPost",type:"uint256"},{components:[{internalType:"uint256",name:"gasPrice",type:"uint256"},{internalType:"uint256",name:"pctRelayFee",type:"uint256"},{internalType:"uint256",name:"baseRelayFee",type:"uint256"},{internalType:"address",name:"relayWorker",type:"address"},{internalType:"address",name:"paymaster",type:"address"},{internalType:"bytes",name:"paymasterData",type:"bytes"},{internalType:"uint256",name:"clientId",type:"uint256"},{internalType:"address",name:"forwarder",type:"address"}],internalType:"struct GsnTypes.RelayData",name:"relayData",type:"tuple"}],name:"postRelayedCall",outputs:[],stateMutability:"nonpayable",type:"function",params:{context:"- the call context, as returned by the preRelayedCall",gasUseWithoutPost:"- the actual amount of gas used by the entire transaction, EXCEPT        the gas used by the postRelayedCall itself.",relayData:"- the relay params of the request. can be used by relayHub.calculateCharge() Revert in this functions causes a revert of the client's relayed call (and preRelayedCall(), but the Paymaster is still committed to pay the relay for the entire transaction.",success:"- true if the relayed call succeeded, false if it reverted"},notice:"This method is called after the actual relayed function call. It may be used to record the transaction (e.g. charge the caller by some contract logic) for this call. MUST be protected with relayHubOnly() in case it modifies state."},"preRelayedCall(((address,address,uint256,uint256,uint256,bytes),(uint256,uint256,uint256,address,address,bytes,uint256,address)),bytes,bytes,uint256)":{inputs:[{components:[{components:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"gas",type:"uint256"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],internalType:"struct IForwarder.ForwardRequest",name:"request",type:"tuple"},{components:[{internalType:"uint256",name:"gasPrice",type:"uint256"},{internalType:"uint256",name:"pctRelayFee",type:"uint256"},{internalType:"uint256",name:"baseRelayFee",type:"uint256"},{internalType:"address",name:"relayWorker",type:"address"},{internalType:"address",name:"paymaster",type:"address"},{internalType:"bytes",name:"paymasterData",type:"bytes"},{internalType:"uint256",name:"clientId",type:"uint256"},{internalType:"address",name:"forwarder",type:"address"}],internalType:"struct GsnTypes.RelayData",name:"relayData",type:"tuple"}],internalType:"struct GsnTypes.RelayRequest",name:"relayRequest",type:"tuple"},{internalType:"bytes",name:"signature",type:"bytes"},{internalType:"bytes",name:"approvalData",type:"bytes"},{internalType:"uint256",name:"maxPossibleGas",type:"uint256"}],name:"preRelayedCall",outputs:[{internalType:"bytes",name:"context",type:"bytes"},{internalType:"bool",name:"rejectOnRecipientRevert",type:"bool"}],stateMutability:"nonpayable",type:"function",params:{approvalData:"- extra dapp-specific data (e.g. signature from trusted party)",maxPossibleGas:'- based on values returned from {@link getGasLimits},         the RelayHub will calculate the maximum possible amount of gas the user may be charged for.         In order to convert this value to wei, the Paymaster has to call "relayHub.calculateCharge()"  return:      a context to be passed to postRelayedCall      rejectOnRecipientRevert - TRUE if paymaster want to reject the TX if the recipient reverts.          FALSE means that rejects by the recipient will be completed on chain, and paid by the paymaster.          (note that in the latter case, the preRelayedCall and postRelayedCall are not reverted).',relayRequest:"- the full relay request structure",signature:"- user's EIP712-compatible signature of the {@link relayRequest}.              Note that in most cases the paymaster shouldn't try use it at all. It is always checked              by the forwarder immediately after preRelayedCall returns."},notice:'Called by Relay (and RelayHub), to validate if the paymaster agrees to pay for this call. MUST be protected with relayHubOnly() in case it modifies state. The Paymaster rejects by the following "revert" operations  - preRelayedCall() method reverts  - the forwarder reverts because of nonce or signature error  - the paymaster returned "rejectOnRecipientRevert", and the recipient contract reverted. In any of the above cases, all paymaster calls (and recipient call) are reverted. In any other case, the paymaster agrees to pay for the gas cost of the transaction (note  that this includes also postRelayedCall revert) The rejectOnRecipientRevert flag means the Paymaster "delegate" the rejection to the recipient  code.  It also means the Paymaster trust the recipient to reject fast: both preRelayedCall,  forwarder check and receipient checks must fit into the GasLimits.acceptanceBudget,  otherwise the TX is paid by the Paymaster.'},"trustedForwarder()":{inputs:[],name:"trustedForwarder",outputs:[{internalType:"contract IForwarder",name:"",type:"address"}],stateMutability:"view",type:"function"},"versionPaymaster()":{inputs:[],name:"versionPaymaster",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"}}},"contracts/GSN/interfaces/IRelayHub.sol:IRelayHub":{source:"contracts/GSN/interfaces/IRelayHub.sol",name:"IRelayHub",events:{"Deposited(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"paymaster",type:"address"},{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Deposited",type:"event"},"RelayServerRegistered(address,uint256,uint256,string)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"relayManager",type:"address"},{indexed:!1,internalType:"uint256",name:"baseRelayFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"pctRelayFee",type:"uint256"},{indexed:!1,internalType:"string",name:"relayUrl",type:"string"}],name:"RelayServerRegistered",type:"event",notice:"Emitted when a relay server registers or updates its details Looking at these events lets a client discover relay servers"},"RelayWorkersAdded(address,address[],uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"relayManager",type:"address"},{indexed:!1,internalType:"address[]",name:"newRelayWorkers",type:"address[]"},{indexed:!1,internalType:"uint256",name:"workersCount",type:"uint256"}],name:"RelayWorkersAdded",type:"event",notice:"Emitted when relays are added by a relayManager"},"TransactionRejectedByPaymaster(address,address,address,address,address,bytes4,uint256,bytes)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"relayManager",type:"address"},{indexed:!0,internalType:"address",name:"paymaster",type:"address"},{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!1,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"address",name:"relayWorker",type:"address"},{indexed:!1,internalType:"bytes4",name:"selector",type:"bytes4"},{indexed:!1,internalType:"uint256",name:"innerGasUsed",type:"uint256"},{indexed:!1,internalType:"bytes",name:"reason",type:"bytes"}],name:"TransactionRejectedByPaymaster",type:"event",params:{reason:"contains a revert reason returned from preRelayedCall or forwarder."},notice:"Emitted when an attempt to relay a call fails and Paymaster does not accept the transaction. The actual relayed call was not executed, and the recipient not charged."},"TransactionRelayed(address,address,address,address,address,bytes4,uint8,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"relayManager",type:"address"},{indexed:!0,internalType:"address",name:"relayWorker",type:"address"},{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!1,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"address",name:"paymaster",type:"address"},{indexed:!1,internalType:"bytes4",name:"selector",type:"bytes4"},{indexed:!1,internalType:"enum IRelayHub.RelayCallStatus",name:"status",type:"uint8"},{indexed:!1,internalType:"uint256",name:"charge",type:"uint256"}],name:"TransactionRelayed",type:"event"},"TransactionResult(uint8,bytes)":{anonymous:!1,inputs:[{indexed:!1,internalType:"enum IRelayHub.RelayCallStatus",name:"status",type:"uint8"},{indexed:!1,internalType:"bytes",name:"returnValue",type:"bytes"}],name:"TransactionResult",type:"event"},"Withdrawn(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"dest",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Withdrawn",type:"event"}},methods:{"addRelayWorkers(address[])":{inputs:[{internalType:"address[]",name:"newRelayWorkers",type:"address[]"}],name:"addRelayWorkers",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Add new worker addresses controlled by sender who must be a staked Relay Manager address. Emits a RelayWorkersAdded event. This function can be called multiple times, emitting new events"},"balanceOf(address)":{inputs:[{internalType:"address",name:"target",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"Returns an account's deposits. It can be either a deposit of a paymaster, or a revenue of a relay manager."},"calculateCharge(uint256,(uint256,uint256,uint256,address,address,bytes,uint256,address))":{inputs:[{internalType:"uint256",name:"gasUsed",type:"uint256"},{components:[{internalType:"uint256",name:"gasPrice",type:"uint256"},{internalType:"uint256",name:"pctRelayFee",type:"uint256"},{internalType:"uint256",name:"baseRelayFee",type:"uint256"},{internalType:"address",name:"relayWorker",type:"address"},{internalType:"address",name:"paymaster",type:"address"},{internalType:"bytes",name:"paymasterData",type:"bytes"},{internalType:"uint256",name:"clientId",type:"uint256"},{internalType:"address",name:"forwarder",type:"address"}],internalType:"struct GsnTypes.RelayData",name:"relayData",type:"tuple"}],name:"calculateCharge",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The fee is expressed as a base fee in wei plus percentage on actual charge. E.g. a value of 40 stands for a 40% fee, so the recipient will be charged for 1.4 times the spent amount."},"depositFor(address)":{inputs:[{internalType:"address",name:"target",type:"address"}],name:"depositFor",outputs:[],stateMutability:"payable",type:"function"},"gasOverhead()":{inputs:[],name:"gasOverhead",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"the total gas overhead of relayCall(), before the first gasleft() and after the last gasleft(). Assume that relay has non-zero balance (costs 15'000 more otherwise)."},"gasReserve()":{inputs:[],name:"gasReserve",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"isRelayManagerStaked(address)":{inputs:[{internalType:"address",name:"relayManager",type:"address"}],name:"isRelayManagerStaked",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"maxWorkerCount()":{inputs:[],name:"maxWorkerCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"maximumRecipientDeposit()":{inputs:[],name:"maximumRecipientDeposit",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"minimumStake()":{inputs:[],name:"minimumStake",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"minimumUnstakeDelay()":{inputs:[],name:"minimumUnstakeDelay",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"penalize(address,address)":{inputs:[{internalType:"address",name:"relayWorker",type:"address"},{internalType:"address payable",name:"beneficiary",type:"address"}],name:"penalize",outputs:[],stateMutability:"nonpayable",type:"function"},"penalizer()":{inputs:[],name:"penalizer",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"postOverhead()":{inputs:[],name:"postOverhead",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"registerRelayServer(uint256,uint256,string)":{inputs:[{internalType:"uint256",name:"baseRelayFee",type:"uint256"},{internalType:"uint256",name:"pctRelayFee",type:"uint256"},{internalType:"string",name:"url",type:"string"}],name:"registerRelayServer",outputs:[],stateMutability:"nonpayable",type:"function"},"relayCall(uint256,((address,address,uint256,uint256,uint256,bytes),(uint256,uint256,uint256,address,address,bytes,uint256,address)),bytes,bytes,uint256)":{inputs:[{internalType:"uint256",name:"paymasterMaxAcceptanceBudget",type:"uint256"},{components:[{components:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"gas",type:"uint256"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],internalType:"struct IForwarder.ForwardRequest",name:"request",type:"tuple"},{components:[{internalType:"uint256",name:"gasPrice",type:"uint256"},{internalType:"uint256",name:"pctRelayFee",type:"uint256"},{internalType:"uint256",name:"baseRelayFee",type:"uint256"},{internalType:"address",name:"relayWorker",type:"address"},{internalType:"address",name:"paymaster",type:"address"},{internalType:"bytes",name:"paymasterData",type:"bytes"},{internalType:"uint256",name:"clientId",type:"uint256"},{internalType:"address",name:"forwarder",type:"address"}],internalType:"struct GsnTypes.RelayData",name:"relayData",type:"tuple"}],internalType:"struct GsnTypes.RelayRequest",name:"relayRequest",type:"tuple"},{internalType:"bytes",name:"signature",type:"bytes"},{internalType:"bytes",name:"approvalData",type:"bytes"},{internalType:"uint256",name:"externalGasLimit",type:"uint256"}],name:"relayCall",outputs:[{internalType:"bool",name:"paymasterAccepted",type:"bool"},{internalType:"bytes",name:"returnValue",type:"bytes"}],stateMutability:"nonpayable",type:"function",params:{approvalData:": dapp-specific data forwarded to preRelayedCall.        This value is *not* verified by the Hub. For example, it can be used to pass a signature to the Paymaster",externalGasLimit:"- the value passed as gasLimit to the transaction. Emits a TransactionRelayed event.",relayRequest:"- all details of the requested relayed call",signature:"- client's EIP-712 signature over the relayRequest struct"},notice:"Relays a transaction. For this to succeed, multiple conditions must be met:  - Paymaster's \"acceptRelayCall\" method must succeed and not revert  - the sender must be a registered Relay Worker that the user signed  - the transaction's gas price must be equal or larger than the one that was signed by the sender  - the transaction must have enough gas to run all internal transactions if they use all gas available to them  - the Paymaster must have enough balance to pay the Relay Worker for the scenario when all gas is spent If all conditions are met, the call will be relayed and the recipient charged. Arguments:"},"stakeManager()":{inputs:[],name:"stakeManager",outputs:[{internalType:"contract IStakeManager",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"Returns the stake manager of this RelayHub."},"versionHub()":{inputs:[],name:"versionHub",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"withdraw(uint256,address)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"address payable",name:"dest",type:"address"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function"},"workerCount(address)":{inputs:[{internalType:"address",name:"manager",type:"address"}],name:"workerCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"workerToManager(address)":{inputs:[{internalType:"address",name:"worker",type:"address"}],name:"workerToManager",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"}}},"contracts/GSN/interfaces/IRelayRecipient.sol:IRelayRecipient":{source:"contracts/GSN/interfaces/IRelayRecipient.sol",name:"IRelayRecipient",notice:"a contract must implement this interface in order to support relayed transaction. It is better to inherit the BaseRelayRecipient as its implementation.",methods:{"isTrustedForwarder(address)":{inputs:[{internalType:"address",name:"forwarder",type:"address"}],name:"isTrustedForwarder",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"return if the forwarder is trusted to forward relayed transactions to us. the forwarder is required to verify the sender's signature, and verify the call is not a replay."},"versionRecipient()":{inputs:[],name:"versionRecipient",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"}}},"contracts/GSN/interfaces/IStakeManager.sol:IStakeManager":{source:"contracts/GSN/interfaces/IStakeManager.sol",name:"IStakeManager",events:{"HubAuthorized(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"relayManager",type:"address"},{indexed:!0,internalType:"address",name:"relayHub",type:"address"}],name:"HubAuthorized",type:"event"},"HubUnauthorized(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"relayManager",type:"address"},{indexed:!0,internalType:"address",name:"relayHub",type:"address"},{indexed:!1,internalType:"uint256",name:"removalBlock",type:"uint256"}],name:"HubUnauthorized",type:"event"},"StakeAdded(address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"relayManager",type:"address"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!1,internalType:"uint256",name:"stake",type:"uint256"},{indexed:!1,internalType:"uint256",name:"unstakeDelay",type:"uint256"}],name:"StakeAdded",type:"event",notice:"Emitted when a stake or unstakeDelay are initialized or increased"},"StakePenalized(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"relayManager",type:"address"},{indexed:!0,internalType:"address",name:"beneficiary",type:"address"},{indexed:!1,internalType:"uint256",name:"reward",type:"uint256"}],name:"StakePenalized",type:"event",notice:"Emitted when an authorized Relay Hub penalizes a relayManager"},"StakeUnlocked(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"relayManager",type:"address"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!1,internalType:"uint256",name:"withdrawBlock",type:"uint256"}],name:"StakeUnlocked",type:"event",notice:"Emitted once a stake is scheduled for withdrawal"},"StakeWithdrawn(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"relayManager",type:"address"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"StakeWithdrawn",type:"event",notice:"Emitted when owner withdraws relayManager funds"}},methods:{"authorizeHubByManager(address)":{inputs:[{internalType:"address",name:"relayHub",type:"address"}],name:"authorizeHubByManager",outputs:[],stateMutability:"nonpayable",type:"function"},"authorizeHubByOwner(address,address)":{inputs:[{internalType:"address",name:"relayManager",type:"address"},{internalType:"address",name:"relayHub",type:"address"}],name:"authorizeHubByOwner",outputs:[],stateMutability:"nonpayable",type:"function"},"getStakeInfo(address)":{inputs:[{internalType:"address",name:"relayManager",type:"address"}],name:"getStakeInfo",outputs:[{components:[{internalType:"uint256",name:"stake",type:"uint256"},{internalType:"uint256",name:"unstakeDelay",type:"uint256"},{internalType:"uint256",name:"withdrawBlock",type:"uint256"},{internalType:"address payable",name:"owner",type:"address"}],internalType:"struct IStakeManager.StakeInfo",name:"stakeInfo",type:"tuple"}],stateMutability:"view",type:"function"},"isRelayManagerStaked(address,address,uint256,uint256)":{inputs:[{internalType:"address",name:"relayManager",type:"address"},{internalType:"address",name:"relayHub",type:"address"},{internalType:"uint256",name:"minAmount",type:"uint256"},{internalType:"uint256",name:"minUnstakeDelay",type:"uint256"}],name:"isRelayManagerStaked",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"penalizeRelayManager(address,address,uint256)":{inputs:[{internalType:"address",name:"relayManager",type:"address"},{internalType:"address payable",name:"beneficiary",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"penalizeRelayManager",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"- amount to withdraw from stake",beneficiary:"- address that receives half of the penalty amount",relayManager:"- entry to penalize"},notice:"Slash the stake of the relay relayManager. In order to prevent stake kidnapping, burns half of stake on the way."},"stakeForAddress(address,uint256)":{inputs:[{internalType:"address",name:"relayManager",type:"address"},{internalType:"uint256",name:"unstakeDelay",type:"uint256"}],name:"stakeForAddress",outputs:[],stateMutability:"payable",type:"function",params:{relayManager:"- address that represents a stake entry and controls relay registrations on relay hubs",unstakeDelay:"- number of blocks to elapse before the owner can retrieve the stake after calling 'unlock'"},notice:"Put a stake for a relayManager and set its unstake delay. If the entry does not exist, it is created, and the caller of this function becomes its owner. If the entry already exists, only the owner can call this function."},"unauthorizeHubByManager(address)":{inputs:[{internalType:"address",name:"relayHub",type:"address"}],name:"unauthorizeHubByManager",outputs:[],stateMutability:"nonpayable",type:"function"},"unauthorizeHubByOwner(address,address)":{inputs:[{internalType:"address",name:"relayManager",type:"address"},{internalType:"address",name:"relayHub",type:"address"}],name:"unauthorizeHubByOwner",outputs:[],stateMutability:"nonpayable",type:"function"},"unlockStake(address)":{inputs:[{internalType:"address",name:"relayManager",type:"address"}],name:"unlockStake",outputs:[],stateMutability:"nonpayable",type:"function"},"versionSM()":{inputs:[],name:"versionSM",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"withdrawStake(address)":{inputs:[{internalType:"address",name:"relayManager",type:"address"}],name:"withdrawStake",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/GSN/utils/GsnEip712Library.sol:GsnEip712Library":{source:"contracts/GSN/utils/GsnEip712Library.sol",name:"GsnEip712Library",notice:"Bridge Library to map GSN RelayRequest into a call of a Forwarder",methods:{"EIP712DOMAIN_TYPEHASH()":{inputs:[],name:"EIP712DOMAIN_TYPEHASH",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"GENERIC_PARAMS()":{inputs:[],name:"GENERIC_PARAMS",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"RELAYDATA_TYPE()":{inputs:[],name:"RELAYDATA_TYPE",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"view",type:"function"},"RELAYDATA_TYPEHASH()":{inputs:[],name:"RELAYDATA_TYPEHASH",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"RELAY_REQUEST_NAME()":{inputs:[],name:"RELAY_REQUEST_NAME",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"RELAY_REQUEST_SUFFIX()":{inputs:[],name:"RELAY_REQUEST_SUFFIX",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"RELAY_REQUEST_TYPE()":{inputs:[],name:"RELAY_REQUEST_TYPE",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"view",type:"function"},"RELAY_REQUEST_TYPEHASH()":{inputs:[],name:"RELAY_REQUEST_TYPEHASH",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"}}},"contracts/GSN/utils/GsnUtils.sol:GsnUtils":{source:"contracts/GSN/utils/GsnUtils.sol",name:"GsnUtils"},"contracts/GSN/utils/MinLibBytes.sol:MinLibBytes":{source:"contracts/GSN/utils/MinLibBytes.sol",name:"MinLibBytes"},"contracts/InvoiceFactoryUpgrade.sol:InvoiceFactoryUpgrade":{source:"contracts/InvoiceFactoryUpgrade.sol",name:"InvoiceFactoryUpgrade",title:"Invoice factory with an upgradeable feature",events:{"AnchorVerifyInvoice(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_anchor",type:"address"},{indexed:!0,internalType:"uint256",name:"_invoiceId",type:"uint256"}],name:"AnchorVerifyInvoice",type:"event"},"CreateTokenFromInvoice(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"_invoiceId",type:"uint256"},{indexed:!0,internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"CreateTokenFromInvoice",type:"event"},"EnrollAdmin(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_admin",type:"address"}],name:"EnrollAdmin",type:"event"},"EnrollAnchor(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_anchor",type:"address"}],name:"EnrollAnchor",type:"event"},"EnrollSupplier(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_supplier",type:"address"}],name:"EnrollSupplier",type:"event"},"RemoveAdmin(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_admin",type:"address"}],name:"RemoveAdmin",type:"event"},"RestoreAccount(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_originAddress",type:"address"},{indexed:!0,internalType:"address",name:"_newAddress",type:"address"}],name:"RestoreAccount",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"},"TrustVerifyAnchor(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_anchor",type:"address"}],name:"TrustVerifyAnchor",type:"event"},"TrustVerifySupplier(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_supplier",type:"address"}],name:"TrustVerifySupplier",type:"event"},"UploadInvoice(uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"_invoiceId",type:"uint256"},{indexed:!0,internalType:"address",name:"_supplier",type:"address"},{indexed:!0,internalType:"address",name:"_anchor",type:"address"}],name:"UploadInvoice",type:"event"}},methods:{"ANCHOR_ROLE()":{inputs:[],name:"ANCHOR_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"SUPPLIER_ROLE()":{inputs:[],name:"SUPPLIER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"__initialize(uint8,address,address,address,address)":{inputs:[{internalType:"uint8",name:"_decimals",type:"uint8"},{internalType:"address",name:"_trustAddress",type:"address"},{internalType:"address",name:"_trustedForwarder",type:"address"},{internalType:"address",name:"_tokenFactory",type:"address"},{internalType:"address",name:"_whitelist",type:"address"}],name:"__initialize",outputs:[],stateMutability:"nonpayable",type:"function"},"anchorVerifyInvoice(uint256)":{inputs:[{internalType:"uint256",name:"_invoiceId",type:"uint256"}],name:"anchorVerifyInvoice",outputs:[],stateMutability:"nonpayable",type:"function",details:"It emits `AnchorVerifyInvoice` if successful",params:{_invoiceId:"Invoice to be verified"},notice:"For anchor to verify an invoice"},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"enrollAdmin(address)":{inputs:[{internalType:"address",name:"_newAdmin",type:"address"}],name:"enrollAdmin",outputs:[],stateMutability:"nonpayable",type:"function",details:"It throws if `_newAdmin` has already enrolled, otherwise  it emits `EnrollAdmin` if successful",params:{_newAdmin:"Address of admin"},notice:"Enroll admin"},"enrollAnchor(address)":{inputs:[{internalType:"address",name:"_newAnchor",type:"address"}],name:"enrollAnchor",outputs:[],stateMutability:"nonpayable",type:"function",details:"It throws if `_newAnchor` has already enrolled, otherwise  it emits `EnrollAnchor` if successful",params:{_newAnchor:"Address of anchor"},notice:"Enroll anchor"},"enrollSupplier(address)":{inputs:[{internalType:"address",name:"_newSupplier",type:"address"}],name:"enrollSupplier",outputs:[],stateMutability:"nonpayable",type:"function",details:"It throws if `_newSupplier` has already enrolled, otherwise  it emitn `EnrollSupplier` if successful",params:{_newSupplier:"Address of supplier "},notice:"Enroll supplier"},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getRoleMember(bytes32,uint256)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"uint256",name:"index",type:"uint256"}],name:"getRoleMember",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information."},"getRoleMemberCount(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleMemberCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role."},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"invoiceCount()":{inputs:[],name:"invoiceCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"invoiceToToken(uint256)":{inputs:[{internalType:"uint256",name:"_invoiceId",type:"uint256"}],name:"invoiceToToken",outputs:[],stateMutability:"nonpayable",type:"function",details:"It throws if `msg.sender` is not admin, invoice hasn't  been confirmed by anchor or token has created before.  It emits `CreateTokenFromInvioce` if successful",params:{_invoiceId:"Invoice ID"},notice:"Create a token for invoice"},"isAnchor(address)":{inputs:[{internalType:"address",name:"_anchor",type:"address"}],name:"isAnchor",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{_anchor:"Address"},returns:{_0:"`true` if it has anchor role"},notice:"Check anchor role"},"isSupplier(address)":{inputs:[{internalType:"address",name:"_supplier",type:"address"}],name:"isSupplier",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{_supplier:"Address"},returns:{_0:"`true` if it has supplier role"},notice:"Check supplier role"},"isTrustedForwarder(address)":{inputs:[{internalType:"address",name:"forwarder",type:"address"}],name:"isTrustedForwarder",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"return if the forwarder is trusted to forward relayed transactions to us. the forwarder is required to verify the sender's signature, and verify the call is not a replay."},"queryAnchorVerified(address)":{inputs:[{internalType:"address",name:"_anchor",type:"address"}],name:"queryAnchorVerified",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"It returns zero if anchor is not verified",params:{_anchor:"Address of the anchor"},returns:{_0:"Timestamp of verification"},notice:"Queries the timestamp when the anchor is verified by trust"},"queryInvoice(uint256)":{inputs:[{internalType:"uint256",name:"_invoiceId",type:"uint256"}],name:"queryInvoice",outputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"bytes32",name:"",type:"bytes32"},{internalType:"bytes32",name:"",type:"bytes32"},{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",params:{_invoiceId:"Invoice ID to be queried"},returns:{_0:"Invoice ID",_1:"Invoice issuance time",_2:"Invoice amount",_3:"Invoice due date",_4:"Hash of the invoice pdf",_5:"Hash of the invoice number",_6:"Hash of the anchor name"},notice:"Queries the invoice information uploaded by supplier"},"queryInvoiceData(uint256)":{inputs:[{internalType:"uint256",name:"_invoiceId",type:"uint256"}],name:"queryInvoiceData",outputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"bytes32",name:"",type:"bytes32"},{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",params:{_invoiceId:"Invoice ID to be queried"},returns:{_0:"Corresponding Token ID, zero if does not have token",_1:"Interest rate",_2:"Address of the supplier",_3:"Address of the anchor "},notice:"Queries the invoice derivative information"},"queryInvoiceId(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"queryInvoiceId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"It throws if `_tokenId` is zero or does not have a  correcsponding invoice",params:{_tokenId:"Token ID"},returns:{_0:"Invoice ID"},notice:"Queries invoice ID by its correcponding token ID"},"querySupplierVerified(address)":{inputs:[{internalType:"address",name:"_supplier",type:"address"}],name:"querySupplierVerified",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"It returns zero if supplier is not verified",params:{_supplier:"Address of the supplier "},returns:{_0:"Timestamp of verification"},notice:"Queries the timestamp when the supplier is verified by trust"},"queryTokenId(uint256)":{inputs:[{internalType:"uint256",name:"_invoiceId",type:"uint256"}],name:"queryTokenId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"It throws if invoice does not have token creation history",params:{_invoiceId:"Invoice ID"},returns:{_0:"Token ID"},notice:"Queries token ID by its correcponding invoice ID"},"removeAdmin(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"removeAdmin",outputs:[],stateMutability:"nonpayable",type:"function",details:"It throws if `_account` not in admin role, otherwise  it emits `RemoveAdmin` if successful",params:{_account:"Address to admin"},notice:"Remove an address from admin role"},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"restoreAccount(address,address)":{inputs:[{internalType:"address",name:"_originAddress",type:"address"},{internalType:"address",name:"_newAddress",type:"address"}],name:"restoreAccount",outputs:[],stateMutability:"nonpayable",type:"function",details:"This function can only be accessed by admin. It emits  `RestoreAccount` if successful",params:{_newAddress:"New address",_originAddress:"Original address"},notice:"Set a new address for anchor or supplier"},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."},"setTimeInterval(uint256,uint128,uint128)":{inputs:[{internalType:"uint256",name:"_invoiceId",type:"uint256"},{internalType:"uint128",name:"_startTime",type:"uint128"},{internalType:"uint128",name:"_endTime",type:"uint128"}],name:"setTimeInterval",outputs:[],stateMutability:"nonpayable",type:"function",details:"This function can only be accessed by trust",params:{_endTime:"Ending time in unix time format",_invoiceId:"Invoice ID",_startTime:"Starting time in unix time format"},notice:"Set time interval for token holding time calculation "},"tokenFactory()":{inputs:[],name:"tokenFactory",outputs:[{internalType:"contract ITokenFactory",name:"",type:"address"}],stateMutability:"view",type:"function"},"trustAddress()":{inputs:[],name:"trustAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"trustVerifyAnchor(address)":{inputs:[{internalType:"address",name:"_anchor",type:"address"}],name:"trustVerifyAnchor",outputs:[],stateMutability:"nonpayable",type:"function",details:"It emits `TrustVerifyAnchor` if successful",params:{_anchor:"Address of anchor"},notice:"Trust verify anchor"},"trustVerifySupplier(address)":{inputs:[{internalType:"address",name:"_supplier",type:"address"}],name:"trustVerifySupplier",outputs:[],stateMutability:"nonpayable",type:"function",details:"It emits `TrustVerifySupplier` if successful",params:{_supplier:"Address of supplier "},notice:"Trust verify supplier "},"trustedForwarder()":{inputs:[],name:"trustedForwarder",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"updateTokenFactory(address)":{inputs:[{internalType:"address",name:"_newTokenFactory",type:"address"}],name:"updateTokenFactory",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newTokenFactory:"New token factory address"},notice:"Update token factory address"},"updateTrustAddress(address)":{inputs:[{internalType:"address",name:"_newTrust",type:"address"}],name:"updateTrustAddress",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newTrust:"New trust address"},notice:"Update trust address"},"updateWhitelist(address)":{inputs:[{internalType:"address",name:"_newWhitelist",type:"address"}],name:"updateWhitelist",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newWhitelist:"New whitelist address"},notice:"Update whitelist address"},"uploadInvoice(uint256,uint256,bytes32,bytes32,bytes32,bytes32,address,bytes)":{inputs:[{internalType:"uint256",name:"_invoiceAmount",type:"uint256"},{internalType:"uint256",name:"_time",type:"uint256"},{internalType:"bytes32",name:"_interestRate",type:"bytes32"},{internalType:"bytes32",name:"_invoicePdfHash",type:"bytes32"},{internalType:"bytes32",name:"_invoiceNumberHash",type:"bytes32"},{internalType:"bytes32",name:"_anchorHash",type:"bytes32"},{internalType:"address",name:"_anchorAddr",type:"address"},{internalType:"bytes",name:"_signature",type:"bytes"}],name:"uploadInvoice",outputs:[],stateMutability:"nonpayable",type:"function",details:"It emits `UploadInvoice` if successful",params:{_anchorAddr:"Address of anchor",_anchorHash:"Hash of the anchor name",_interestRate:"Interest rate",_invoiceAmount:"Invoice Amount",_invoiceNumberHash:"Hash of the invoice number",_invoicePdfHash:"Hash of the invoice pdf",_signature:"Admin signature",_time:"The first(high) 128-bit is issuance time of invoice,  the last(low) 128-bit is due date"},notice:"Upload an invoice by supplier"},"uploadPreSignedHash(uint256,uint256,bytes32,bytes32,bytes32,bytes32,address,address)":{inputs:[{internalType:"uint256",name:"_invoiceAmount",type:"uint256"},{internalType:"uint256",name:"_time",type:"uint256"},{internalType:"bytes32",name:"_interestRate",type:"bytes32"},{internalType:"bytes32",name:"_invoicePdfHash",type:"bytes32"},{internalType:"bytes32",name:"_invoiceNumberHash",type:"bytes32"},{internalType:"bytes32",name:"_anchorHash",type:"bytes32"},{internalType:"address",name:"_supplierAddr",type:"address"},{internalType:"address",name:"_anchorAddr",type:"address"}],name:"uploadPreSignedHash",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"pure",type:"function",params:{_anchorAddr:"Address of anchor",_anchorHash:"Hash of the anchor name",_interestRate:"Interest rate",_invoiceAmount:"Invoice Amount",_invoiceNumberHash:"Hash of the invoice number",_invoicePdfHash:"Hash of the invoice pdf",_supplierAddr:"Address of supplier ",_time:"The first(high) 128-bit is issuance time of invoice,  the last(low) 128-bit is due date"},notice:"Hash invoice"},"versionRecipient()":{inputs:[],name:"versionRecipient",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"whitelist()":{inputs:[],name:"whitelist",outputs:[{internalType:"contract IWhitelist",name:"",type:"address"}],stateMutability:"view",type:"function"}}},"contracts/TokenFactory.sol:TokenFactory":{source:"contracts/TokenFactory.sol",name:"TokenFactory",constructor:{inputs:[{internalType:"address",name:"_trustedForwarder",type:"address"}],stateMutability:"nonpayable",type:"constructor"},events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_owner",type:"address"},{indexed:!0,internalType:"address",name:"_approved",type:"address"},{indexed:!0,internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"Approval",type:"event"},"ApprovalForAll(address,address,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_owner",type:"address"},{indexed:!0,internalType:"address",name:"_operator",type:"address"},{indexed:!1,internalType:"bool",name:"_approved",type:"bool"}],name:"ApprovalForAll",type:"event"},"NewAdapter(uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"_tokenId",type:"uint256"},{indexed:!0,internalType:"address",name:"_adapter",type:"address"}],name:"NewAdapter",type:"event"},"RecordingTransferSingle(address,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"_operator",type:"address"},{indexed:!0,internalType:"address",name:"_from",type:"address"},{indexed:!0,internalType:"address",name:"_to",type:"address"},{indexed:!0,internalType:"uint256",name:"_tokenId",type:"uint256"},{indexed:!1,internalType:"uint256",name:"_value",type:"uint256"}],name:"RecordingTransferSingle",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_from",type:"address"},{indexed:!0,internalType:"address",name:"_to",type:"address"},{indexed:!0,internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"Transfer",type:"event"},"TransferBatch(address,address,address,uint256[],uint256[])":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_operator",type:"address"},{indexed:!0,internalType:"address",name:"_from",type:"address"},{indexed:!0,internalType:"address",name:"_to",type:"address"},{indexed:!1,internalType:"uint256[]",name:"_tokenIds",type:"uint256[]"},{indexed:!1,internalType:"uint256[]",name:"_values",type:"uint256[]"}],name:"TransferBatch",type:"event"},"TransferSingle(address,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_operator",type:"address"},{indexed:!0,internalType:"address",name:"_from",type:"address"},{indexed:!0,internalType:"address",name:"_to",type:"address"},{indexed:!1,internalType:"uint256",name:"_tokenId",type:"uint256"},{indexed:!1,internalType:"uint256",name:"_value",type:"uint256"}],name:"TransferSingle",type:"event"},"URI(string,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"string",name:"_value",type:"string"},{indexed:!0,internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"URI",type:"event"}},methods:{"approve(address,uint256)":{inputs:[{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"approve",outputs:[],stateMutability:"nonpayable",type:"function",details:"The zero address indicates there is no approved address.  Throws unless `msg.sender` is the current NFT owner, or an authorized  operator of the current owner.",params:{_to:"The new approved NFT controller",_tokenId:"The NFT to approve"},notice:"Change or reaffirm the approved address for an NFT"},"balanceOf(address,uint256)":{inputs:[{internalType:"address",name:"_owner",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"It accept both ",params:{_owner:"The address of the token holder",_tokenId:"ID of the Token"},returns:{_0:"The _owner's balance of the Token type requested"},notice:"Get the balance of an account's Tokens."},"balanceOf(address)":{inputs:[{internalType:"address",name:"_owner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_owner:"An address for whom to query the balance"},returns:{_0:"The number of NFTs owned by `_owner`, possibly zero"},notice:"Count all NFTs assigned to an owner"},"balanceOfBatch(address[],uint256[])":{inputs:[{internalType:"address[]",name:"_owners",type:"address[]"},{internalType:"uint256[]",name:"_tokenIds",type:"uint256[]"}],name:"balanceOfBatch",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"view",type:"function",params:{_owners:"The addresses of the token holders",_tokenIds:"ID of the Tokens"},returns:{_0:"The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)"},notice:"Get the balance of multiple account/token pairs"},"createToken(uint256,address,address,bool,string,bool)":{inputs:[{internalType:"uint256",name:"_supply",type:"uint256"},{internalType:"address",name:"_receiver",type:"address"},{internalType:"address",name:"_settingOperator",type:"address"},{internalType:"bool",name:"_needTime",type:"bool"},{internalType:"string",name:"_uri",type:"string"},{internalType:"bool",name:"_erc20",type:"bool"}],name:"createToken",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{_erc20:"Set to `true` to create a erc20 adapter for token",_needTime:"Set to `true` if need to query holding time for token",_receiver:"Address that receives minted token",_settingOperator:"Address that can perform setTimeInterval  and set ERC20 Attribute",_supply:"The amount of token to create",_uri:"URI that points to token metadata"},returns:{_0:"Token ID"},notice:"Create a token with uri"},"createToken(uint256,address,address,bool,bool)":{inputs:[{internalType:"uint256",name:"_supply",type:"uint256"},{internalType:"address",name:"_receiver",type:"address"},{internalType:"address",name:"_settingOperator",type:"address"},{internalType:"bool",name:"_needTime",type:"bool"},{internalType:"bool",name:"_erc20",type:"bool"}],name:"createToken",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{_erc20:"Set to `true` to create a erc20 adapter for token",_needTime:"Set to `true` if need to query holding time for token",_receiver:"Address that receives minted token",_settingOperator:"Address that can perform setTimeInterval  and set ERC20 Attribute",_supply:"The amount of token to create"},returns:{_0:"Token ID"},notice:"Create a token without setting uri"},"createTokenWithRecording(uint256,address,address,bool,address,string,bool)":{inputs:[{internalType:"uint256",name:"_supply",type:"uint256"},{internalType:"address",name:"_receiver",type:"address"},{internalType:"address",name:"_settingOperator",type:"address"},{internalType:"bool",name:"_needTime",type:"bool"},{internalType:"address",name:"_recordingOperator",type:"address"},{internalType:"string",name:"_uri",type:"string"},{internalType:"bool",name:"_erc20",type:"bool"}],name:"createTokenWithRecording",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",details:"Recording token shares the same token ID with normal token",params:{_erc20:"Set to `true` to create a erc20 adapter for token",_needTime:"Set to `true` if need to query holding time for token",_receiver:"Address that receives minted token",_recordingOperator:"Address that can manage recording token",_settingOperator:"Address that can perform setTimeInterval  and set ERC20 Attribute",_supply:"The amount of token to create",_uri:"URI that points to token metadata"},returns:{_0:"Token ID"},notice:"Create both normal token and recording token with uri"},"createTokenWithRecording(uint256,address,address,bool,address,bool)":{inputs:[{internalType:"uint256",name:"_supply",type:"uint256"},{internalType:"address",name:"_receiver",type:"address"},{internalType:"address",name:"_settingOperator",type:"address"},{internalType:"bool",name:"_needTime",type:"bool"},{internalType:"address",name:"_recordingOperator",type:"address"},{internalType:"bool",name:"_erc20",type:"bool"}],name:"createTokenWithRecording",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",details:"Recording token shares the same token ID with normal token",params:{_erc20:"Set to `true` to create a erc20 adapter for token",_needTime:"Set to `true` if need to query holding time for token",_receiver:"Address that receives minted token",_recordingOperator:"Address that can manage recording token",_settingOperator:"Address that can perform setTimeInterval  and set ERC20 Attribute",_supply:"The amount of token to create"},returns:{_0:"Token ID"},notice:"Create both normal token and recording token without setting uri"},"getAdapter(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"getAdapter",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns zero address if does not have a adapter",params:{_tokenId:"Token ID to be queried"},returns:{_0:"ERC20 adapter contract address"},notice:"Queries the erc20 adapter contract address for a given token ID"},"getApproved(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"getApproved",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Throws if `_tokenId` is not a valid NFT.",params:{_tokenId:"The NFT to find the approved address for"},returns:{_0:"The approved address for this NFT, or the zero address if there is none"},notice:"Get the approved address for a single NFT"},"holdingTimeOf(address,uint256)":{inputs:[{internalType:"address",name:"_owner",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"holdingTimeOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"It throws if it's not a need-time token. The way how holding time is  calculated is by suming up (token amount) * (holding time in second)",params:{_owner:"Address to be queried",_tokenId:"Token ID of the token to be queried"},returns:{_0:"Holding time"},notice:"Queries accumulated holding time for a given owner and token"},"isApprovedForAll(address,address)":{inputs:[{internalType:"address",name:"_owner",type:"address"},{internalType:"address",name:"_operator",type:"address"}],name:"isApprovedForAll",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{_operator:"Address of authorized operator",_owner:"The owner of the Tokens"},returns:{_0:"True if the operator is approved, false if not"},notice:"Queries the approval status of an operator for a given owner."},"isTrustedForwarder(address)":{inputs:[{internalType:"address",name:"forwarder",type:"address"}],name:"isTrustedForwarder",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"return if the forwarder is trusted to forward relayed transactions to us. the forwarder is required to verify the sender's signature, and verify the call is not a replay."},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"pure",type:"function",notice:"A descriptive name for a collection of NFTs in this contract"},"ownerOf(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"ownerOf",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"NFTs assigned to zero address or FT token are considered invalid,  and queries about them do throw.",params:{_tokenId:"The identifier for an NFT"},returns:{_0:"The address of the owner of the NFT"},notice:"Find the owner of an NFT"},"recordingBalanceOf(address,uint256)":{inputs:[{internalType:"address",name:"_owner",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"recordingBalanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_owner:"An address for whom to query the balance",_tokenId:"The token ID to be queried"},notice:"Count all recording token assigned to an address"},"recordingHoldingTimeOf(address,uint256)":{inputs:[{internalType:"address",name:"_owner",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"recordingHoldingTimeOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"It throws if it's not a need-time token. The way how holding time is  calculated is by suming up (token amount) * (holding time in second)It returns zero if it doesn't have a corresponding recording token",params:{_owner:"Address to be queried",_tokenId:"Token ID of the token to be queried"},returns:{_0:"Holding time"},notice:"Queries accumulated holding time for a given owner and recording token"},"recordingOperatorOf(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"recordingOperatorOf",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",params:{_tokenId:"Token ID to be queried"},returns:{_0:"The recording operator address"},notice:"Returns the recording operator of a token"},"recordingTransferFrom(address,address,uint256,uint256)":{inputs:[{internalType:"address",name:"_from",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"},{internalType:"uint256",name:"_value",type:"uint256"}],name:"recordingTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"If `_to` is zeroaddress or `msg.sender` is not recording operator,  it throwsa.",params:{_from:"Current owner of recording token",_to:"New owner",_tokenId:"The token to transfer",_value:"The amount to transfer"},notice:"Transfer recording token"},"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)":{inputs:[{internalType:"address",name:"_from",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256[]",name:"_tokenIds",type:"uint256[]"},{internalType:"uint256[]",name:"_values",type:"uint256[]"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"safeBatchTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:'Caller must be approved to manage the tokens being transferred out of the `_from` account (see "Approval" section of the standard). MUST revert if `_to` is the zero address. MUST revert if length of `_tokenIds` is not the same as length of `_values`. MUST revert if any of the balance(s) of the holder(s) for token(s) in `_tokenIds` is lower than the respective amount(s) in `_values` sent to the recipient. MUST revert on any other error. MUST emit `TransferSingle` or `TransferBatch` event(s) such that all the balance changes are reflected (see "Safe Transfer Rules" section of the standard). Balance changes and events MUST follow the ordering of the arrays (_tokenIds[0]/_values[0] before _tokenIds[1]/_values[1], etc). After the above conditions for the transfer(s) in the batch are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call the relevant `ERC1155TokenReceiver` hook(s) on `_to` and act appropriately (see "Safe Transfer Rules" section of the standard).',params:{_data:"Additional data with no specified format, MUST be sent unaltered in call to the `ERC1155TokenReceiver` hook(s) on `_to`",_from:"Source address",_to:"Target address",_tokenIds:"IDs of each token type (order and length must match _values array)",_values:"Transfer amounts per token type (order and length must match _tokenIds array)"},notice:"Transfers `_values` amount(s) of `_tokenIds` from the `_from` address to the `_to` address specified (with safety call)."},"safeTransferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"_from",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:'This works identically to the other function with an extra data parameter,  except this function just sets data to "".',params:{_from:"The current owner of the NFT",_to:"The new owner",_tokenId:"The NFT to transfer"},notice:"Transfers the ownership of an NFT from one address to another address"},"safeTransferFrom(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"_from",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:'Throws unless `msg.sender` is the current owner, an authorized  operator, or the approved address for this NFT. Throws if `_from` is  not the current owner. Throws if `_to` is the zero address. Throws if  `_tokenId` is not a valid NFT. When transfer is complete, this function  checks if `_to` is a smart contract (code size > 0). If so, it calls  `onERC721Received` on `_to` and throws if the return value is not  `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`.',params:{_data:"Additional data with no specified format, sent in call to `_to`",_from:"The current owner of the NFT",_to:"The new owner",_tokenId:"The NFT to transfer"},notice:"Transfers the ownership of an NFT from one address to another address"},"safeTransferFrom(address,address,uint256,uint256,bytes)":{inputs:[{internalType:"address",name:"_from",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"},{internalType:"uint256",name:"_value",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:'Caller must be approved to manage the tokens being transferred out of the `_from` account (see "Approval" section of the standard). MUST revert if `_to` is the zero address. MUST revert if balance of holder for token `_tokenId` is lower than the `_value` sent. MUST revert on any other error. MUST emit the `TransferSingle` event to reflect the balance change (see "Safe Transfer Rules" section of the standard). After the above conditions are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call `onERC1155Received` on `_to` and act appropriately (see "Safe Transfer Rules" section of the standard).',params:{_data:"Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `_to`",_from:"Source address",_to:"Target address",_tokenId:"ID of the token type",_value:"Transfer amount"},notice:"Transfers `_value` amount of an `_tokenId` from the `_from` address to the `_to` address specified (with safety call)."},"setApprovalForAll(address,bool)":{inputs:[{internalType:"address",name:"_operator",type:"address"},{internalType:"bool",name:"_approved",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"MUST emit the ApprovalForAll event on success.",params:{_approved:"True if the operator is approved, false to revoke approval",_operator:"Address to add to the set of authorized operators"},notice:'Enable or disable approval for a third party ("operator") to manage all of the caller\'s tokens.'},"setERC20Attribute(uint256,string,string,uint8)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"},{internalType:"string",name:"_name",type:"string"},{internalType:"string",name:"_symbol",type:"string"},{internalType:"uint8",name:"_decimals",type:"uint8"}],name:"setERC20Attribute",outputs:[],stateMutability:"nonpayable",type:"function",details:"Throws if `msg.sender` is not authorized setting operator",params:{_decimals:"Number of decimals to use",_name:"Name of the token",_symbol:"Symbol of the token",_tokenId:"Corresponding token ID with erc20 adapter"},notice:"Set erc20 token attribute"},"setTimeInterval(uint256,uint128,uint128)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"},{internalType:"uint128",name:"_startTime",type:"uint128"},{internalType:"uint128",name:"_endTime",type:"uint128"}],name:"setTimeInterval",outputs:[],stateMutability:"nonpayable",type:"function",details:"Starting time must be greater than time at the momentTo save gas cost, here use uint128 to store time",params:{_endTime:"Ending time in unix time format",_startTime:"Starting time in unix time format"},notice:"Set starting time and ending time for token holding time calculation"},"settingOperatorOf(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"settingOperatorOf",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",params:{_tokenId:"Token ID to be queried"},returns:{_0:"The setting operator address"},notice:"Returns the setting operator of a token"},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"_interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"pure",type:"function",details:"Interface identification is specified in ERC-165. This function  uses less than 30,000 gas.",params:{_interfaceId:"The interface identifier, as specified in ERC-165"},returns:{_0:"`true` if the contract implements `_interfaceId`,  `false` otherwise"},notice:"Query if a contract implements an interface"},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"pure",type:"function",notice:"An abbreviated name for NFTs in this contract"},"template()":{inputs:[],name:"template",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"timeIntervalOf(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"timeIntervalOf",outputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_tokenId:"Token ID to be queried"},returns:{_0:"The starting time in unix time",_1:"The ending time in unix time"},notice:"Returns the starting time and ending time of token holding time calculation"},"tokenURI(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"tokenURI",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:'Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC  3986. The URI may point to a JSON file that conforms to the "ERC721  Metadata JSON Schema".',notice:"A distinct Uniform Resource Identifier (URI) for a given asset."},"totalSupply(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_tokenId:"Token ID to be queried"},returns:{_0:"Total supply of a token"},notice:"Returns total supply of a token"},"transferByAdapter(address,address,uint256,uint256)":{inputs:[{internalType:"address",name:"_from",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"},{internalType:"uint256",name:"_value",type:"uint256"}],name:"transferByAdapter",outputs:[],stateMutability:"nonpayable",type:"function",details:"This function should only be called from erc20 adapter",params:{_from:"Source address",_to:"Target address",_tokenId:"ID of the token type",_value:"Transfer amount"},notice:"Transfers `_value` amount of `_tokenId` from `_from` to `_to`"},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"_from",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"transferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Throws unless `msg.sender` is the current owner, an authorized  operator, or the approved address for this NFT. Throws if `_from` is  not the current owner. Throws if `_to` is the zero address. Throws if  `_tokenId` is not a valid NFT.",params:{_from:"The current owner of the NFT",_to:"The new owner",_tokenId:"The NFT to transfer"},notice:"Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE  THEY MAY BE PERMANENTLY LOST"},"trustedForwarder()":{inputs:[],name:"trustedForwarder",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"uri(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"uri",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:'URIs are defined in RFC 3986. The URI MUST point to a JSON file that conforms to the "ERC-1155 Metadata URI JSON Schema".        ',returns:{_0:"URI string"},notice:"A distinct Uniform Resource Identifier (URI) for a given token."},"versionRecipient()":{inputs:[],name:"versionRecipient",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"}}},"contracts/Whitelist.sol:Whitelist":{source:"contracts/Whitelist.sol",name:"Whitelist",title:"GNS whitelist contract",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},receive:{stateMutability:"payable",type:"receive"},events:{"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"}},methods:{"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"FORWARDER_HUB_OVERHEAD()":{inputs:[],name:"FORWARDER_HUB_OVERHEAD",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"PAYMASTER_ACCEPTANCE_BUDGET()":{inputs:[],name:"PAYMASTER_ACCEPTANCE_BUDGET",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"POST_RELAYED_CALL_GAS_LIMIT()":{inputs:[],name:"POST_RELAYED_CALL_GAS_LIMIT",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"PRE_RELAYED_CALL_GAS_LIMIT()":{inputs:[],name:"PRE_RELAYED_CALL_GAS_LIMIT",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"WHITELIST_ROLE()":{inputs:[],name:"WHITELIST_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"_verifyForwarder(((address,address,uint256,uint256,uint256,bytes),(uint256,uint256,uint256,address,address,bytes,uint256,address)))":{inputs:[{components:[{components:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"gas",type:"uint256"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],internalType:"struct IForwarder.ForwardRequest",name:"request",type:"tuple"},{components:[{internalType:"uint256",name:"gasPrice",type:"uint256"},{internalType:"uint256",name:"pctRelayFee",type:"uint256"},{internalType:"uint256",name:"baseRelayFee",type:"uint256"},{internalType:"address",name:"relayWorker",type:"address"},{internalType:"address",name:"paymaster",type:"address"},{internalType:"bytes",name:"paymasterData",type:"bytes"},{internalType:"uint256",name:"clientId",type:"uint256"},{internalType:"address",name:"forwarder",type:"address"}],internalType:"struct GsnTypes.RelayData",name:"relayData",type:"tuple"}],internalType:"struct GsnTypes.RelayRequest",name:"relayRequest",type:"tuple"}],name:"_verifyForwarder",outputs:[],stateMutability:"view",type:"function"},"_verifySignature(((address,address,uint256,uint256,uint256,bytes),(uint256,uint256,uint256,address,address,bytes,uint256,address)),bytes)":{inputs:[{components:[{components:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"gas",type:"uint256"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],internalType:"struct IForwarder.ForwardRequest",name:"request",type:"tuple"},{components:[{internalType:"uint256",name:"gasPrice",type:"uint256"},{internalType:"uint256",name:"pctRelayFee",type:"uint256"},{internalType:"uint256",name:"baseRelayFee",type:"uint256"},{internalType:"address",name:"relayWorker",type:"address"},{internalType:"address",name:"paymaster",type:"address"},{internalType:"bytes",name:"paymasterData",type:"bytes"},{internalType:"uint256",name:"clientId",type:"uint256"},{internalType:"address",name:"forwarder",type:"address"}],internalType:"struct GsnTypes.RelayData",name:"relayData",type:"tuple"}],internalType:"struct GsnTypes.RelayRequest",name:"relayRequest",type:"tuple"},{internalType:"bytes",name:"signature",type:"bytes"}],name:"_verifySignature",outputs:[],stateMutability:"view",type:"function"},"acceptOwnership()":{inputs:[],name:"acceptOwnership",outputs:[],stateMutability:"nonpayable",type:"function"},"addAdmin(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"addAdmin",outputs:[],stateMutability:"nonpayable",type:"function",details:"It does not throw if address already has role admin",params:{_account:"The address to be inserted"},notice:"Insert an address into role admin"},"addWhitelist(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"addWhitelist",outputs:[],stateMutability:"nonpayable",type:"function",details:"It does not throw if address already has role whitelist",params:{_account:"The address to be inserted"},notice:"Insert an address into role whitelist"},"getGasLimits()":{inputs:[],name:"getGasLimits",outputs:[{components:[{internalType:"uint256",name:"acceptanceBudget",type:"uint256"},{internalType:"uint256",name:"preRelayedCallGasLimit",type:"uint256"},{internalType:"uint256",name:"postRelayedCallGasLimit",type:"uint256"}],internalType:"struct IPaymaster.GasLimits",name:"limits",type:"tuple"}],stateMutability:"view",type:"function",notice:"Return the GasLimits constants used by the Paymaster."},"getHubAddr()":{inputs:[],name:"getHubAddr",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"return the relayHub of this contract."},"getRelayHubDeposit()":{inputs:[],name:"getRelayHubDeposit",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"check current deposit on relay hub."},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getRoleMember(bytes32,uint256)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"uint256",name:"index",type:"uint256"}],name:"getRoleMember",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information."},"getRoleMemberCount(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleMemberCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role."},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"inWhitelist(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"inWhitelist",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{_account:"The address to be queried"},returns:{_0:"`True` if `_account` has role whitelist"},notice:"Queries whether an address has role whitelist"},"isAdmin(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"isAdmin",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{_account:"The address to be queried"},returns:{_0:"`True` if `_account` has role admin"},notice:"Quries whether an address has role admin"},"newOwner()":{inputs:[],name:"newOwner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"postRelayedCall(bytes,bool,uint256,(uint256,uint256,uint256,address,address,bytes,uint256,address))":{inputs:[{internalType:"bytes",name:"context",type:"bytes"},{internalType:"bool",name:"success",type:"bool"},{internalType:"uint256",name:"gasUseWithoutPost",type:"uint256"},{components:[{internalType:"uint256",name:"gasPrice",type:"uint256"},{internalType:"uint256",name:"pctRelayFee",type:"uint256"},{internalType:"uint256",name:"baseRelayFee",type:"uint256"},{internalType:"address",name:"relayWorker",type:"address"},{internalType:"address",name:"paymaster",type:"address"},{internalType:"bytes",name:"paymasterData",type:"bytes"},{internalType:"uint256",name:"clientId",type:"uint256"},{internalType:"address",name:"forwarder",type:"address"}],internalType:"struct GsnTypes.RelayData",name:"relayData",type:"tuple"}],name:"postRelayedCall",outputs:[],stateMutability:"nonpayable",type:"function",params:{context:"- the call context, as returned by the preRelayedCall",gasUseWithoutPost:"- the actual amount of gas used by the entire transaction, EXCEPT        the gas used by the postRelayedCall itself.",relayData:"- the relay params of the request. can be used by relayHub.calculateCharge() Revert in this functions causes a revert of the client's relayed call (and preRelayedCall(), but the Paymaster is still committed to pay the relay for the entire transaction.",success:"- true if the relayed call succeeded, false if it reverted"},notice:"This method is called after the actual relayed function call. It may be used to record the transaction (e.g. charge the caller by some contract logic) for this call. MUST be protected with relayHubOnly() in case it modifies state."},"preRelayedCall(((address,address,uint256,uint256,uint256,bytes),(uint256,uint256,uint256,address,address,bytes,uint256,address)),bytes,bytes,uint256)":{inputs:[{components:[{components:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"gas",type:"uint256"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],internalType:"struct IForwarder.ForwardRequest",name:"request",type:"tuple"},{components:[{internalType:"uint256",name:"gasPrice",type:"uint256"},{internalType:"uint256",name:"pctRelayFee",type:"uint256"},{internalType:"uint256",name:"baseRelayFee",type:"uint256"},{internalType:"address",name:"relayWorker",type:"address"},{internalType:"address",name:"paymaster",type:"address"},{internalType:"bytes",name:"paymasterData",type:"bytes"},{internalType:"uint256",name:"clientId",type:"uint256"},{internalType:"address",name:"forwarder",type:"address"}],internalType:"struct GsnTypes.RelayData",name:"relayData",type:"tuple"}],internalType:"struct GsnTypes.RelayRequest",name:"relayRequest",type:"tuple"},{internalType:"bytes",name:"signature",type:"bytes"},{internalType:"bytes",name:"approvalData",type:"bytes"},{internalType:"uint256",name:"maxPossibleGas",type:"uint256"}],name:"preRelayedCall",outputs:[{internalType:"bytes",name:"context",type:"bytes"},{internalType:"bool",name:"rejectOnRecipientRevert",type:"bool"}],stateMutability:"view",type:"function",params:{approvalData:"- extra dapp-specific data (e.g. signature from trusted party)",maxPossibleGas:'- based on values returned from {@link getGasLimits},         the RelayHub will calculate the maximum possible amount of gas the user may be charged for.         In order to convert this value to wei, the Paymaster has to call "relayHub.calculateCharge()"  return:      a context to be passed to postRelayedCall      rejectOnRecipientRevert - TRUE if paymaster want to reject the TX if the recipient reverts.          FALSE means that rejects by the recipient will be completed on chain, and paid by the paymaster.          (note that in the latter case, the preRelayedCall and postRelayedCall are not reverted).',relayRequest:"- the full relay request structure",signature:"- user's EIP712-compatible signature of the {@link relayRequest}.              Note that in most cases the paymaster shouldn't try use it at all. It is always checked              by the forwarder immediately after preRelayedCall returns."},notice:'Called by Relay (and RelayHub), to validate if the paymaster agrees to pay for this call. MUST be protected with relayHubOnly() in case it modifies state. The Paymaster rejects by the following "revert" operations  - preRelayedCall() method reverts  - the forwarder reverts because of nonce or signature error  - the paymaster returned "rejectOnRecipientRevert", and the recipient contract reverted. In any of the above cases, all paymaster calls (and recipient call) are reverted. In any other case, the paymaster agrees to pay for the gas cost of the transaction (note  that this includes also postRelayedCall revert) The rejectOnRecipientRevert flag means the Paymaster "delegate" the rejection to the recipient  code.  It also means the Paymaster trust the recipient to reject fast: both preRelayedCall,  forwarder check and receipient checks must fit into the GasLimits.acceptanceBudget,  otherwise the TX is paid by the Paymaster.'},"removeAdmin(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"removeAdmin",outputs:[],stateMutability:"nonpayable",type:"function",details:"It throws if `msg.sender` does no have role admin.  It does not throw if address is not in role admin.",params:{_account:"The address to be removed"},notice:"Remove an address from role admin"},"removeWhitelist(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"removeWhitelist",outputs:[],stateMutability:"nonpayable",type:"function",details:"It throws if `msg.sender` does no have role admin.  It does not throw if address is not in role whitelist.",params:{_account:"The address to be removed"},notice:"Remove an address from role whitelist"},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."},"setRelayHub(address)":{inputs:[{internalType:"contract IRelayHub",name:"hub",type:"address"}],name:"setRelayHub",outputs:[],stateMutability:"nonpayable",type:"function"},"setTrustedForwarder(address)":{inputs:[{internalType:"contract IForwarder",name:"forwarder",type:"address"}],name:"setTrustedForwarder",outputs:[],stateMutability:"nonpayable",type:"function"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"_newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"trustedForwarder()":{inputs:[],name:"trustedForwarder",outputs:[{internalType:"contract IForwarder",name:"",type:"address"}],stateMutability:"view",type:"function"},"versionPaymaster()":{inputs:[],name:"versionPaymaster",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"pure",type:"function"},"withdrawRelayHubDepositTo(uint256,address)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"address payable",name:"target",type:"address"}],name:"withdrawRelayHubDepositTo",outputs:[],stateMutability:"nonpayable",type:"function",notice:"withdraw deposit from relayHub"}}},"contracts/interfaces/IERC1155.sol:IERC1155":{source:"contracts/interfaces/IERC1155.sol",name:"IERC1155",title:"ERC-1155 Multi Token Standard",details:"See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1155.md Note: The ERC-165 identifier for this interface is 0xd9b67a26.",events:{"ApprovalForAll(address,address,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_owner",type:"address"},{indexed:!0,internalType:"address",name:"_operator",type:"address"},{indexed:!1,internalType:"bool",name:"_approved",type:"bool"}],name:"ApprovalForAll",type:"event",details:"MUST emit when approval for a second party/operator address to manage all tokens for an owner address is enabled or disabled (absense of an event assumes disabled)."},"TransferBatch(address,address,address,uint256[],uint256[])":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_operator",type:"address"},{indexed:!0,internalType:"address",name:"_from",type:"address"},{indexed:!0,internalType:"address",name:"_to",type:"address"},{indexed:!1,internalType:"uint256[]",name:"_tokenIds",type:"uint256[]"},{indexed:!1,internalType:"uint256[]",name:"_values",type:"uint256[]"}],name:"TransferBatch",type:"event",details:'Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see "Safe Transfer Rules" section of the standard). The `_operator` argument MUST be msg.sender. The `_from` argument MUST be the address of the holder whose balance is decreased. The `_to` argument MUST be the address of the recipient whose balance is increased. The `_tokenIds` argument MUST be the list of tokens being transferred. The `_values` argument MUST be the list of number of tokens (matching the list and order of tokens specified in _tokenIds) the holder balance is decreased by and match what the recipient balance is increased by. When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address). When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).'},"TransferSingle(address,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_operator",type:"address"},{indexed:!0,internalType:"address",name:"_from",type:"address"},{indexed:!0,internalType:"address",name:"_to",type:"address"},{indexed:!1,internalType:"uint256",name:"_tokenId",type:"uint256"},{indexed:!1,internalType:"uint256",name:"_value",type:"uint256"}],name:"TransferSingle",type:"event",details:'Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see "Safe Transfer Rules" section of the standard). The `_operator` argument MUST be msg.sender. The `_from` argument MUST be the address of the holder whose balance is decreased. The `_to` argument MUST be the address of the recipient whose balance is increased. The `_tokenId` argument MUST be the token type being transferred. The `_value` argument MUST be the number of tokens the holder balance is decreased by and match what the recipient balance is increased by. When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address). When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).'},"URI(string,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"string",name:"_value",type:"string"},{indexed:!0,internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"URI",type:"event",details:'MUST emit when the URI is updated for a token ID. URIs are defined in RFC 3986. The URI MUST point a JSON file that conforms to the "ERC-1155 Metadata URI JSON Schema".'}},methods:{"balanceOf(address,uint256)":{inputs:[{internalType:"address",name:"_owner",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_owner:"The address of the token holder",_tokenId:"ID of the Token"},returns:{_0:"The _owner's balance of the Token type requested"},notice:"Get the balance of an account's Tokens."},"balanceOfBatch(address[],uint256[])":{inputs:[{internalType:"address[]",name:"_owners",type:"address[]"},{internalType:"uint256[]",name:"_tokenIds",type:"uint256[]"}],name:"balanceOfBatch",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"view",type:"function",params:{_owners:"The addresses of the token holders",_tokenIds:"ID of the Tokens"},returns:{_0:"The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)"},notice:"Get the balance of multiple account/token pairs"},"isApprovedForAll(address,address)":{inputs:[{internalType:"address",name:"_owner",type:"address"},{internalType:"address",name:"_operator",type:"address"}],name:"isApprovedForAll",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{_operator:"Address of authorized operator",_owner:"The owner of the Tokens"},returns:{_0:"True if the operator is approved, false if not"},notice:"Queries the approval status of an operator for a given owner."},"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)":{inputs:[{internalType:"address",name:"_from",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256[]",name:"_tokenIds",type:"uint256[]"},{internalType:"uint256[]",name:"_values",type:"uint256[]"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"safeBatchTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:'Caller must be approved to manage the tokens being transferred out of the `_from` account (see "Approval" section of the standard). MUST revert if `_to` is the zero address. MUST revert if length of `_tokenIds` is not the same as length of `_values`. MUST revert if any of the balance(s) of the holder(s) for token(s) in `_tokenIds` is lower than the respective amount(s) in `_values` sent to the recipient. MUST revert on any other error. MUST emit `TransferSingle` or `TransferBatch` event(s) such that all the balance changes are reflected (see "Safe Transfer Rules" section of the standard). Balance changes and events MUST follow the ordering of the arrays (_tokenIds[0]/_values[0] before _tokenIds[1]/_values[1], etc). After the above conditions for the transfer(s) in the batch are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call the relevant `ERC1155TokenReceiver` hook(s) on `_to` and act appropriately (see "Safe Transfer Rules" section of the standard).',params:{_data:"Additional data with no specified format, MUST be sent unaltered in call to the `ERC1155TokenReceiver` hook(s) on `_to`",_from:"Source address",_to:"Target address",_tokenIds:"IDs of each token type (order and length must match _values array)",_values:"Transfer amounts per token type (order and length must match _tokenIds array)"},notice:"Transfers `_values` amount(s) of `_tokenIds` from the `_from` address to the `_to` address specified (with safety call)."},"safeTransferFrom(address,address,uint256,uint256,bytes)":{inputs:[{internalType:"address",name:"_from",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"},{internalType:"uint256",name:"_value",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:'Caller must be approved to manage the tokens being transferred out of the `_from` account (see "Approval" section of the standard). MUST revert if `_to` is the zero address. MUST revert if balance of holder for token `_tokenId` is lower than the `_value` sent. MUST revert on any other error. MUST emit the `TransferSingle` event to reflect the balance change (see "Safe Transfer Rules" section of the standard). After the above conditions are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call `onERC1155Received` on `_to` and act appropriately (see "Safe Transfer Rules" section of the standard).',params:{_data:"Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `_to`",_from:"Source address",_to:"Target address",_tokenId:"ID of the token type",_value:"Transfer amount"},notice:"Transfers `_value` amount of an `_tokenId` from the `_from` address to the `_to` address specified (with safety call)."},"setApprovalForAll(address,bool)":{inputs:[{internalType:"address",name:"_operator",type:"address"},{internalType:"bool",name:"_approved",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"MUST emit the ApprovalForAll event on success.",params:{_approved:"True if the operator is approved, false to revoke approval",_operator:"Address to add to the set of authorized operators"},notice:'Enable or disable approval for a third party ("operator") to manage all of the caller\'s tokens.'}}},"contracts/interfaces/IERC1155Metadata.sol:IERC1155Metadata":{source:"contracts/interfaces/IERC1155Metadata.sol",name:"IERC1155Metadata",notice:"Note: The ERC-165 identifier for this interface is 0x0e89341c.",methods:{"uri(uint256)":{inputs:[{internalType:"uint256",name:"_id",type:"uint256"}],name:"uri",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:'URIs are defined in RFC 3986. The URI MUST point to a JSON file that conforms to the "ERC-1155 Metadata URI JSON Schema".        ',returns:{_0:"URI string"},notice:"A distinct Uniform Resource Identifier (URI) for a given token."}}},"contracts/interfaces/IERC1155TokenReceiver.sol:IERC1155TokenReceiver":{source:"contracts/interfaces/IERC1155TokenReceiver.sol",name:"IERC1155TokenReceiver",notice:"Note: The ERC-165 identifier for this interface is 0x4e2312e0.",methods:{"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)":{inputs:[{internalType:"address",name:"_operator",type:"address"},{internalType:"address",name:"_from",type:"address"},{internalType:"uint256[]",name:"_ids",type:"uint256[]"},{internalType:"uint256[]",name:"_values",type:"uint256[]"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"onERC1155BatchReceived",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function",details:'An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated. This function MUST return `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))` (i.e. 0xbc197c81) if it accepts the transfer(s). This function MUST revert if it rejects the transfer(s). Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.',params:{_data:"Additional data with no specified format",_from:"The address which previously owned the token",_ids:"An array containing ids of each token being transferred (order and length must match _values array)",_operator:"The address which initiated the batch transfer (i.e. msg.sender)",_values:"An array containing amounts of each token being transferred (order and length must match _ids array)"},returns:{_0:'`bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`'},notice:"Handle the receipt of multiple ERC1155 token types."},"onERC1155Received(address,address,uint256,uint256,bytes)":{inputs:[{internalType:"address",name:"_operator",type:"address"},{internalType:"address",name:"_from",type:"address"},{internalType:"uint256",name:"_id",type:"uint256"},{internalType:"uint256",name:"_value",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"onERC1155Received",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function",details:'An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated. This function MUST return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` (i.e. 0xf23a6e61) if it accepts the transfer. This function MUST revert if it rejects the transfer. Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.',params:{_data:"Additional data with no specified format",_from:"The address which previously owned the token",_id:"The ID of the token being transferred",_operator:"The address which initiated the transfer (i.e. msg.sender)",_value:"The amount of tokens being transferred"},returns:{_0:'`bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`'},notice:"Handle the receipt of a single ERC1155 token type."}}},"contracts/interfaces/IERC165.sol:IERC165":{source:"contracts/interfaces/IERC165.sol",name:"IERC165",title:"ERC165",details:"https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md",methods:{"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"_interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Interface identification is specified in ERC-165. This function uses less than 30,000 gas.",params:{_interfaceId:"The interface identifier, as specified in ERC-165"},notice:"Query if a contract implements an interface"}}},"contracts/interfaces/IERC20.sol:IERC20":{source:"contracts/interfaces/IERC20.sol",name:"IERC20",details:"Interface of the ERC20 standard as defined in the EIP.",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_owner",type:"address"},{indexed:!0,internalType:"address",name:"_spender",type:"address"},{indexed:!1,internalType:"uint256",name:"_value",type:"uint256"}],name:"Approval",type:"event",details:"Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance."},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_from",type:"address"},{indexed:!0,internalType:"address",name:"_to",type:"address"},{indexed:!1,internalType:"uint256",name:"_value",type:"uint256"}],name:"Transfer",type:"event",details:"Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero."}},methods:{"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens owned by `account`."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens in existence."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from the caller's account to `recipient`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."}}},"contracts/interfaces/IERC20Adapter.sol:IERC20Adapter":{source:"contracts/interfaces/IERC20Adapter.sol",name:"IERC20Adapter",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_owner",type:"address"},{indexed:!0,internalType:"address",name:"_spender",type:"address"},{indexed:!1,internalType:"uint256",name:"_value",type:"uint256"}],name:"Approval",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_from",type:"address"},{indexed:!0,internalType:"address",name:"_to",type:"address"},{indexed:!1,internalType:"uint256",name:"_value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens owned by `account`."},"emitTransfer(address,address,uint256)":{inputs:[{internalType:"address",name:"_from",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_value",type:"uint256"}],name:"emitTransfer",outputs:[],stateMutability:"nonpayable",type:"function"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens in existence."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from the caller's account to `recipient`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."}}},"contracts/interfaces/IERC721.sol:IERC721":{source:"contracts/interfaces/IERC721.sol",name:"IERC721",details:"Required interface of an ERC721 compliant contract.",methods:{"approve(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"approve",outputs:[],stateMutability:"nonpayable",type:"function",details:"Gives permission to `to` to transfer `tokenId` token to another account. The approval is cleared when the token is transferred. Only a single account can be approved at a time, so approving the zero address clears previous approvals. Requirements: - The caller must own the token or be an approved operator. - `tokenId` must exist. Emits an {Approval} event."},"balanceOf(address)":{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"balance",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of tokens in ``owner``'s account."},"getApproved(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"getApproved",outputs:[{internalType:"address",name:"operator",type:"address"}],stateMutability:"view",type:"function",details:"Returns the account approved for `tokenId` token. Requirements: - `tokenId` must exist."},"isApprovedForAll(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"operator",type:"address"}],name:"isApprovedForAll",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns if the `operator` is allowed to manage all of the assets of `owner`. See {setApprovalForAll}"},"ownerOf(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"ownerOf",outputs:[{internalType:"address",name:"owner",type:"address"}],stateMutability:"view",type:"function",details:"Returns the owner of the `tokenId` token. Requirements: - `tokenId` must exist."},"safeTransferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients are aware of the ERC721 protocol to prevent tokens from being forever locked. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must exist and be owned by `from`. - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}. - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event."},"safeTransferFrom(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Safely transfers `tokenId` token from `from` to `to`. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must exist and be owned by `from`. - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}. - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event."},"setApprovalForAll(address,bool)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bool",name:"_approved",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"Approve or remove `operator` as an operator for the caller. Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller. Requirements: - The `operator` cannot be the caller. Emits an {ApprovalForAll} event."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"transferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers `tokenId` token from `from` to `to`. WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must be owned by `from`. - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}. Emits a {Transfer} event."}}},"contracts/interfaces/IERC721Event.sol:IERC721Event":{source:"contracts/interfaces/IERC721Event.sol",name:"IERC721Event",details:"Required interface of an ERC721 compliant contract.",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_owner",type:"address"},{indexed:!0,internalType:"address",name:"_approved",type:"address"},{indexed:!0,internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"Approval",type:"event",details:"Emitted when `owner` enables `approved` to manage the `tokenId` token."},"ApprovalForAll(address,address,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_owner",type:"address"},{indexed:!0,internalType:"address",name:"_operator",type:"address"},{indexed:!1,internalType:"bool",name:"_approved",type:"bool"}],name:"ApprovalForAll",type:"event",details:"Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets."},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_from",type:"address"},{indexed:!0,internalType:"address",name:"_to",type:"address"},{indexed:!0,internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"Transfer",type:"event",details:"Emitted when `tokenId` token is transferred from `from` to `to`."}}},"contracts/interfaces/IERC721Metadata.sol:IERC721Metadata":{source:"contracts/interfaces/IERC721Metadata.sol",name:"IERC721Metadata",title:"ERC-721 Non-Fungible Token Standard, optional metadata extension",details:"See https://eips.ethereum.org/EIPS/eip-721  Note: the ERC-165 identifier for this interface is 0x5b5e139f.",methods:{"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",notice:"A descriptive name for a collection of NFTs in this contract"},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",notice:"An abbreviated name for NFTs in this contract"},"tokenURI(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"tokenURI",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:'Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC  3986. The URI may point to a JSON file that conforms to the "ERC721  Metadata JSON Schema".',notice:"A distinct Uniform Resource Identifier (URI) for a given asset."}}},"contracts/interfaces/IERC721Receiver.sol:IERC721Receiver":{source:"contracts/interfaces/IERC721Receiver.sol",name:"IERC721Receiver",title:"ERC721 token receiver interface",details:"Interface for any contract that wants to support safeTransfers from ERC721 asset contracts.",methods:{"onERC721Received(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"from",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"onERC721Received",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function",details:"Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom} by `operator` from `from`, this function is called. It must return its Solidity selector to confirm the token transfer. If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted. The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`."}}},"contracts/interfaces/ITokenFactory.sol:ITokenFactory":{source:"contracts/interfaces/ITokenFactory.sol",name:"ITokenFactory",methods:{"createToken(uint256,address,address,bool,string,bool)":{inputs:[{internalType:"uint256",name:"_supply",type:"uint256"},{internalType:"address",name:"_receiver",type:"address"},{internalType:"address",name:"_settingOperator",type:"address"},{internalType:"bool",name:"_needTime",type:"bool"},{internalType:"string",name:"_uri",type:"string"},{internalType:"bool",name:"_erc20",type:"bool"}],name:"createToken",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"createToken(uint256,address,address,bool,bool)":{inputs:[{internalType:"uint256",name:"_supply",type:"uint256"},{internalType:"address",name:"_receiver",type:"address"},{internalType:"address",name:"_settingOperator",type:"address"},{internalType:"bool",name:"_needTime",type:"bool"},{internalType:"bool",name:"_erc20",type:"bool"}],name:"createToken",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"createTokenWithRecording(uint256,address,address,bool,address,string,bool)":{inputs:[{internalType:"uint256",name:"_supply",type:"uint256"},{internalType:"address",name:"_receiver",type:"address"},{internalType:"address",name:"_settingOperator",type:"address"},{internalType:"bool",name:"_needTime",type:"bool"},{internalType:"address",name:"_recordingOperator",type:"address"},{internalType:"string",name:"_uri",type:"string"},{internalType:"bool",name:"_erc20",type:"bool"}],name:"createTokenWithRecording",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"createTokenWithRecording(uint256,address,address,bool,address,bool)":{inputs:[{internalType:"uint256",name:"_supply",type:"uint256"},{internalType:"address",name:"_receiver",type:"address"},{internalType:"address",name:"_settingOperator",type:"address"},{internalType:"bool",name:"_needTime",type:"bool"},{internalType:"address",name:"_recordingOperator",type:"address"},{internalType:"bool",name:"_erc20",type:"bool"}],name:"createTokenWithRecording",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"holdingTimeOf(address,uint256)":{inputs:[{internalType:"address",name:"_owner",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"holdingTimeOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"recordingHoldingTimeOf(address,uint256)":{inputs:[{internalType:"address",name:"_owner",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"recordingHoldingTimeOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"setERC20Attribute(uint256,string,string,uint8)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"},{internalType:"string",name:"_name",type:"string"},{internalType:"string",name:"_symbol",type:"string"},{internalType:"uint8",name:"decimals",type:"uint8"}],name:"setERC20Attribute",outputs:[],stateMutability:"nonpayable",type:"function"},"setTimeInterval(uint256,uint128,uint128)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"},{internalType:"uint128",name:"_startTime",type:"uint128"},{internalType:"uint128",name:"_endTime",type:"uint128"}],name:"setTimeInterval",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/interfaces/IWhitelist.sol:IWhitelist":{source:"contracts/interfaces/IWhitelist.sol",name:"IWhitelist",methods:{"addAdmin(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"addAdmin",outputs:[],stateMutability:"nonpayable",type:"function"},"addWhitelist(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"addWhitelist",outputs:[],stateMutability:"nonpayable",type:"function"},"inWhitelist(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"inWhitelist",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isAdmin(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"isAdmin",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"removeAdmin(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"removeAdmin",outputs:[],stateMutability:"nonpayable",type:"function"},"removeWhitelist(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"removeWhitelist",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/libraries/AccessControl.sol:AccessControl":{source:"contracts/libraries/AccessControl.sol",name:"AccessControl",details:'Contract module that allows children to implement role-based access control mechanisms. Roles are referred to by their `bytes32` identifier. These should be exposed in the external API and be unique. The best way to achieve this is by using `public constant` hash digests: ``` bytes32 public constant MY_ROLE = keccak256("MY_ROLE"); ``` Roles can be used to represent a set of permissions. To restrict access to a function call, use {hasRole}: ``` function foo() public {     require(hasRole(MY_ROLE, msg.sender));     ... } ``` Roles can be granted and revoked dynamically via the {grantRole} and {revokeRole} functions. Each role has an associated admin role, and only accounts that have a role\'s admin role can call {grantRole} and {revokeRole}. By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means that only accounts with this role will be able to grant or revoke other roles. More complex role relationships can be created by using {_setRoleAdmin}. WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to grant and revoke this role. Extra precautions should be taken to secure accounts that have been granted it.',events:{"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event",details:"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this. _Available since v3.1._"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event",details:"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {_setupRole}."},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event",details:"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)"}},methods:{"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getRoleMember(bytes32,uint256)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"uint256",name:"index",type:"uint256"}],name:"getRoleMember",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information."},"getRoleMemberCount(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleMemberCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role."},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."}}},"contracts/libraries/GSN/Context.sol:Context":{source:"contracts/libraries/GSN/Context.sol",name:"Context"},"contracts/libraries/Ownable.sol:Ownable":{source:"contracts/libraries/Ownable.sol",name:"Ownable",details:"Contract module which provides a basic access control mechanism, where there is an account (an owner) that can be granted exclusive access to specific functions. By default, the owner account will be the one that deploys the contract. This can later be changed with {transferOwnership}. This module is used through inheritance. It will make available the modifier `onlyOwner`, which can be applied to your functions to restrict their use to the owner.",events:{"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"}},methods:{"acceptOwnership()":{inputs:[],name:"acceptOwnership",outputs:[],stateMutability:"nonpayable",type:"function"},"newOwner()":{inputs:[],name:"newOwner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"transferOwnership(address)":{inputs:[{internalType:"address",name:"_newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},"contracts/libraries/utils/Address.sol:Address":{source:"contracts/libraries/utils/Address.sol",name:"Address",details:"Collection of functions related to the address type"},"contracts/libraries/utils/ECDSA.sol:ECDSA":{source:"contracts/libraries/utils/ECDSA.sol",name:"ECDSA",details:"Elliptic Curve Digital Signature Algorithm (ECDSA) operations. These functions can be used to verify that a message was signed by the holder of the private keys of a given address."},"contracts/libraries/utils/EnumerableSet.sol:EnumerableSet":{source:"contracts/libraries/utils/EnumerableSet.sol",name:"EnumerableSet",details:"Library for managing https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive types. Sets have the following properties: - Elements are added, removed, and checked for existence in constant time (O(1)). - Elements are enumerated in O(n). No guarantees are made on the ordering. ``` contract Example {     // Add the library methods     using EnumerableSet for EnumerableSet.AddressSet;     // Declare a set state variable     EnumerableSet.AddressSet private mySet; } ``` As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`) and `uint256` (`UintSet`) are supported."},"contracts/mock/ERC1155ERC721ReceiverMock.sol:ERC1155ERC721ReceiverMock":{source:"contracts/mock/ERC1155ERC721ReceiverMock.sol",name:"ERC1155ERC721ReceiverMock",events:{"TransferBatchReceiver(address,address,uint256[],uint256[])":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"_from",type:"address"},{indexed:!1,internalType:"address",name:"_to",type:"address"},{indexed:!1,internalType:"uint256[]",name:"_fromBalances",type:"uint256[]"},{indexed:!1,internalType:"uint256[]",name:"_toBalances",type:"uint256[]"}],name:"TransferBatchReceiver",type:"event"},"TransferReceiver(address,address,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"_from",type:"address"},{indexed:!1,internalType:"address",name:"_to",type:"address"},{indexed:!1,internalType:"uint256",name:"_fromBalance",type:"uint256"},{indexed:!1,internalType:"uint256",name:"_toBalance",type:"uint256"},{indexed:!1,internalType:"address",name:"_tokenOwner",type:"address"}],name:"TransferReceiver",type:"event"},"TransferSingleReceiver(address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"_from",type:"address"},{indexed:!1,internalType:"address",name:"_to",type:"address"},{indexed:!1,internalType:"uint256",name:"_fromBalance",type:"uint256"},{indexed:!1,internalType:"uint256",name:"_toBalance",type:"uint256"}],name:"TransferSingleReceiver",type:"event"}},methods:{"lastData()":{inputs:[],name:"lastData",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"view",type:"function"},"lastId()":{inputs:[],name:"lastId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"lastOperator()":{inputs:[],name:"lastOperator",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"lastValue()":{inputs:[],name:"lastValue",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"_from",type:"address"},{internalType:"uint256[]",name:"_ids",type:"uint256[]"},{internalType:"uint256[]",name:"",type:"uint256[]"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"onERC1155BatchReceived",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function",details:"An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated. This function MAY throw to revert and reject the transfer. Return of other than the magic value WILL result in the transaction being reverted. Note: The contract address is always the message sender.",params:{_data:"Additional data with no specified format",_from:"The address which previously owned the token",_ids:"An array containing ids of each token being transferred"},returns:{_0:'`bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`'},notice:"Handle the receipt of multiple ERC1155 token types."},"onERC1155Received(address,address,uint256,uint256,bytes)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"_from",type:"address"},{internalType:"uint256",name:"_id",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"onERC1155Received",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function",details:"An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated. This function MAY throw to revert and reject the transfer. Return of other than the magic value MUST result in the transaction being reverted. Note: The contract address is always the message sender.",params:{_data:"Additional data with no specified format",_from:"The address which previously owned the token",_id:"The id of the token being transferred"},returns:{_0:'`bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`'},notice:"Handle the receipt of a single ERC1155 token type."},"onERC721Received(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"_from",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"onERC721Received",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function",details:"An ERC721-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated. This function MAY throw to revert and reject the transfer. Return of other than the magic value MUST result in the transaction being reverted. Note: The contract address is always the message sender.",params:{_data:"Additional data with no specified format",_from:"The address which previously owned the token",_tokenId:"The token id"},returns:{_0:'`bytes4(keccak256("onERC721Received(address,address,uint256,uint256,bytes)"))`'},notice:"Handle the receipt of a single ERC721 token type."},"setShouldReject(bool)":{inputs:[{internalType:"bool",name:"_value",type:"bool"}],name:"setShouldReject",outputs:[],stateMutability:"nonpayable",type:"function"},"shouldReject()":{inputs:[],name:"shouldReject",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceID",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"pure",type:"function",details:"This function MUST return true if it implements the ERC1155TokenReceiver interface and ERC-165 interface.      This function MUST NOT consume more than 5,000 gas.",params:{interfaceID:"The ERC-165 interface ID that is queried for support.s"},returns:{_0:"Wheter ERC-165 or ERC1155TokenReceiver interfaces are supported."},notice:"Indicates whether a contract implements the `ERC1155TokenReceiver` functions and so can accept ERC1155 token types."}}},"contracts/mock/ERC1155ReceiverMock.sol:ERC1155ReceiverMock":{source:"contracts/mock/ERC1155ReceiverMock.sol",name:"ERC1155ReceiverMock",events:{"TransferBatchReceiver(address,address,uint256[],uint256[])":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"_from",type:"address"},{indexed:!1,internalType:"address",name:"_to",type:"address"},{indexed:!1,internalType:"uint256[]",name:"_fromBalances",type:"uint256[]"},{indexed:!1,internalType:"uint256[]",name:"_toBalances",type:"uint256[]"}],name:"TransferBatchReceiver",type:"event"},"TransferSingleReceiver(address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"_from",type:"address"},{indexed:!1,internalType:"address",name:"_to",type:"address"},{indexed:!1,internalType:"uint256",name:"_fromBalance",type:"uint256"},{indexed:!1,internalType:"uint256",name:"_toBalance",type:"uint256"}],name:"TransferSingleReceiver",type:"event"}},methods:{"lastData()":{inputs:[],name:"lastData",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"view",type:"function"},"lastId()":{inputs:[],name:"lastId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"lastOperator()":{inputs:[],name:"lastOperator",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"lastValue()":{inputs:[],name:"lastValue",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"_from",type:"address"},{internalType:"uint256[]",name:"_ids",type:"uint256[]"},{internalType:"uint256[]",name:"",type:"uint256[]"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"onERC1155BatchReceived",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function",details:"An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated. This function MAY throw to revert and reject the transfer. Return of other than the magic value WILL result in the transaction being reverted. Note: The contract address is always the message sender.",params:{_data:"Additional data with no specified format",_from:"The address which previously owned the token",_ids:"An array containing ids of each token being transferred"},returns:{_0:'`bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`'},notice:"Handle the receipt of multiple ERC1155 token types."},"onERC1155Received(address,address,uint256,uint256,bytes)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"_from",type:"address"},{internalType:"uint256",name:"_id",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"onERC1155Received",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function",details:"An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated. This function MAY throw to revert and reject the transfer. Return of other than the magic value MUST result in the transaction being reverted. Note: The contract address is always the message sender.",params:{_data:"Additional data with no specified format",_from:"The address which previously owned the token",_id:"The id of the token being transferred"},returns:{_0:'`bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`'},notice:"Handle the receipt of a single ERC1155 token type."},"setShouldReject(bool)":{inputs:[{internalType:"bool",name:"_value",type:"bool"}],name:"setShouldReject",outputs:[],stateMutability:"nonpayable",type:"function"},"shouldReject()":{inputs:[],name:"shouldReject",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceID",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"pure",type:"function",details:"This function MUST return true if it implements the ERC1155TokenReceiver interface and ERC-165 interface.      This function MUST NOT consume more than 5,000 gas.",params:{interfaceID:"The ERC-165 interface ID that is queried for support.s"},returns:{_0:"Wheter ERC-165 or ERC1155TokenReceiver interfaces are supported."},notice:"Indicates whether a contract implements the `ERC1155TokenReceiver` functions and so can accept ERC1155 token types."}}},"contracts/mock/ERC721ReceiverMock.sol:ERC721ReceiverMock":{source:"contracts/mock/ERC721ReceiverMock.sol",name:"ERC721ReceiverMock",events:{"TransferReceiver(address,address,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"_from",type:"address"},{indexed:!1,internalType:"address",name:"_to",type:"address"},{indexed:!1,internalType:"uint256",name:"_fromBalance",type:"uint256"},{indexed:!1,internalType:"uint256",name:"_toBalance",type:"uint256"},{indexed:!1,internalType:"address",name:"_tokenOwner",type:"address"}],name:"TransferReceiver",type:"event"}},methods:{"lastData()":{inputs:[],name:"lastData",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"view",type:"function"},"lastId()":{inputs:[],name:"lastId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"lastOperator()":{inputs:[],name:"lastOperator",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"lastValue()":{inputs:[],name:"lastValue",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"onERC721Received(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"_from",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"onERC721Received",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function",details:"An ERC721-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated. This function MAY throw to revert and reject the transfer. Return of other than the magic value MUST result in the transaction being reverted. Note: The contract address is always the message sender.",params:{_data:"Additional data with no specified format",_from:"The address which previously owned the token",_tokenId:"The token id"},returns:{_0:'`bytes4(keccak256("onERC721Received(address,address,uint256,uint256,bytes)"))`'},notice:"Handle the receipt of a single ERC721 token type."},"setShouldReject(bool)":{inputs:[{internalType:"bool",name:"_value",type:"bool"}],name:"setShouldReject",outputs:[],stateMutability:"nonpayable",type:"function"},"shouldReject()":{inputs:[],name:"shouldReject",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceID",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"pure",type:"function",details:"This function MUST return true if it implements the ERC721TokenReceiver interface and ERC-165 interface.      This function MUST NOT consume more than 5,000 gas.",params:{interfaceID:"The ERC-165 interface ID that is queried for support.s"},returns:{_0:"Wheter ERC-165 or ERC721TokenReceiver interfaces are supported."},notice:"Indicates whether a contract implements the `ERC721TokenReceiver` functions and so can accept ERC721 token types."}}},"contracts/mock/Empty.sol:Empty":{source:"contracts/mock/Empty.sol",name:"Empty"},"contracts/mock/InvoiceFactoryMock.sol:InvoiceFactoryMock":{source:"contracts/mock/InvoiceFactoryMock.sol",name:"InvoiceFactoryMock",constructor:{inputs:[{internalType:"uint8",name:"_decimals",type:"uint8"},{internalType:"address",name:"_trustAddress",type:"address"},{internalType:"address",name:"_trustedForwarder",type:"address"},{internalType:"address",name:"_tokenFactory",type:"address"},{internalType:"address",name:"_whitelist",type:"address"}],stateMutability:"nonpayable",type:"constructor"},events:{"AnchorVerifyInvoice(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_anchor",type:"address"},{indexed:!0,internalType:"uint256",name:"_invoiceId",type:"uint256"}],name:"AnchorVerifyInvoice",type:"event"},"CreateTokenFromInvoice(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"_invoiceId",type:"uint256"},{indexed:!0,internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"CreateTokenFromInvoice",type:"event"},"EnrollAdmin(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_admin",type:"address"}],name:"EnrollAdmin",type:"event"},"EnrollAnchor(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_anchor",type:"address"}],name:"EnrollAnchor",type:"event"},"EnrollSupplier(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_supplier",type:"address"}],name:"EnrollSupplier",type:"event"},"MsgData(bytes,bytes)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bytes",name:"_msgData",type:"bytes"},{indexed:!1,internalType:"bytes",name:"_realData",type:"bytes"}],name:"MsgData",type:"event"},"MsgSender(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_msgSender",type:"address"},{indexed:!0,internalType:"address",name:"_realSender",type:"address"}],name:"MsgSender",type:"event"},"RelayCall(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_sender",type:"address"}],name:"RelayCall",type:"event"},"RemoveAdmin(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_admin",type:"address"}],name:"RemoveAdmin",type:"event"},"RestoreAccount(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_originAddress",type:"address"},{indexed:!0,internalType:"address",name:"_newAddress",type:"address"}],name:"RestoreAccount",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"},"TrustVerifyAnchor(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_anchor",type:"address"}],name:"TrustVerifyAnchor",type:"event"},"TrustVerifySupplier(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_supplier",type:"address"}],name:"TrustVerifySupplier",type:"event"},"UploadInvoice(uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"_invoiceId",type:"uint256"},{indexed:!0,internalType:"address",name:"_supplier",type:"address"},{indexed:!0,internalType:"address",name:"_anchor",type:"address"}],name:"UploadInvoice",type:"event"}},methods:{"ANCHOR_ROLE()":{inputs:[],name:"ANCHOR_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"SUPPLIER_ROLE()":{inputs:[],name:"SUPPLIER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"__initialize(uint8,address,address,address,address)":{inputs:[{internalType:"uint8",name:"_decimals",type:"uint8"},{internalType:"address",name:"_trustAddress",type:"address"},{internalType:"address",name:"_trustedForwarder",type:"address"},{internalType:"address",name:"_tokenFactory",type:"address"},{internalType:"address",name:"_whitelist",type:"address"}],name:"__initialize",outputs:[],stateMutability:"nonpayable",type:"function"},"anchorVerifyInvoice(uint256)":{inputs:[{internalType:"uint256",name:"_invoiceId",type:"uint256"}],name:"anchorVerifyInvoice",outputs:[],stateMutability:"nonpayable",type:"function",details:"It emits `AnchorVerifyInvoice` if successful",params:{_invoiceId:"Invoice to be verified"},notice:"For anchor to verify an invoice"},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"enrollAdmin(address)":{inputs:[{internalType:"address",name:"_newAdmin",type:"address"}],name:"enrollAdmin",outputs:[],stateMutability:"nonpayable",type:"function",details:"It throws if `_newAdmin` has already enrolled, otherwise  it emits `EnrollAdmin` if successful",params:{_newAdmin:"Address of admin"},notice:"Enroll admin"},"enrollAnchor(address)":{inputs:[{internalType:"address",name:"_newAnchor",type:"address"}],name:"enrollAnchor",outputs:[],stateMutability:"nonpayable",type:"function",details:"It throws if `_newAnchor` has already enrolled, otherwise  it emits `EnrollAnchor` if successful",params:{_newAnchor:"Address of anchor"},notice:"Enroll anchor"},"enrollSupplier(address)":{inputs:[{internalType:"address",name:"_newSupplier",type:"address"}],name:"enrollSupplier",outputs:[],stateMutability:"nonpayable",type:"function",details:"It throws if `_newSupplier` has already enrolled, otherwise  it emitn `EnrollSupplier` if successful",params:{_newSupplier:"Address of supplier "},notice:"Enroll supplier"},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getRoleMember(bytes32,uint256)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"uint256",name:"index",type:"uint256"}],name:"getRoleMember",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information."},"getRoleMemberCount(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleMemberCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role."},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"invoiceCount()":{inputs:[],name:"invoiceCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"invoiceToToken(uint256)":{inputs:[{internalType:"uint256",name:"_invoiceId",type:"uint256"}],name:"invoiceToToken",outputs:[],stateMutability:"nonpayable",type:"function",details:"It throws if `msg.sender` is not admin, invoice hasn't  been confirmed by anchor or token has created before.  It emits `CreateTokenFromInvioce` if successful",params:{_invoiceId:"Invoice ID"},notice:"Create a token for invoice"},"isAnchor(address)":{inputs:[{internalType:"address",name:"_anchor",type:"address"}],name:"isAnchor",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{_anchor:"Address"},returns:{_0:"`true` if it has anchor role"},notice:"Check anchor role"},"isSupplier(address)":{inputs:[{internalType:"address",name:"_supplier",type:"address"}],name:"isSupplier",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{_supplier:"Address"},returns:{_0:"`true` if it has supplier role"},notice:"Check supplier role"},"isTrustedForwarder(address)":{inputs:[{internalType:"address",name:"forwarder",type:"address"}],name:"isTrustedForwarder",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"return if the forwarder is trusted to forward relayed transactions to us. the forwarder is required to verify the sender's signature, and verify the call is not a replay."},"msgData()":{inputs:[],name:"msgData",outputs:[{internalType:"bytes",name:"",type:"bytes"},{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"nonpayable",type:"function"},"msgSender()":{inputs:[],name:"msgSender",outputs:[{internalType:"address payable",name:"",type:"address"}],stateMutability:"nonpayable",type:"function"},"queryAnchorVerified(address)":{inputs:[{internalType:"address",name:"_anchor",type:"address"}],name:"queryAnchorVerified",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"It returns zero if anchor is not verified",params:{_anchor:"Address of the anchor"},returns:{_0:"Timestamp of verification"},notice:"Queries the timestamp when the anchor is verified by trust"},"queryInvoice(uint256)":{inputs:[{internalType:"uint256",name:"_invoiceId",type:"uint256"}],name:"queryInvoice",outputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"bytes32",name:"",type:"bytes32"},{internalType:"bytes32",name:"",type:"bytes32"},{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",params:{_invoiceId:"Invoice ID to be queried"},returns:{_0:"Invoice ID",_1:"Invoice issuance time",_2:"Invoice amount",_3:"Invoice due date",_4:"Hash of the invoice pdf",_5:"Hash of the invoice number",_6:"Hash of the anchor name"},notice:"Queries the invoice information uploaded by supplier"},"queryInvoiceData(uint256)":{inputs:[{internalType:"uint256",name:"_invoiceId",type:"uint256"}],name:"queryInvoiceData",outputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"bytes32",name:"",type:"bytes32"},{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",params:{_invoiceId:"Invoice ID to be queried"},returns:{_0:"Corresponding Token ID, zero if does not have token",_1:"Interest rate",_2:"Address of the supplier",_3:"Address of the anchor "},notice:"Queries the invoice derivative information"},"queryInvoiceId(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"queryInvoiceId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"It throws if `_tokenId` is zero or does not have a  correcsponding invoice",params:{_tokenId:"Token ID"},returns:{_0:"Invoice ID"},notice:"Queries invoice ID by its correcponding token ID"},"querySupplierVerified(address)":{inputs:[{internalType:"address",name:"_supplier",type:"address"}],name:"querySupplierVerified",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"It returns zero if supplier is not verified",params:{_supplier:"Address of the supplier "},returns:{_0:"Timestamp of verification"},notice:"Queries the timestamp when the supplier is verified by trust"},"queryTokenId(uint256)":{inputs:[{internalType:"uint256",name:"_invoiceId",type:"uint256"}],name:"queryTokenId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"It throws if invoice does not have token creation history",params:{_invoiceId:"Invoice ID"},returns:{_0:"Token ID"},notice:"Queries token ID by its correcponding invoice ID"},"relayCall()":{inputs:[],name:"relayCall",outputs:[],stateMutability:"nonpayable",type:"function"},"removeAdmin(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"removeAdmin",outputs:[],stateMutability:"nonpayable",type:"function",details:"It throws if `_account` not in admin role, otherwise  it emits `RemoveAdmin` if successful",params:{_account:"Address to admin"},notice:"Remove an address from admin role"},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"restoreAccount(address,address)":{inputs:[{internalType:"address",name:"_originAddress",type:"address"},{internalType:"address",name:"_newAddress",type:"address"}],name:"restoreAccount",outputs:[],stateMutability:"nonpayable",type:"function",details:"This function can only be accessed by admin. It emits  `RestoreAccount` if successful",params:{_newAddress:"New address",_originAddress:"Original address"},notice:"Set a new address for anchor or supplier"},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."},"setTimeInterval(uint256,uint128,uint128)":{inputs:[{internalType:"uint256",name:"_invoiceId",type:"uint256"},{internalType:"uint128",name:"_startTime",type:"uint128"},{internalType:"uint128",name:"_endTime",type:"uint128"}],name:"setTimeInterval",outputs:[],stateMutability:"nonpayable",type:"function",details:"This function can only be accessed by trust",params:{_endTime:"Ending time in unix time format",_invoiceId:"Invoice ID",_startTime:"Starting time in unix time format"},notice:"Set time interval for token holding time calculation "},"tokenFactory()":{inputs:[],name:"tokenFactory",outputs:[{internalType:"contract ITokenFactory",name:"",type:"address"}],stateMutability:"view",type:"function"},"trustAddress()":{inputs:[],name:"trustAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"trustVerifyAnchor(address)":{inputs:[{internalType:"address",name:"_anchor",type:"address"}],name:"trustVerifyAnchor",outputs:[],stateMutability:"nonpayable",type:"function",details:"It emits `TrustVerifyAnchor` if successful",params:{_anchor:"Address of anchor"},notice:"Trust verify anchor"},"trustVerifySupplier(address)":{inputs:[{internalType:"address",name:"_supplier",type:"address"}],name:"trustVerifySupplier",outputs:[],stateMutability:"nonpayable",type:"function",details:"It emits `TrustVerifySupplier` if successful",params:{_supplier:"Address of supplier "},notice:"Trust verify supplier "},"trustedForwarder()":{inputs:[],name:"trustedForwarder",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"updateTokenFactory(address)":{inputs:[{internalType:"address",name:"_newTokenFactory",type:"address"}],name:"updateTokenFactory",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newTokenFactory:"New token factory address"},notice:"Update token factory address"},"updateTrustAddress(address)":{inputs:[{internalType:"address",name:"_newTrust",type:"address"}],name:"updateTrustAddress",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newTrust:"New trust address"},notice:"Update trust address"},"updateWhitelist(address)":{inputs:[{internalType:"address",name:"_newWhitelist",type:"address"}],name:"updateWhitelist",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newWhitelist:"New whitelist address"},notice:"Update whitelist address"},"uploadInvoice(uint256,uint256,bytes32,bytes32,bytes32,bytes32,address,bytes)":{inputs:[{internalType:"uint256",name:"_invoiceAmount",type:"uint256"},{internalType:"uint256",name:"_time",type:"uint256"},{internalType:"bytes32",name:"_interestRate",type:"bytes32"},{internalType:"bytes32",name:"_invoicePdfHash",type:"bytes32"},{internalType:"bytes32",name:"_invoiceNumberHash",type:"bytes32"},{internalType:"bytes32",name:"_anchorHash",type:"bytes32"},{internalType:"address",name:"_anchorAddr",type:"address"},{internalType:"bytes",name:"_signature",type:"bytes"}],name:"uploadInvoice",outputs:[],stateMutability:"nonpayable",type:"function",details:"It emits `UploadInvoice` if successful",params:{_anchorAddr:"Address of anchor",_anchorHash:"Hash of the anchor name",_interestRate:"Interest rate",_invoiceAmount:"Invoice Amount",_invoiceNumberHash:"Hash of the invoice number",_invoicePdfHash:"Hash of the invoice pdf",_signature:"Admin signature",_time:"The first(high) 128-bit is issuance time of invoice,  the last(low) 128-bit is due date"},notice:"Upload an invoice by supplier"},"uploadPreSignedHash(uint256,uint256,bytes32,bytes32,bytes32,bytes32,address,address)":{inputs:[{internalType:"uint256",name:"_invoiceAmount",type:"uint256"},{internalType:"uint256",name:"_time",type:"uint256"},{internalType:"bytes32",name:"_interestRate",type:"bytes32"},{internalType:"bytes32",name:"_invoicePdfHash",type:"bytes32"},{internalType:"bytes32",name:"_invoiceNumberHash",type:"bytes32"},{internalType:"bytes32",name:"_anchorHash",type:"bytes32"},{internalType:"address",name:"_supplierAddr",type:"address"},{internalType:"address",name:"_anchorAddr",type:"address"}],name:"uploadPreSignedHash",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"pure",type:"function",params:{_anchorAddr:"Address of anchor",_anchorHash:"Hash of the anchor name",_interestRate:"Interest rate",_invoiceAmount:"Invoice Amount",_invoiceNumberHash:"Hash of the invoice number",_invoicePdfHash:"Hash of the invoice pdf",_supplierAddr:"Address of supplier ",_time:"The first(high) 128-bit is issuance time of invoice,  the last(low) 128-bit is due date"},notice:"Hash invoice"},"versionRecipient()":{inputs:[],name:"versionRecipient",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"whitelist()":{inputs:[],name:"whitelist",outputs:[{internalType:"contract IWhitelist",name:"",type:"address"}],stateMutability:"view",type:"function"}}},"contracts/mock/InvoiceFactoryUpgradeNew.sol:InvoiceFactoryUpgradeNew":{source:"contracts/mock/InvoiceFactoryUpgradeNew.sol",name:"InvoiceFactoryUpgradeNew",events:{"AnchorVerifyInvoice(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_anchor",type:"address"},{indexed:!0,internalType:"uint256",name:"_invoiceId",type:"uint256"}],name:"AnchorVerifyInvoice",type:"event"},"CreateTokenFromInvoice(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"_invoiceId",type:"uint256"},{indexed:!0,internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"CreateTokenFromInvoice",type:"event"},"EnrollAdmin(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_admin",type:"address"}],name:"EnrollAdmin",type:"event"},"EnrollAnchor(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_anchor",type:"address"}],name:"EnrollAnchor",type:"event"},"EnrollSupplier(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_supplier",type:"address"}],name:"EnrollSupplier",type:"event"},"RemoveAdmin(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_admin",type:"address"}],name:"RemoveAdmin",type:"event"},"RestoreAccount(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_originAddress",type:"address"},{indexed:!0,internalType:"address",name:"_newAddress",type:"address"}],name:"RestoreAccount",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"},"TrustVerifyAnchor(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_anchor",type:"address"}],name:"TrustVerifyAnchor",type:"event"},"TrustVerifySupplier(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_supplier",type:"address"}],name:"TrustVerifySupplier",type:"event"},"UploadInvoice(uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"_invoiceId",type:"uint256"},{indexed:!0,internalType:"address",name:"_supplier",type:"address"},{indexed:!0,internalType:"address",name:"_anchor",type:"address"}],name:"UploadInvoice",type:"event"}},methods:{"ANCHOR_ROLE()":{inputs:[],name:"ANCHOR_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"SUPPLIER_ROLE()":{inputs:[],name:"SUPPLIER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"__initialize(uint8,address,address,address,address)":{inputs:[{internalType:"uint8",name:"_decimals",type:"uint8"},{internalType:"address",name:"_trustAddress",type:"address"},{internalType:"address",name:"_trustedForwarder",type:"address"},{internalType:"address",name:"_tokenFactory",type:"address"},{internalType:"address",name:"_whitelist",type:"address"}],name:"__initialize",outputs:[],stateMutability:"nonpayable",type:"function"},"anchorVerifyInvoice(uint256)":{inputs:[{internalType:"uint256",name:"_invoiceId",type:"uint256"}],name:"anchorVerifyInvoice",outputs:[],stateMutability:"nonpayable",type:"function",details:"It emits `AnchorVerifyInvoice` if successful",params:{_invoiceId:"Invoice to be verified"},notice:"For anchor to verify an invoice"},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"enrollAdmin(address)":{inputs:[{internalType:"address",name:"_newAdmin",type:"address"}],name:"enrollAdmin",outputs:[],stateMutability:"nonpayable",type:"function",details:"It throws if `_newAdmin` has already enrolled, otherwise  it emits `EnrollAdmin` if successful",params:{_newAdmin:"Address of admin"},notice:"Enroll admin"},"enrollAnchor(address)":{inputs:[{internalType:"address",name:"_newAnchor",type:"address"}],name:"enrollAnchor",outputs:[],stateMutability:"nonpayable",type:"function",details:"It throws if `_newAnchor` has already enrolled, otherwise  it emits `EnrollAnchor` if successful",params:{_newAnchor:"Address of anchor"},notice:"Enroll anchor"},"enrollSupplier(address)":{inputs:[{internalType:"address",name:"_newSupplier",type:"address"}],name:"enrollSupplier",outputs:[],stateMutability:"nonpayable",type:"function",details:"It throws if `_newSupplier` has already enrolled, otherwise  it emitn `EnrollSupplier` if successful",params:{_newSupplier:"Address of supplier "},notice:"Enroll supplier"},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getRoleMember(bytes32,uint256)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"uint256",name:"index",type:"uint256"}],name:"getRoleMember",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information."},"getRoleMemberCount(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleMemberCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role."},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"invoiceCount()":{inputs:[],name:"invoiceCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"invoiceToToken(uint256)":{inputs:[{internalType:"uint256",name:"_invoiceId",type:"uint256"}],name:"invoiceToToken",outputs:[],stateMutability:"nonpayable",type:"function",details:"It throws if `msg.sender` is not admin, invoice hasn't  been confirmed by anchor or token has created before.  It emits `CreateTokenFromInvioce` if successful",params:{_invoiceId:"Invoice ID"},notice:"Create a token for invoice"},"isAnchor(address)":{inputs:[{internalType:"address",name:"_anchor",type:"address"}],name:"isAnchor",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{_anchor:"Address"},returns:{_0:"`true` if it has anchor role"},notice:"Check anchor role"},"isSupplier(address)":{inputs:[{internalType:"address",name:"_supplier",type:"address"}],name:"isSupplier",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{_supplier:"Address"},returns:{_0:"`true` if it has supplier role"},notice:"Check supplier role"},"isTrustedForwarder(address)":{inputs:[{internalType:"address",name:"forwarder",type:"address"}],name:"isTrustedForwarder",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"return if the forwarder is trusted to forward relayed transactions to us. the forwarder is required to verify the sender's signature, and verify the call is not a replay."},"newTokenFactoryWhitelist(address,address)":{inputs:[{internalType:"address",name:"_newTokenFactory",type:"address"},{internalType:"address",name:"_newWhitelist",type:"address"}],name:"newTokenFactoryWhitelist",outputs:[],stateMutability:"nonpayable",type:"function"},"queryAnchorVerified(address)":{inputs:[{internalType:"address",name:"_anchor",type:"address"}],name:"queryAnchorVerified",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"It returns zero if anchor is not verified",params:{_anchor:"Address of the anchor"},returns:{_0:"Timestamp of verification"},notice:"Queries the timestamp when the anchor is verified by trust"},"queryInvoice(uint256)":{inputs:[{internalType:"uint256",name:"_invoiceId",type:"uint256"}],name:"queryInvoice",outputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"bytes32",name:"",type:"bytes32"},{internalType:"bytes32",name:"",type:"bytes32"},{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",params:{_invoiceId:"Invoice ID to be queried"},returns:{_0:"Invoice ID",_1:"Invoice issuance time",_2:"Invoice amount",_3:"Invoice due date",_4:"Hash of the invoice pdf",_5:"Hash of the invoice number",_6:"Hash of the anchor name"},notice:"Queries the invoice information uploaded by supplier"},"queryInvoiceData(uint256)":{inputs:[{internalType:"uint256",name:"_invoiceId",type:"uint256"}],name:"queryInvoiceData",outputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"bytes32",name:"",type:"bytes32"},{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",params:{_invoiceId:"Invoice ID to be queried"},returns:{_0:"Corresponding Token ID, zero if does not have token",_1:"Interest rate",_2:"Address of the supplier",_3:"Address of the anchor "},notice:"Queries the invoice derivative information"},"queryInvoiceId(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"queryInvoiceId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"It throws if `_tokenId` is zero or does not have a  correcsponding invoice",params:{_tokenId:"Token ID"},returns:{_0:"Invoice ID"},notice:"Queries invoice ID by its correcponding token ID"},"querySupplierVerified(address)":{inputs:[{internalType:"address",name:"_supplier",type:"address"}],name:"querySupplierVerified",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"It returns zero if supplier is not verified",params:{_supplier:"Address of the supplier "},returns:{_0:"Timestamp of verification"},notice:"Queries the timestamp when the supplier is verified by trust"},"queryTokenId(uint256)":{inputs:[{internalType:"uint256",name:"_invoiceId",type:"uint256"}],name:"queryTokenId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"It throws if invoice does not have token creation history",params:{_invoiceId:"Invoice ID"},returns:{_0:"Token ID"},notice:"Queries token ID by its correcponding invoice ID"},"removeAdmin(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"removeAdmin",outputs:[],stateMutability:"nonpayable",type:"function",details:"It throws if `_account` not in admin role, otherwise  it emits `RemoveAdmin` if successful",params:{_account:"Address to admin"},notice:"Remove an address from admin role"},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"restoreAccount(address,address)":{inputs:[{internalType:"address",name:"_originAddress",type:"address"},{internalType:"address",name:"_newAddress",type:"address"}],name:"restoreAccount",outputs:[],stateMutability:"nonpayable",type:"function",details:"This function can only be accessed by admin. It emits  `RestoreAccount` if successful",params:{_newAddress:"New address",_originAddress:"Original address"},notice:"Set a new address for anchor or supplier"},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."},"setTimeInterval(uint256,uint128,uint128)":{inputs:[{internalType:"uint256",name:"_invoiceId",type:"uint256"},{internalType:"uint128",name:"_startTime",type:"uint128"},{internalType:"uint128",name:"_endTime",type:"uint128"}],name:"setTimeInterval",outputs:[],stateMutability:"nonpayable",type:"function",details:"This function can only be accessed by trust",params:{_endTime:"Ending time in unix time format",_invoiceId:"Invoice ID",_startTime:"Starting time in unix time format"},notice:"Set time interval for token holding time calculation "},"tokenFactory()":{inputs:[],name:"tokenFactory",outputs:[{internalType:"contract ITokenFactory",name:"",type:"address"}],stateMutability:"view",type:"function"},"trustAddress()":{inputs:[],name:"trustAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"trustVerifyAnchor(address)":{inputs:[{internalType:"address",name:"_anchor",type:"address"}],name:"trustVerifyAnchor",outputs:[],stateMutability:"nonpayable",type:"function",details:"It emits `TrustVerifyAnchor` if successful",params:{_anchor:"Address of anchor"},notice:"Trust verify anchor"},"trustVerifySupplier(address)":{inputs:[{internalType:"address",name:"_supplier",type:"address"}],name:"trustVerifySupplier",outputs:[],stateMutability:"nonpayable",type:"function",details:"It emits `TrustVerifySupplier` if successful",params:{_supplier:"Address of supplier "},notice:"Trust verify supplier "},"trustedForwarder()":{inputs:[],name:"trustedForwarder",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"updateTokenFactory(address)":{inputs:[{internalType:"address",name:"_newTokenFactory",type:"address"}],name:"updateTokenFactory",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newTokenFactory:"New token factory address"},notice:"Update token factory address"},"updateTrustAddress(address)":{inputs:[{internalType:"address",name:"_newTrust",type:"address"}],name:"updateTrustAddress",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newTrust:"New trust address"},notice:"Update trust address"},"updateWhitelist(address)":{inputs:[{internalType:"address",name:"_newWhitelist",type:"address"}],name:"updateWhitelist",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newWhitelist:"New whitelist address"},notice:"Update whitelist address"},"uploadInvoice(uint256,uint256,bytes32,bytes32,bytes32,bytes32,address,bytes)":{inputs:[{internalType:"uint256",name:"_invoiceAmount",type:"uint256"},{internalType:"uint256",name:"_time",type:"uint256"},{internalType:"bytes32",name:"_interestRate",type:"bytes32"},{internalType:"bytes32",name:"_invoicePdfHash",type:"bytes32"},{internalType:"bytes32",name:"_invoiceNumberHash",type:"bytes32"},{internalType:"bytes32",name:"_anchorHash",type:"bytes32"},{internalType:"address",name:"_anchorAddr",type:"address"},{internalType:"bytes",name:"_signature",type:"bytes"}],name:"uploadInvoice",outputs:[],stateMutability:"nonpayable",type:"function",details:"It emits `UploadInvoice` if successful",params:{_anchorAddr:"Address of anchor",_anchorHash:"Hash of the anchor name",_interestRate:"Interest rate",_invoiceAmount:"Invoice Amount",_invoiceNumberHash:"Hash of the invoice number",_invoicePdfHash:"Hash of the invoice pdf",_signature:"Admin signature",_time:"The first(high) 128-bit is issuance time of invoice,  the last(low) 128-bit is due date"},notice:"Upload an invoice by supplier"},"uploadPreSignedHash(uint256,uint256,bytes32,bytes32,bytes32,bytes32,address,address)":{inputs:[{internalType:"uint256",name:"_invoiceAmount",type:"uint256"},{internalType:"uint256",name:"_time",type:"uint256"},{internalType:"bytes32",name:"_interestRate",type:"bytes32"},{internalType:"bytes32",name:"_invoicePdfHash",type:"bytes32"},{internalType:"bytes32",name:"_invoiceNumberHash",type:"bytes32"},{internalType:"bytes32",name:"_anchorHash",type:"bytes32"},{internalType:"address",name:"_supplierAddr",type:"address"},{internalType:"address",name:"_anchorAddr",type:"address"}],name:"uploadPreSignedHash",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"pure",type:"function",params:{_anchorAddr:"Address of anchor",_anchorHash:"Hash of the anchor name",_interestRate:"Interest rate",_invoiceAmount:"Invoice Amount",_invoiceNumberHash:"Hash of the invoice number",_invoicePdfHash:"Hash of the invoice pdf",_supplierAddr:"Address of supplier ",_time:"The first(high) 128-bit is issuance time of invoice,  the last(low) 128-bit is due date"},notice:"Hash invoice"},"versionRecipient()":{inputs:[],name:"versionRecipient",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"whitelist()":{inputs:[],name:"whitelist",outputs:[{internalType:"contract IWhitelist",name:"",type:"address"}],stateMutability:"view",type:"function"}}},"contracts/mock/TokenFactoryMock.sol:TokenFactoryMock":{source:"contracts/mock/TokenFactoryMock.sol",name:"TokenFactoryMock",constructor:{inputs:[{internalType:"address",name:"_trustedForwarder",type:"address"}],stateMutability:"nonpayable",type:"constructor"},events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_owner",type:"address"},{indexed:!0,internalType:"address",name:"_approved",type:"address"},{indexed:!0,internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"Approval",type:"event"},"ApprovalForAll(address,address,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_owner",type:"address"},{indexed:!0,internalType:"address",name:"_operator",type:"address"},{indexed:!1,internalType:"bool",name:"_approved",type:"bool"}],name:"ApprovalForAll",type:"event"},"MsgData(bytes,bytes)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bytes",name:"_msgData",type:"bytes"},{indexed:!1,internalType:"bytes",name:"_realData",type:"bytes"}],name:"MsgData",type:"event"},"MsgSender(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_msgSender",type:"address"},{indexed:!0,internalType:"address",name:"_realSender",type:"address"}],name:"MsgSender",type:"event"},"NewAdapter(uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"_tokenId",type:"uint256"},{indexed:!0,internalType:"address",name:"_adapter",type:"address"}],name:"NewAdapter",type:"event"},"RecordingTransferSingle(address,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"_operator",type:"address"},{indexed:!0,internalType:"address",name:"_from",type:"address"},{indexed:!0,internalType:"address",name:"_to",type:"address"},{indexed:!0,internalType:"uint256",name:"_tokenId",type:"uint256"},{indexed:!1,internalType:"uint256",name:"_value",type:"uint256"}],name:"RecordingTransferSingle",type:"event"},"RelayCall(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_sender",type:"address"}],name:"RelayCall",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_from",type:"address"},{indexed:!0,internalType:"address",name:"_to",type:"address"},{indexed:!0,internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"Transfer",type:"event"},"TransferBatch(address,address,address,uint256[],uint256[])":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_operator",type:"address"},{indexed:!0,internalType:"address",name:"_from",type:"address"},{indexed:!0,internalType:"address",name:"_to",type:"address"},{indexed:!1,internalType:"uint256[]",name:"_tokenIds",type:"uint256[]"},{indexed:!1,internalType:"uint256[]",name:"_values",type:"uint256[]"}],name:"TransferBatch",type:"event"},"TransferSingle(address,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"_operator",type:"address"},{indexed:!0,internalType:"address",name:"_from",type:"address"},{indexed:!0,internalType:"address",name:"_to",type:"address"},{indexed:!1,internalType:"uint256",name:"_tokenId",type:"uint256"},{indexed:!1,internalType:"uint256",name:"_value",type:"uint256"}],name:"TransferSingle",type:"event"},"URI(string,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"string",name:"_value",type:"string"},{indexed:!0,internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"URI",type:"event"}},methods:{"approve(address,uint256)":{inputs:[{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"approve",outputs:[],stateMutability:"nonpayable",type:"function",details:"The zero address indicates there is no approved address.  Throws unless `msg.sender` is the current NFT owner, or an authorized  operator of the current owner.",params:{_to:"The new approved NFT controller",_tokenId:"The NFT to approve"},notice:"Change or reaffirm the approved address for an NFT"},"balanceOf(address,uint256)":{inputs:[{internalType:"address",name:"_owner",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"It accept both ",params:{_owner:"The address of the token holder",_tokenId:"ID of the Token"},returns:{_0:"The _owner's balance of the Token type requested"},notice:"Get the balance of an account's Tokens."},"balanceOf(address)":{inputs:[{internalType:"address",name:"_owner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_owner:"An address for whom to query the balance"},returns:{_0:"The number of NFTs owned by `_owner`, possibly zero"},notice:"Count all NFTs assigned to an owner"},"balanceOfBatch(address[],uint256[])":{inputs:[{internalType:"address[]",name:"_owners",type:"address[]"},{internalType:"uint256[]",name:"_tokenIds",type:"uint256[]"}],name:"balanceOfBatch",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"view",type:"function",params:{_owners:"The addresses of the token holders",_tokenIds:"ID of the Tokens"},returns:{_0:"The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)"},notice:"Get the balance of multiple account/token pairs"},"createToken(uint256,address,address,bool,string,bool)":{inputs:[{internalType:"uint256",name:"_supply",type:"uint256"},{internalType:"address",name:"_receiver",type:"address"},{internalType:"address",name:"_settingOperator",type:"address"},{internalType:"bool",name:"_needTime",type:"bool"},{internalType:"string",name:"_uri",type:"string"},{internalType:"bool",name:"_erc20",type:"bool"}],name:"createToken",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{_erc20:"Set to `true` to create a erc20 adapter for token",_needTime:"Set to `true` if need to query holding time for token",_receiver:"Address that receives minted token",_settingOperator:"Address that can perform setTimeInterval  and set ERC20 Attribute",_supply:"The amount of token to create",_uri:"URI that points to token metadata"},returns:{_0:"Token ID"},notice:"Create a token with uri"},"createToken(uint256,address,address,bool,bool)":{inputs:[{internalType:"uint256",name:"_supply",type:"uint256"},{internalType:"address",name:"_receiver",type:"address"},{internalType:"address",name:"_settingOperator",type:"address"},{internalType:"bool",name:"_needTime",type:"bool"},{internalType:"bool",name:"_erc20",type:"bool"}],name:"createToken",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{_erc20:"Set to `true` to create a erc20 adapter for token",_needTime:"Set to `true` if need to query holding time for token",_receiver:"Address that receives minted token",_settingOperator:"Address that can perform setTimeInterval  and set ERC20 Attribute",_supply:"The amount of token to create"},returns:{_0:"Token ID"},notice:"Create a token without setting uri"},"createTokenWithRecording(uint256,address,address,bool,address,string,bool)":{inputs:[{internalType:"uint256",name:"_supply",type:"uint256"},{internalType:"address",name:"_receiver",type:"address"},{internalType:"address",name:"_settingOperator",type:"address"},{internalType:"bool",name:"_needTime",type:"bool"},{internalType:"address",name:"_recordingOperator",type:"address"},{internalType:"string",name:"_uri",type:"string"},{internalType:"bool",name:"_erc20",type:"bool"}],name:"createTokenWithRecording",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",details:"Recording token shares the same token ID with normal token",params:{_erc20:"Set to `true` to create a erc20 adapter for token",_needTime:"Set to `true` if need to query holding time for token",_receiver:"Address that receives minted token",_recordingOperator:"Address that can manage recording token",_settingOperator:"Address that can perform setTimeInterval  and set ERC20 Attribute",_supply:"The amount of token to create",_uri:"URI that points to token metadata"},returns:{_0:"Token ID"},notice:"Create both normal token and recording token with uri"},"createTokenWithRecording(uint256,address,address,bool,address,bool)":{inputs:[{internalType:"uint256",name:"_supply",type:"uint256"},{internalType:"address",name:"_receiver",type:"address"},{internalType:"address",name:"_settingOperator",type:"address"},{internalType:"bool",name:"_needTime",type:"bool"},{internalType:"address",name:"_recordingOperator",type:"address"},{internalType:"bool",name:"_erc20",type:"bool"}],name:"createTokenWithRecording",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",details:"Recording token shares the same token ID with normal token",params:{_erc20:"Set to `true` to create a erc20 adapter for token",_needTime:"Set to `true` if need to query holding time for token",_receiver:"Address that receives minted token",_recordingOperator:"Address that can manage recording token",_settingOperator:"Address that can perform setTimeInterval  and set ERC20 Attribute",_supply:"The amount of token to create"},returns:{_0:"Token ID"},notice:"Create both normal token and recording token without setting uri"},"getAdapter(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"getAdapter",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns zero address if does not have a adapter",params:{_tokenId:"Token ID to be queried"},returns:{_0:"ERC20 adapter contract address"},notice:"Queries the erc20 adapter contract address for a given token ID"},"getApproved(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"getApproved",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Throws if `_tokenId` is not a valid NFT.",params:{_tokenId:"The NFT to find the approved address for"},returns:{_0:"The approved address for this NFT, or the zero address if there is none"},notice:"Get the approved address for a single NFT"},"holdingTimeOf(address,uint256)":{inputs:[{internalType:"address",name:"_owner",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"holdingTimeOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"It throws if it's not a need-time token. The way how holding time is  calculated is by suming up (token amount) * (holding time in second)",params:{_owner:"Address to be queried",_tokenId:"Token ID of the token to be queried"},returns:{_0:"Holding time"},notice:"Queries accumulated holding time for a given owner and token"},"isApprovedForAll(address,address)":{inputs:[{internalType:"address",name:"_owner",type:"address"},{internalType:"address",name:"_operator",type:"address"}],name:"isApprovedForAll",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{_operator:"Address of authorized operator",_owner:"The owner of the Tokens"},returns:{_0:"True if the operator is approved, false if not"},notice:"Queries the approval status of an operator for a given owner."},"isTrustedForwarder(address)":{inputs:[{internalType:"address",name:"forwarder",type:"address"}],name:"isTrustedForwarder",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"return if the forwarder is trusted to forward relayed transactions to us. the forwarder is required to verify the sender's signature, and verify the call is not a replay."},"msgData()":{inputs:[],name:"msgData",outputs:[{internalType:"bytes",name:"",type:"bytes"},{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"nonpayable",type:"function"},"msgSender()":{inputs:[],name:"msgSender",outputs:[{internalType:"address payable",name:"",type:"address"}],stateMutability:"nonpayable",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"pure",type:"function",notice:"A descriptive name for a collection of NFTs in this contract"},"ownerOf(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"ownerOf",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"NFTs assigned to zero address or FT token are considered invalid,  and queries about them do throw.",params:{_tokenId:"The identifier for an NFT"},returns:{_0:"The address of the owner of the NFT"},notice:"Find the owner of an NFT"},"recordingBalanceOf(address,uint256)":{inputs:[{internalType:"address",name:"_owner",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"recordingBalanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_owner:"An address for whom to query the balance",_tokenId:"The token ID to be queried"},notice:"Count all recording token assigned to an address"},"recordingHoldingTimeOf(address,uint256)":{inputs:[{internalType:"address",name:"_owner",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"recordingHoldingTimeOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"It throws if it's not a need-time token. The way how holding time is  calculated is by suming up (token amount) * (holding time in second)It returns zero if it doesn't have a corresponding recording token",params:{_owner:"Address to be queried",_tokenId:"Token ID of the token to be queried"},returns:{_0:"Holding time"},notice:"Queries accumulated holding time for a given owner and recording token"},"recordingOperatorOf(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"recordingOperatorOf",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",params:{_tokenId:"Token ID to be queried"},returns:{_0:"The recording operator address"},notice:"Returns the recording operator of a token"},"recordingTransferFrom(address,address,uint256,uint256)":{inputs:[{internalType:"address",name:"_from",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"},{internalType:"uint256",name:"_value",type:"uint256"}],name:"recordingTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"If `_to` is zeroaddress or `msg.sender` is not recording operator,  it throwsa.",params:{_from:"Current owner of recording token",_to:"New owner",_tokenId:"The token to transfer",_value:"The amount to transfer"},notice:"Transfer recording token"},"relayCall()":{inputs:[],name:"relayCall",outputs:[],stateMutability:"nonpayable",type:"function"},"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)":{inputs:[{internalType:"address",name:"_from",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256[]",name:"_tokenIds",type:"uint256[]"},{internalType:"uint256[]",name:"_values",type:"uint256[]"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"safeBatchTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:'Caller must be approved to manage the tokens being transferred out of the `_from` account (see "Approval" section of the standard). MUST revert if `_to` is the zero address. MUST revert if length of `_tokenIds` is not the same as length of `_values`. MUST revert if any of the balance(s) of the holder(s) for token(s) in `_tokenIds` is lower than the respective amount(s) in `_values` sent to the recipient. MUST revert on any other error. MUST emit `TransferSingle` or `TransferBatch` event(s) such that all the balance changes are reflected (see "Safe Transfer Rules" section of the standard). Balance changes and events MUST follow the ordering of the arrays (_tokenIds[0]/_values[0] before _tokenIds[1]/_values[1], etc). After the above conditions for the transfer(s) in the batch are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call the relevant `ERC1155TokenReceiver` hook(s) on `_to` and act appropriately (see "Safe Transfer Rules" section of the standard).',params:{_data:"Additional data with no specified format, MUST be sent unaltered in call to the `ERC1155TokenReceiver` hook(s) on `_to`",_from:"Source address",_to:"Target address",_tokenIds:"IDs of each token type (order and length must match _values array)",_values:"Transfer amounts per token type (order and length must match _tokenIds array)"},notice:"Transfers `_values` amount(s) of `_tokenIds` from the `_from` address to the `_to` address specified (with safety call)."},"safeTransferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"_from",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:'This works identically to the other function with an extra data parameter,  except this function just sets data to "".',params:{_from:"The current owner of the NFT",_to:"The new owner",_tokenId:"The NFT to transfer"},notice:"Transfers the ownership of an NFT from one address to another address"},"safeTransferFrom(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"_from",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:'Throws unless `msg.sender` is the current owner, an authorized  operator, or the approved address for this NFT. Throws if `_from` is  not the current owner. Throws if `_to` is the zero address. Throws if  `_tokenId` is not a valid NFT. When transfer is complete, this function  checks if `_to` is a smart contract (code size > 0). If so, it calls  `onERC721Received` on `_to` and throws if the return value is not  `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`.',params:{_data:"Additional data with no specified format, sent in call to `_to`",_from:"The current owner of the NFT",_to:"The new owner",_tokenId:"The NFT to transfer"},notice:"Transfers the ownership of an NFT from one address to another address"},"safeTransferFrom(address,address,uint256,uint256,bytes)":{inputs:[{internalType:"address",name:"_from",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"},{internalType:"uint256",name:"_value",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:'Caller must be approved to manage the tokens being transferred out of the `_from` account (see "Approval" section of the standard). MUST revert if `_to` is the zero address. MUST revert if balance of holder for token `_tokenId` is lower than the `_value` sent. MUST revert on any other error. MUST emit the `TransferSingle` event to reflect the balance change (see "Safe Transfer Rules" section of the standard). After the above conditions are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call `onERC1155Received` on `_to` and act appropriately (see "Safe Transfer Rules" section of the standard).',params:{_data:"Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `_to`",_from:"Source address",_to:"Target address",_tokenId:"ID of the token type",_value:"Transfer amount"},notice:"Transfers `_value` amount of an `_tokenId` from the `_from` address to the `_to` address specified (with safety call)."},"setApprovalForAll(address,bool)":{inputs:[{internalType:"address",name:"_operator",type:"address"},{internalType:"bool",name:"_approved",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"MUST emit the ApprovalForAll event on success.",params:{_approved:"True if the operator is approved, false to revoke approval",_operator:"Address to add to the set of authorized operators"},notice:'Enable or disable approval for a third party ("operator") to manage all of the caller\'s tokens.'},"setERC20Attribute(uint256,string,string,uint8)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"},{internalType:"string",name:"_name",type:"string"},{internalType:"string",name:"_symbol",type:"string"},{internalType:"uint8",name:"_decimals",type:"uint8"}],name:"setERC20Attribute",outputs:[],stateMutability:"nonpayable",type:"function",details:"Throws if `msg.sender` is not authorized setting operator",params:{_decimals:"Number of decimals to use",_name:"Name of the token",_symbol:"Symbol of the token",_tokenId:"Corresponding token ID with erc20 adapter"},notice:"Set erc20 token attribute"},"setTimeInterval(uint256,uint128,uint128)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"},{internalType:"uint128",name:"_startTime",type:"uint128"},{internalType:"uint128",name:"_endTime",type:"uint128"}],name:"setTimeInterval",outputs:[],stateMutability:"nonpayable",type:"function",details:"Starting time must be greater than time at the momentTo save gas cost, here use uint128 to store time",params:{_endTime:"Ending time in unix time format",_startTime:"Starting time in unix time format"},notice:"Set starting time and ending time for token holding time calculation"},"settingOperatorOf(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"settingOperatorOf",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",params:{_tokenId:"Token ID to be queried"},returns:{_0:"The setting operator address"},notice:"Returns the setting operator of a token"},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"_interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"pure",type:"function",details:"Interface identification is specified in ERC-165. This function  uses less than 30,000 gas.",params:{_interfaceId:"The interface identifier, as specified in ERC-165"},returns:{_0:"`true` if the contract implements `_interfaceId`,  `false` otherwise"},notice:"Query if a contract implements an interface"},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"pure",type:"function",notice:"An abbreviated name for NFTs in this contract"},"template()":{inputs:[],name:"template",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"timeIntervalOf(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"timeIntervalOf",outputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_tokenId:"Token ID to be queried"},returns:{_0:"The starting time in unix time",_1:"The ending time in unix time"},notice:"Returns the starting time and ending time of token holding time calculation"},"tokenURI(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"tokenURI",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:'Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC  3986. The URI may point to a JSON file that conforms to the "ERC721  Metadata JSON Schema".',notice:"A distinct Uniform Resource Identifier (URI) for a given asset."},"totalSupply(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_tokenId:"Token ID to be queried"},returns:{_0:"Total supply of a token"},notice:"Returns total supply of a token"},"transferByAdapter(address,address,uint256,uint256)":{inputs:[{internalType:"address",name:"_from",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"},{internalType:"uint256",name:"_value",type:"uint256"}],name:"transferByAdapter",outputs:[],stateMutability:"nonpayable",type:"function",details:"This function should only be called from erc20 adapter",params:{_from:"Source address",_to:"Target address",_tokenId:"ID of the token type",_value:"Transfer amount"},notice:"Transfers `_value` amount of `_tokenId` from `_from` to `_to`"},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"_from",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"transferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Throws unless `msg.sender` is the current owner, an authorized  operator, or the approved address for this NFT. Throws if `_from` is  not the current owner. Throws if `_to` is the zero address. Throws if  `_tokenId` is not a valid NFT.",params:{_from:"The current owner of the NFT",_to:"The new owner",_tokenId:"The NFT to transfer"},notice:"Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE  THEY MAY BE PERMANENTLY LOST"},"trustedForwarder()":{inputs:[],name:"trustedForwarder",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"uri(uint256)":{inputs:[{internalType:"uint256",name:"_tokenId",type:"uint256"}],name:"uri",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:'URIs are defined in RFC 3986. The URI MUST point to a JSON file that conforms to the "ERC-1155 Metadata URI JSON Schema".        ',returns:{_0:"URI string"},notice:"A distinct Uniform Resource Identifier (URI) for a given token."},"versionRecipient()":{inputs:[],name:"versionRecipient",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"}}},"contracts/upgradeable/GSN/ContextUpgradeable.sol:ContextUpgradeable":{source:"contracts/upgradeable/GSN/ContextUpgradeable.sol",name:"ContextUpgradeable"},"contracts/upgradeable/access/AccessControlUpgradeable.sol:AccessControlUpgradeable":{source:"contracts/upgradeable/access/AccessControlUpgradeable.sol",name:"AccessControlUpgradeable",details:'Contract module that allows children to implement role-based access control mechanisms. Roles are referred to by their `bytes32` identifier. These should be exposed in the external API and be unique. The best way to achieve this is by using `public constant` hash digests: ``` bytes32 public constant MY_ROLE = keccak256("MY_ROLE"); ``` Roles can be used to represent a set of permissions. To restrict access to a function call, use {hasRole}: ``` function foo() public {     require(hasRole(MY_ROLE, msg.sender));     ... } ``` Roles can be granted and revoked dynamically via the {grantRole} and {revokeRole} functions. Each role has an associated admin role, and only accounts that have a role\'s admin role can call {grantRole} and {revokeRole}. By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means that only accounts with this role will be able to grant or revoke other roles. More complex role relationships can be created by using {_setRoleAdmin}. WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to grant and revoke this role. Extra precautions should be taken to secure accounts that have been granted it.',events:{"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event",details:"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this. _Available since v3.1._"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event",details:"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {_setupRole}."},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event",details:"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)"}},methods:{"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getRoleMember(bytes32,uint256)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"uint256",name:"index",type:"uint256"}],name:"getRoleMember",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information."},"getRoleMemberCount(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleMemberCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role."},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."}}},"contracts/upgradeable/proxy/Initializable.sol:Initializable":{source:"contracts/upgradeable/proxy/Initializable.sol",name:"Initializable",details:"This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.  TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.  CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure that all initializers are idempotent. This is not verified automatically as constructors are by Solidity."},"contracts/upgradeable/utils/AddressUpgradeable.sol:AddressUpgradeable":{source:"contracts/upgradeable/utils/AddressUpgradeable.sol",name:"AddressUpgradeable",details:"Collection of functions related to the address type"},"contracts/upgradeable/utils/EnumerableSetUpgradeable.sol:EnumerableSetUpgradeable":{source:"contracts/upgradeable/utils/EnumerableSetUpgradeable.sol",name:"EnumerableSetUpgradeable",details:"Library for managing https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive types. Sets have the following properties: - Elements are added, removed, and checked for existence in constant time (O(1)). - Elements are enumerated in O(n). No guarantees are made on the ordering. ``` contract Example {     // Add the library methods     using EnumerableSet for EnumerableSet.AddressSet;     // Declare a set state variable     EnumerableSet.AddressSet private mySet; } ``` As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`) and `uint256` (`UintSet`) are supported."},"hardhat/console.sol:console":{source:"hardhat/console.sol",name:"console"}},gt=new Ve({routes:[{path:"/",component:bt,props:()=>({json:_t})},{path:"*",component:mt,props:e=>({json:_t[e.path.slice(1)]})}]});new a.a({el:"#app",router:gt,mounted(){document.dispatchEvent(new Event("render-event"))},render:e=>e(Ke)})},function(e,t,n){"use strict";function a(e,t){for(var n=[],a={},r=0;r<t.length;r++){var s=t[r],i=s[0],o={id:e+":"+r,css:s[1],media:s[2],sourceMap:s[3]};a[i]?a[i].parts.push(o):n.push(a[i]={id:i,parts:[o]})}return n}n.r(t),n.d(t,"default",(function(){return c}));var r="undefined"!=typeof document;if("undefined"!=typeof DEBUG&&DEBUG&&!r)throw new Error("vue-style-loader cannot be used in a non-browser environment. Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.");var s={},i=r&&(document.head||document.getElementsByTagName("head")[0]),o=null,d=0,u=!1,p=function(){},l=null,y="undefined"!=typeof navigator&&/msie [6-9]\b/.test(navigator.userAgent.toLowerCase());function c(e,t,n,r){u=n,l=r||{};var i=a(e,t);return m(i),function(t){for(var n=[],r=0;r<i.length;r++){var o=i[r];(d=s[o.id]).refs--,n.push(d)}t?m(i=a(e,t)):i=[];for(r=0;r<n.length;r++){var d;if(0===(d=n[r]).refs){for(var u=0;u<d.parts.length;u++)d.parts[u]();delete s[d.id]}}}}function m(e){for(var t=0;t<e.length;t++){var n=e[t],a=s[n.id];if(a){a.refs++;for(var r=0;r<a.parts.length;r++)a.parts[r](n.parts[r]);for(;r<n.parts.length;r++)a.parts.push(h(n.parts[r]));a.parts.length>n.parts.length&&(a.parts.length=n.parts.length)}else{var i=[];for(r=0;r<n.parts.length;r++)i.push(h(n.parts[r]));s[n.id]={id:n.id,refs:1,parts:i}}}}function f(){var e=document.createElement("style");return e.type="text/css",i.appendChild(e),e}function h(e){var t,n,a=document.querySelector('style[data-vue-ssr-id~="'+e.id+'"]');if(a){if(u)return p;a.parentNode.removeChild(a)}if(y){var r=d++;a=o||(o=f()),t=b.bind(null,a,r,!1),n=b.bind(null,a,r,!0)}else a=f(),t=_.bind(null,a),n=function(){a.parentNode.removeChild(a)};return t(e),function(a){if(a){if(a.css===e.css&&a.media===e.media&&a.sourceMap===e.sourceMap)return;t(e=a)}else n()}}var v,T=(v=[],function(e,t){return v[e]=t,v.filter(Boolean).join("\n")});function b(e,t,n,a){var r=n?"":a.css;if(e.styleSheet)e.styleSheet.cssText=T(t,r);else{var s=document.createTextNode(r),i=e.childNodes;i[t]&&e.removeChild(i[t]),i.length?e.insertBefore(s,i[t]):e.appendChild(s)}}function _(e,t){var n=t.css,a=t.media,r=t.sourceMap;if(a&&e.setAttribute("media",a),l.ssrId&&e.setAttribute("data-vue-ssr-id",t.id),r&&(n+="\n/*# sourceURL="+r.sources[0]+" */",n+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(r))))+" */"),e.styleSheet)e.styleSheet.cssText=n;else{for(;e.firstChild;)e.removeChild(e.firstChild);e.appendChild(document.createTextNode(n))}}}]);